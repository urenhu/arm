; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\tasks.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tasks.crf ..\free_rtos\tasks.c]
                          THUMB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;2378   
;;;2379   static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
000000  b570              PUSH     {r4-r6,lr}
;;;2380   {
;;;2381   	/* The list item will be inserted in wake time order. */
;;;2382   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000002  4c0b              LDR      r4,|L1.48|
000004  4605              MOV      r5,r0                 ;2380
000006  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
;;;2383   
;;;2384   	if( xTimeToWake < xTickCount )
000008  6045              STR      r5,[r0,#4]
00000a  68e0              LDR      r0,[r4,#0xc]  ; xTickCount
;;;2385   	{
;;;2386   		/* Wake time has overflowed.  Place this item in the overflow list. */
;;;2387   		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
;;;2388   	}
;;;2389   	else
;;;2390   	{
;;;2391   		/* The wake time has not overflowed, so we can use the current block list. */
;;;2392   		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
00000c  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
00000e  4285              CMP      r5,r0                 ;2384
000010  d205              BCS      |L1.30|
000012  6ba0              LDR      r0,[r4,#0x38]         ;2387  ; pxOverflowDelayedTaskList
000014  e8bd4070          POP      {r4-r6,lr}            ;2387
000018  1d09              ADDS     r1,r1,#4              ;2387
00001a  f7ffbffe          B.W      vListInsert
                  |L1.30|
00001e  6b60              LDR      r0,[r4,#0x34]  ; pxDelayedTaskList
000020  1d09              ADDS     r1,r1,#4
000022  f7fffffe          BL       vListInsert
;;;2393   
;;;2394   		/* If the task entering the blocked state was placed at the head of the
;;;2395   		list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;2396   		too. */
;;;2397   		if( xTimeToWake < xNextTaskUnblockTime )
000026  6b20              LDR      r0,[r4,#0x30]  ; xNextTaskUnblockTime
000028  4285              CMP      r5,r0
00002a  d200              BCS      |L1.46|
;;;2398   		{
;;;2399   			xNextTaskUnblockTime = xTimeToWake;
00002c  6325              STR      r5,[r4,#0x30]  ; xNextTaskUnblockTime
                  |L1.46|
;;;2400   		}
;;;2401   	}
;;;2402   }
00002e  bd70              POP      {r4-r6,pc}
;;;2403   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.48|
                          DCD      ||.data||

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;2343   
;;;2344   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2345   {
;;;2346   	#if ( INCLUDE_vTaskDelete == 1 )
;;;2347   	{
;;;2348   		portBASE_TYPE xListIsEmpty;
;;;2349   
;;;2350   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;2351   		too often in the idle task. */
;;;2352   		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
;;;2353   		{
;;;2354   			vTaskSuspendAll();
;;;2355   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000002  4e12              LDR      r6,|L2.76|
;;;2356   			xTaskResumeAll();
;;;2357   
;;;2358   			if( xListIsEmpty == pdFALSE )
;;;2359   			{
;;;2360   				tskTCB *pxTCB;
;;;2361   
;;;2362   				taskENTER_CRITICAL();
;;;2363   				{
;;;2364   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
;;;2365   					uxListRemove( &( pxTCB->xGenericListItem ) );
;;;2366   					--uxCurrentNumberOfTasks;
000004  4c12              LDR      r4,|L2.80|
000006  e01a              B        |L2.62|
                  |L2.8|
000008  f7fffffe          BL       vTaskSuspendAll
00000c  6830              LDR      r0,[r6,#0]            ;2355  ; xTasksWaitingTermination
00000e  b1d0              CBZ      r0,|L2.70|
000010  f7fffffe          BL       xTaskResumeAll
000014  f7fffffe          BL       vPortEnterCritical
000018  68f0              LDR      r0,[r6,#0xc]          ;2364  ; xTasksWaitingTermination
00001a  68c5              LDR      r5,[r0,#0xc]          ;2364
00001c  1d28              ADDS     r0,r5,#4              ;2365
00001e  f7fffffe          BL       uxListRemove
000022  68a0              LDR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
000024  1e40              SUBS     r0,r0,#1
000026  60a0              STR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
;;;2367   					--uxTasksDeleted;
000028  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
00002a  1e40              SUBS     r0,r0,#1
00002c  6060              STR      r0,[r4,#4]  ; uxTasksDeleted
;;;2368   				}
;;;2369   				taskEXIT_CRITICAL();
00002e  f7fffffe          BL       vPortExitCritical
000032  6b28              LDR      r0,[r5,#0x30]
000034  f7fffffe          BL       vPortFree
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       vPortFree
                  |L2.62|
00003e  6860              LDR      r0,[r4,#4]            ;2352  ; uxTasksDeleted
000040  2800              CMP      r0,#0                 ;2352
000042  d1e1              BNE      |L2.8|
;;;2370   
;;;2371   				prvDeleteTCB( pxTCB );
;;;2372   			}
;;;2373   		}
;;;2374   	}
;;;2375   	#endif /* vTaskDelete */
;;;2376   }
000044  bd70              POP      {r4-r6,pc}
                  |L2.70|
000046  f7fffffe          BL       xTaskResumeAll
00004a  e7f8              B        |L2.62|
;;;2377   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.76|
                          DCD      ||.bss||+0xa0
                  |L2.80|
                          DCD      ||.data||

                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;2095    */
;;;2096   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  4c04              LDR      r4,|L3.20|
;;;2097   {
;;;2098   	/* Stop warnings. */
;;;2099   	( void ) pvParameters;
;;;2100   
;;;2101   	for( ;; )
;;;2102   	{
;;;2103   		/* See if any tasks have been deleted. */
;;;2104   		prvCheckTasksWaitingTermination();
000002  bf00              NOP      
                  |L3.4|
000004  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;2105   
;;;2106   		#if ( configUSE_PREEMPTION == 0 )
;;;2107   		{
;;;2108   			/* If we are not using preemption we keep forcing a task switch to
;;;2109   			see if any other task has become available.  If we are using
;;;2110   			preemption we don't need to do this as any task becoming available
;;;2111   			will automatically get the processor anyway. */
;;;2112   			taskYIELD();
;;;2113   		}
;;;2114   		#endif /* configUSE_PREEMPTION */
;;;2115   
;;;2116   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;2117   		{
;;;2118   			/* When using preemption tasks of equal priority will be
;;;2119   			timesliced.  If a task that is sharing the idle priority is ready
;;;2120   			to run then the idle task should yield before the end of the
;;;2121   			timeslice.
;;;2122   
;;;2123   			A critical region is not required here as we are just reading from
;;;2124   			the list, and an occasional incorrect value will not matter.  If
;;;2125   			the ready list at the idle priority contains more than one task
;;;2126   			then a task other than the idle task is ready to execute. */
;;;2127   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
000008  6820              LDR      r0,[r4,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d9fa              BLS      |L3.4|
;;;2128   			{
;;;2129   				taskYIELD();
00000e  f7fffffe          BL       vPortYield
000012  e7f7              B        |L3.4|
;;;2130   			}
;;;2131   		}
;;;2132   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;2133   
;;;2134   		#if ( configUSE_IDLE_HOOK == 1 )
;;;2135   		{
;;;2136   			extern void vApplicationIdleHook( void );
;;;2137   
;;;2138   			/* Call the user defined function from within the idle task.  This
;;;2139   			allows the application designer to add background functionality
;;;2140   			without the overhead of a separate task.
;;;2141   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;2142   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;2143   			vApplicationIdleHook();
;;;2144   		}
;;;2145   		#endif /* configUSE_IDLE_HOOK */
;;;2146   
;;;2147   		/* This conditional compilation should use inequality to 0, not equality
;;;2148   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;2149   		user defined low power mode	implementations require
;;;2150   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;2151   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;2152   		{
;;;2153   		portTickType xExpectedIdleTime;
;;;2154   
;;;2155   			/* It is not desirable to suspend then resume the scheduler on
;;;2156   			each iteration of the idle task.  Therefore, a preliminary
;;;2157   			test of the expected idle time is performed without the
;;;2158   			scheduler suspended.  The result here is not necessarily
;;;2159   			valid. */
;;;2160   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2161   
;;;2162   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2163   			{
;;;2164   				vTaskSuspendAll();
;;;2165   				{
;;;2166   					/* Now the scheduler is suspended, the expected idle
;;;2167   					time can be sampled again, and this time its value can
;;;2168   					be used. */
;;;2169   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;2170   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;2171   
;;;2172   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;2173   					{
;;;2174   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;2175   					}
;;;2176   				}
;;;2177   				xTaskResumeAll();
;;;2178   			}
;;;2179   		}
;;;2180   		#endif /* configUSE_TICKLESS_IDLE */
;;;2181   	}
;;;2182   } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
;;;2183   /*-----------------------------------------------------------*/
                          ENDP

                  |L3.20|
                          DCD      ||.bss||

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;1452   
;;;1453   unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L4.8|
;;;1454   {
;;;1455   	/* A critical section is not required because the variables are of type
;;;1456   	portBASE_TYPE. */
;;;1457   	return uxCurrentNumberOfTasks;
000002  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;1458   }
000004  4770              BX       lr
;;;1459   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;906    
;;;907    	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
000000  b510              PUSH     {r4,lr}
;;;908    	{
000002  4604              MOV      r4,r0
;;;909    	tskTCB *pxTCB;
;;;910    	unsigned portBASE_TYPE uxReturn;
;;;911    
;;;912    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;913    		{
;;;914    			/* If null is passed in here then we are changing the
;;;915    			priority of the calling function. */
;;;916    			pxTCB = prvGetTCBFromHandle( xTask );
000008  b90c              CBNZ     r4,|L5.14|
00000a  4803              LDR      r0,|L5.24|
00000c  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L5.14|
;;;917    			uxReturn = pxTCB->uxPriority;
00000e  6ae4              LDR      r4,[r4,#0x2c]
;;;918    		}
;;;919    		taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;920    
;;;921    		return uxReturn;
000014  4620              MOV      r0,r4
;;;922    	}
000016  bd10              POP      {r4,pc}
;;;923    
                          ENDP

                  |L5.24|
                          DCD      ||.data||

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;792    
;;;793    	void vTaskDelay( portTickType xTicksToDelay )
000000  b510              PUSH     {r4,lr}
;;;794    	{
000002  0002              MOVS     r2,r0
000004  d00f              BEQ      |L6.38|
;;;795    	portTickType xTimeToWake;
;;;796    	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
;;;797    
;;;798    		/* A delay time of zero just forces a reschedule. */
;;;799    		if( xTicksToDelay > ( portTickType ) 0U )
;;;800    		{
;;;801    			vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;802    			{
;;;803    				traceTASK_DELAY();
;;;804    
;;;805    				/* A task that is removed from the event list while the
;;;806    				scheduler is suspended will not get placed in the ready
;;;807    				list or removed from the blocked list until the scheduler
;;;808    				is resumed.
;;;809    
;;;810    				This task cannot be in an event list as it is the currently
;;;811    				executing task. */
;;;812    
;;;813    				/* Calculate the time to wake - this may overflow but this is
;;;814    				not a problem. */
;;;815    				xTimeToWake = xTickCount + xTicksToDelay;
00000a  4809              LDR      r0,|L6.48|
00000c  68c1              LDR      r1,[r0,#0xc]  ; xTickCount
;;;816    
;;;817    				/* We must remove ourselves from the ready list before adding
;;;818    				ourselves to the blocked list as the same list item is used for
;;;819    				both lists. */
;;;820    				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  188c              ADDS     r4,r1,r2              ;815
000012  1d00              ADDS     r0,r0,#4
000014  f7fffffe          BL       uxListRemove
;;;821    				{
;;;822    					/* The current task must be in a ready list, so there is
;;;823    					no need to check, and the port reset macro can be called
;;;824    					directly. */
;;;825    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;826    				}
;;;827    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;828    			}
;;;829    			xAlreadyYielded = xTaskResumeAll();
00001e  f7fffffe          BL       xTaskResumeAll
000022  2800              CMP      r0,#0
000024  d103              BNE      |L6.46|
                  |L6.38|
;;;830    		}
;;;831    
;;;832    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;833    		have put ourselves to sleep. */
;;;834    		if( xAlreadyYielded == pdFALSE )
;;;835    		{
;;;836    			portYIELD_WITHIN_API();
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      vPortYield
                  |L6.46|
;;;837    		}
;;;838    	}
00002e  bd10              POP      {r4,pc}
;;;839    
                          ENDP

                  |L6.48|
                          DCD      ||.data||

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;720    
;;;721    	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
000000  b510              PUSH     {r4,lr}
;;;722    	{
000002  460b              MOV      r3,r1
000004  4602              MOV      r2,r0
;;;723    	portTickType xTimeToWake;
;;;724    	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
;;;725    
;;;726    		configASSERT( pxPreviousWakeTime );
;;;727    		configASSERT( ( xTimeIncrement > 0U ) );
;;;728    
;;;729    		vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;730    		{
;;;731    			/* Generate the tick time at which the task wants to wake. */
;;;732    			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00000a  6810              LDR      r0,[r2,#0]
;;;733    
;;;734    			if( xTickCount < *pxPreviousWakeTime )
00000c  490f              LDR      r1,|L7.76|
00000e  18c4              ADDS     r4,r0,r3              ;732
000010  68cb              LDR      r3,[r1,#0xc]  ; xTickCount
000012  4298              CMP      r0,r3
000014  d905              BLS      |L7.34|
;;;735    			{
;;;736    				/* The tick count has overflowed since this function was
;;;737    				lasted called.  In this case the only time we should ever
;;;738    				actually delay is if the wake time has also	overflowed,
;;;739    				and the wake time is greater than the tick time.  When this
;;;740    				is the case it is as if neither time had overflowed. */
;;;741    				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
000016  42a0              CMP      r0,r4
000018  d90e              BLS      |L7.56|
                  |L7.26|
00001a  68c8              LDR      r0,[r1,#0xc]  ; xTickCount
00001c  4284              CMP      r4,r0
00001e  d802              BHI      |L7.38|
000020  e00a              B        |L7.56|
                  |L7.34|
;;;742    				{
;;;743    					xShouldDelay = pdTRUE;
;;;744    				}
;;;745    			}
;;;746    			else
;;;747    			{
;;;748    				/* The tick time has not overflowed.  In this case we will
;;;749    				delay if either the wake time has overflowed, and/or the
;;;750    				tick time is less than the wake time. */
;;;751    				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
000022  42a0              CMP      r0,r4
000024  d9f9              BLS      |L7.26|
                  |L7.38|
;;;752    				{
;;;753    					xShouldDelay = pdTRUE;
;;;754    				}
;;;755    			}
;;;756    
;;;757    			/* Update the wake time ready for the next call. */
;;;758    			*pxPreviousWakeTime = xTimeToWake;
;;;759    
;;;760    			if( xShouldDelay != pdFALSE )
;;;761    			{
;;;762    				traceTASK_DELAY_UNTIL();
;;;763    
;;;764    				/* We must remove ourselves from the ready list before adding
;;;765    				ourselves to the blocked list as the same list item is used for
;;;766    				both lists. */
;;;767    				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
000026  6014              STR      r4,[r2,#0]
000028  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
00002a  1d00              ADDS     r0,r0,#4
00002c  f7fffffe          BL       uxListRemove
;;;768    				{
;;;769    					/* The current task must be in a ready list, so there is
;;;770    					no need to check, and the port reset macro can be called
;;;771    					directly. */
;;;772    					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;773    				}
;;;774    
;;;775    				prvAddCurrentTaskToDelayedList( xTimeToWake );
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       prvAddCurrentTaskToDelayedList
000036  e000              B        |L7.58|
                  |L7.56|
000038  6014              STR      r4,[r2,#0]            ;758
                  |L7.58|
;;;776    			}
;;;777    		}
;;;778    		xAlreadyYielded = xTaskResumeAll();
00003a  f7fffffe          BL       xTaskResumeAll
;;;779    
;;;780    		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;781    		have put ourselves to sleep. */
;;;782    		if( xAlreadyYielded == pdFALSE )
00003e  2800              CMP      r0,#0
000040  d103              BNE      |L7.74|
;;;783    		{
;;;784    			portYIELD_WITHIN_API();
000042  e8bd4010          POP      {r4,lr}
000046  f7ffbffe          B.W      vPortYield
                  |L7.74|
;;;785    		}
;;;786    	}
00004a  bd10              POP      {r4,pc}
;;;787    
                          ENDP

                  |L7.76|
                          DCD      ||.data||

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;659    
;;;660    	void vTaskDelete( xTaskHandle xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;661    	{
000002  4606              MOV      r6,r0
;;;662    	tskTCB *pxTCB;
;;;663    
;;;664    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;665    		{
;;;666    			/* Ensure a yield is performed if the current task is being
;;;667    			deleted. */
;;;668    			if( xTaskToDelete == pxCurrentTCB )
000008  4c14              LDR      r4,|L8.92|
00000a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00000c  4286              CMP      r6,r0
00000e  d101              BNE      |L8.20|
;;;669    			{
;;;670    				xTaskToDelete = NULL;
000010  2600              MOVS     r6,#0
000012  e01f              B        |L8.84|
                  |L8.20|
;;;671    			}
;;;672    
;;;673    			/* If null is passed in here then we are deleting ourselves. */
;;;674    			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000014  b1f6              CBZ      r6,|L8.84|
000016  4635              MOV      r5,r6
                  |L8.24|
;;;675    
;;;676    			/* Remove task from the ready list and place in the	termination list.
;;;677    			This will stop the task from be scheduled.  The idle task will check
;;;678    			the termination list and free up any memory allocated by the
;;;679    			scheduler for the TCB and stack. */
;;;680    			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
000018  1d28              ADDS     r0,r5,#4
00001a  f7fffffe          BL       uxListRemove
;;;681    			{
;;;682    				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;683    			}
;;;684    
;;;685    			/* Is the task waiting on an event also? */
;;;686    			if( pxTCB->xEventListItem.pvContainer != NULL )
00001e  6aa8              LDR      r0,[r5,#0x28]
000020  b118              CBZ      r0,|L8.42|
;;;687    			{
;;;688    				uxListRemove( &( pxTCB->xEventListItem ) );
000022  f1050018          ADD      r0,r5,#0x18
000026  f7fffffe          BL       uxListRemove
                  |L8.42|
;;;689    			}
;;;690    
;;;691    			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
00002a  1d29              ADDS     r1,r5,#4
00002c  480c              LDR      r0,|L8.96|
00002e  f7fffffe          BL       vListInsertEnd
;;;692    
;;;693    			/* Increment the ucTasksDeleted variable so the idle task knows
;;;694    			there is a task that has been deleted and that it should therefore
;;;695    			check the xTasksWaitingTermination list. */
;;;696    			++uxTasksDeleted;
000032  6860              LDR      r0,[r4,#4]  ; uxTasksDeleted
000034  1c40              ADDS     r0,r0,#1
000036  6060              STR      r0,[r4,#4]  ; uxTasksDeleted
;;;697    
;;;698    			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
;;;699    			can detect that the task lists need re-generating. */
;;;700    			uxTaskNumber++;
000038  6ae0              LDR      r0,[r4,#0x2c]  ; uxTaskNumber
00003a  1c40              ADDS     r0,r0,#1
;;;701    
;;;702    			traceTASK_DELETE( pxTCB );
;;;703    		}
;;;704    		taskEXIT_CRITICAL();
00003c  62e0              STR      r0,[r4,#0x2c]  ; uxTaskNumber
00003e  f7fffffe          BL       vPortExitCritical
;;;705    
;;;706    		/* Force a reschedule if we have just deleted the current task. */
;;;707    		if( xSchedulerRunning != pdFALSE )
000042  69a0              LDR      r0,[r4,#0x18]  ; xSchedulerRunning
000044  2800              CMP      r0,#0
000046  d007              BEQ      |L8.88|
;;;708    		{
;;;709    			if( ( void * ) xTaskToDelete == NULL )
000048  2e00              CMP      r6,#0
00004a  d105              BNE      |L8.88|
;;;710    			{
;;;711    				portYIELD_WITHIN_API();
00004c  e8bd4070          POP      {r4-r6,lr}
000050  f7ffbffe          B.W      vPortYield
                  |L8.84|
000054  6825              LDR      r5,[r4,#0]            ;674  ; pxCurrentTCB
000056  e7df              B        |L8.24|
                  |L8.88|
;;;712    			}
;;;713    		}
;;;714    	}
000058  bd70              POP      {r4-r6,pc}
;;;715    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      ||.data||
                  |L8.96|
                          DCD      ||.bss||+0xa0

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1300   
;;;1301   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1302   {
;;;1303   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1304   	routine so the original ISRs can be restored if necessary.  The port
;;;1305   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1306   	portDISABLE_INTERRUPTS();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;1307   	xSchedulerRunning = pdFALSE;
000006  4903              LDR      r1,|L9.20|
000008  2000              MOVS     r0,#0
00000a  6188              STR      r0,[r1,#0x18]  ; xSchedulerRunning
;;;1308   	vPortEndScheduler();
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      vPortEndScheduler
;;;1309   }
;;;1310   /*----------------------------------------------------------*/
                          ENDP

                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.vTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  vTaskIncrementTick PROC
;;;1641   
;;;1642   void vTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1643   {
;;;1644   tskTCB * pxTCB;
;;;1645   
;;;1646   	/* Called by the portable layer each time a tick interrupt occurs.
;;;1647   	Increments the tick then checks to see if the new tick value will cause any
;;;1648   	tasks to be unblocked. */
;;;1649   	traceTASK_INCREMENT_TICK( xTickCount );
;;;1650   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000004  4c24              LDR      r4,|L10.152|
000006  69e0              LDR      r0,[r4,#0x1c]  ; uxSchedulerSuspended
000008  b120              CBZ      r0,|L10.20|
;;;1651   	{
;;;1652   		++xTickCount;
;;;1653   		if( xTickCount == ( portTickType ) 0U )
;;;1654   		{
;;;1655   			xList *pxTemp;
;;;1656   
;;;1657   			/* Tick count has overflowed so we need to swap the delay lists.
;;;1658   			If there are any items in pxDelayedTaskList here then there is
;;;1659   			an error! */
;;;1660   			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
;;;1661   
;;;1662   			pxTemp = pxDelayedTaskList;
;;;1663   			pxDelayedTaskList = pxOverflowDelayedTaskList;
;;;1664   			pxOverflowDelayedTaskList = pxTemp;
;;;1665   			xNumOfOverflows++;
;;;1666   
;;;1667   			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;1668   			{
;;;1669   				/* The new current delayed list is empty.  Set
;;;1670   				xNextTaskUnblockTime to the maximum possible value so it is
;;;1671   				extremely unlikely that the
;;;1672   				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;1673   				there is an item in the delayed list. */
;;;1674   				xNextTaskUnblockTime = portMAX_DELAY;
;;;1675   			}
;;;1676   			else
;;;1677   			{
;;;1678   				/* The new current delayed list is not empty, get the value of
;;;1679   				the item at the head of the delayed list.  This is the time at
;;;1680   				which the task at the head of the delayed list should be removed
;;;1681   				from the Blocked state. */
;;;1682   				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;1683   				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
;;;1684   			}
;;;1685   		}
;;;1686   
;;;1687   		/* See if this tick has made a timeout expire. */
;;;1688   		prvCheckDelayedTasks();
;;;1689   	}
;;;1690   	else
;;;1691   	{
;;;1692   		++uxMissedTicks;
00000a  6a20              LDR      r0,[r4,#0x20]  ; uxMissedTicks
00000c  1c40              ADDS     r0,r0,#1
00000e  6220              STR      r0,[r4,#0x20]  ; uxMissedTicks
                  |L10.16|
;;;1693   
;;;1694   		/* The tick hook gets called at regular intervals, even if the
;;;1695   		scheduler is locked. */
;;;1696   		#if ( configUSE_TICK_HOOK == 1 )
;;;1697   		{
;;;1698   			vApplicationTickHook();
;;;1699   		}
;;;1700   		#endif
;;;1701   	}
;;;1702   
;;;1703   	#if ( configUSE_TICK_HOOK == 1 )
;;;1704   	{
;;;1705   		/* Guard against the tick hook being called when the missed tick
;;;1706   		count is being unwound (when the scheduler is being unlocked. */
;;;1707   		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
;;;1708   		{
;;;1709   			vApplicationTickHook();
;;;1710   		}
;;;1711   	}
;;;1712   	#endif /* configUSE_TICK_HOOK */
;;;1713   }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L10.20|
000014  68e0              LDR      r0,[r4,#0xc]          ;1652  ; xTickCount
000016  1c40              ADDS     r0,r0,#1              ;1652
000018  60e0              STR      r0,[r4,#0xc]          ;1652  ; xTickCount
00001a  68e0              LDR      r0,[r4,#0xc]          ;1653  ; xTickCount
00001c  f04f35ff          MOV      r5,#0xffffffff        ;1674
000020  b970              CBNZ     r0,|L10.64|
000022  6b60              LDR      r0,[r4,#0x34]         ;1662  ; pxDelayedTaskList
000024  6ba1              LDR      r1,[r4,#0x38]         ;1663  ; pxOverflowDelayedTaskList
000026  6361              STR      r1,[r4,#0x34]         ;1663  ; pxDelayedTaskList
000028  63a0              STR      r0,[r4,#0x38]         ;1664  ; pxOverflowDelayedTaskList
00002a  6aa0              LDR      r0,[r4,#0x28]         ;1665  ; xNumOfOverflows
00002c  1c40              ADDS     r0,r0,#1              ;1665
00002e  62a0              STR      r0,[r4,#0x28]         ;1665  ; xNumOfOverflows
000030  6b60              LDR      r0,[r4,#0x34]         ;1667  ; pxDelayedTaskList
000032  6800              LDR      r0,[r0,#0]            ;1667
000034  b1a8              CBZ      r0,|L10.98|
000036  6b60              LDR      r0,[r4,#0x34]         ;1682  ; pxDelayedTaskList
000038  68c0              LDR      r0,[r0,#0xc]          ;1682
00003a  68c0              LDR      r0,[r0,#0xc]          ;1682
00003c  6840              LDR      r0,[r0,#4]            ;1683
00003e  6320              STR      r0,[r4,#0x30]         ;1683  ; xNextTaskUnblockTime
                  |L10.64|
000040  68e0              LDR      r0,[r4,#0xc]          ;1688  ; xTickCount
000042  6b21              LDR      r1,[r4,#0x30]         ;1688  ; xNextTaskUnblockTime
000044  4288              CMP      r0,r1                 ;1688
000046  d3e3              BCC      |L10.16|
000048  4f14              LDR      r7,|L10.156|
                  |L10.74|
00004a  6b60              LDR      r0,[r4,#0x34]         ;1688  ; pxDelayedTaskList
00004c  6800              LDR      r0,[r0,#0]            ;1688
00004e  b150              CBZ      r0,|L10.102|
000050  6b60              LDR      r0,[r4,#0x34]         ;1688  ; pxDelayedTaskList
000052  68c0              LDR      r0,[r0,#0xc]          ;1688
000054  68c6              LDR      r6,[r0,#0xc]          ;1688
000056  68e1              LDR      r1,[r4,#0xc]          ;1688  ; xTickCount
000058  6870              LDR      r0,[r6,#4]            ;1688
00005a  4281              CMP      r1,r0                 ;1688
00005c  d205              BCS      |L10.106|
00005e  6320              STR      r0,[r4,#0x30]         ;1688  ; xNextTaskUnblockTime
000060  e7d6              B        |L10.16|
                  |L10.98|
000062  6325              STR      r5,[r4,#0x30]         ;1674  ; xNextTaskUnblockTime
000064  e7ec              B        |L10.64|
                  |L10.102|
000066  6325              STR      r5,[r4,#0x30]         ;1688  ; xNextTaskUnblockTime
000068  e7d2              B        |L10.16|
                  |L10.106|
00006a  1d30              ADDS     r0,r6,#4              ;1688
00006c  f7fffffe          BL       uxListRemove
000070  6ab0              LDR      r0,[r6,#0x28]         ;1688
000072  b118              CBZ      r0,|L10.124|
000074  f1060018          ADD      r0,r6,#0x18           ;1688
000078  f7fffffe          BL       uxListRemove
                  |L10.124|
00007c  6af0              LDR      r0,[r6,#0x2c]         ;1688
00007e  6961              LDR      r1,[r4,#0x14]         ;1688  ; uxTopReadyPriority
000080  4288              CMP      r0,r1                 ;1688
000082  d900              BLS      |L10.134|
000084  6160              STR      r0,[r4,#0x14]         ;1688  ; uxTopReadyPriority
                  |L10.134|
000086  eb000080          ADD      r0,r0,r0,LSL #2       ;1688
00008a  eb070080          ADD      r0,r7,r0,LSL #2       ;1688
00008e  1d31              ADDS     r1,r6,#4              ;1688
000090  f7fffffe          BL       vListInsertEnd
000094  e7d9              B        |L10.74|
;;;1714   /*-----------------------------------------------------------*/
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      ||.data||
                  |L10.156|
                          DCD      ||.bss||

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;2040   
;;;2041   void vTaskMissedYield( void )
000000  4901              LDR      r1,|L11.8|
;;;2042   {
;;;2043   	xMissedYield = pdTRUE;
000002  2001              MOVS     r0,#1
000004  6248              STR      r0,[r1,#0x24]  ; xMissedYield
;;;2044   }
000006  4770              BX       lr
;;;2045   /*-----------------------------------------------------------*/
                          ENDP

                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;1842   
;;;1843   void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;1844   {
;;;1845   portTickType xTimeToWake;
;;;1846   
;;;1847   	configASSERT( pxEventList );
;;;1848   
;;;1849   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1850   	SCHEDULER SUSPENDED. */
;;;1851   
;;;1852   	/* Place the event list item of the TCB in the appropriate event list.
;;;1853   	This is placed in the list in priority order so the highest priority task
;;;1854   	is the first to be woken by the event. */
;;;1855   	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
000002  4d0c              LDR      r5,|L12.52|
000004  460c              MOV      r4,r1                 ;1844
000006  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000008  3118              ADDS     r1,r1,#0x18
00000a  f7fffffe          BL       vListInsert
;;;1856   
;;;1857   	/* We must remove ourselves from the ready list before adding ourselves
;;;1858   	to the blocked list as the same list item is used for both lists.  We have
;;;1859   	exclusive access to the ready lists as the scheduler is locked. */
;;;1860   	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
00000e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
;;;1861   	{
;;;1862   		/* The current task must be in a ready list, so there is no need to
;;;1863   		check, and the port reset macro can be called directly. */
;;;1864   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;1865   	}
;;;1866   
;;;1867   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;1868   	{
;;;1869   		if( xTicksToWait == portMAX_DELAY )
000016  1c60              ADDS     r0,r4,#1
000018  d005              BEQ      |L12.38|
;;;1870   		{
;;;1871   			/* Add ourselves to the suspended task list instead of a delayed task
;;;1872   			list to ensure we are not woken by a timing event.  We will block
;;;1873   			indefinitely. */
;;;1874   			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
;;;1875   		}
;;;1876   		else
;;;1877   		{
;;;1878   			/* Calculate the time at which the task should be woken if the event does
;;;1879   			not occur.  This may overflow but this doesn't matter. */
;;;1880   			xTimeToWake = xTickCount + xTicksToWait;
00001a  68e8              LDR      r0,[r5,#0xc]  ; xTickCount
00001c  4420              ADD      r0,r0,r4
;;;1881   			prvAddCurrentTaskToDelayedList( xTimeToWake );
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      prvAddCurrentTaskToDelayedList
                  |L12.38|
000026  6829              LDR      r1,[r5,#0]            ;1874  ; pxCurrentTCB
000028  e8bd4070          POP      {r4-r6,lr}            ;1874
00002c  4802              LDR      r0,|L12.56|
00002e  1d09              ADDS     r1,r1,#4              ;1874
000030  f7ffbffe          B.W      vListInsertEnd
;;;1882   		}
;;;1883   	}
;;;1884   	#else /* INCLUDE_vTaskSuspend */
;;;1885   	{
;;;1886   			/* Calculate the time at which the task should be woken if the event does
;;;1887   			not occur.  This may overflow but this doesn't matter. */
;;;1888   			xTimeToWake = xTickCount + xTicksToWait;
;;;1889   			prvAddCurrentTaskToDelayedList( xTimeToWake );
;;;1890   	}
;;;1891   	#endif /* INCLUDE_vTaskSuspend */
;;;1892   }
;;;1893   /*-----------------------------------------------------------*/
                          ENDP

                  |L12.52|
                          DCD      ||.data||
                  |L12.56|
                          DCD      ||.bss||+0xb4

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;928    
;;;929    	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;930    	{
;;;931    	tskTCB *pxTCB;
;;;932    	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
;;;933    	portBASE_TYPE xYieldRequired = pdFALSE;
000004  2700              MOVS     r7,#0
000006  460d              MOV      r5,r1                 ;930
000008  4606              MOV      r6,r0                 ;930
;;;934    
;;;935    		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;936    
;;;937    		/* Ensure the new priority is valid. */
;;;938    		if( uxNewPriority >= configMAX_PRIORITIES )
00000a  2905              CMP      r1,#5
00000c  d300              BCC      |L13.16|
;;;939    		{
;;;940    			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
00000e  2504              MOVS     r5,#4
                  |L13.16|
;;;941    		}
;;;942    
;;;943    		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;944    		{
;;;945    			if( xTask == ( xTaskHandle ) pxCurrentTCB )
000014  f8df8070          LDR      r8,|L13.136|
000018  f8d80000          LDR      r0,[r8,#0]  ; pxCurrentTCB
00001c  4286              CMP      r6,r0
00001e  d101              BNE      |L13.36|
;;;946    			{
;;;947    				xTask = NULL;
000020  2600              MOVS     r6,#0
000022  e008              B        |L13.54|
                  |L13.36|
;;;948    			}
;;;949    
;;;950    			/* If null is passed in here then we are changing the
;;;951    			priority of the calling function. */
;;;952    			pxTCB = prvGetTCBFromHandle( xTask );
000024  b13e              CBZ      r6,|L13.54|
000026  4634              MOV      r4,r6
                  |L13.40|
;;;953    
;;;954    			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;955    
;;;956    			#if ( configUSE_MUTEXES == 1 )
;;;957    			{
;;;958    				uxCurrentPriority = pxTCB->uxBasePriority;
;;;959    			}
;;;960    			#else
;;;961    			{
;;;962    				uxCurrentPriority = pxTCB->uxPriority;
;;;963    			}
;;;964    			#endif
;;;965    
;;;966    			if( uxCurrentPriority != uxNewPriority )
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  42a8              CMP      r0,r5
00002c  d028              BEQ      |L13.128|
;;;967    			{
;;;968    				/* The priority change may have readied a task of higher
;;;969    				priority than the calling task. */
;;;970    				if( uxNewPriority > uxCurrentPriority )
00002e  4285              CMP      r5,r0
000030  d904              BLS      |L13.60|
;;;971    				{
;;;972    					if( xTask != NULL )
000032  b926              CBNZ     r6,|L13.62|
000034  e004              B        |L13.64|
                  |L13.54|
000036  f8d84000          LDR      r4,[r8,#0]            ;952  ; pxCurrentTCB
00003a  e7f5              B        |L13.40|
                  |L13.60|
;;;973    					{
;;;974    						/* The priority of another task is being raised.  If we
;;;975    						were raising the priority of the currently running task
;;;976    						there would be no need to switch as it must have already
;;;977    						been the highest priority task. */
;;;978    						xYieldRequired = pdTRUE;
;;;979    					}
;;;980    				}
;;;981    				else if( xTask == NULL )
00003c  b906              CBNZ     r6,|L13.64|
                  |L13.62|
;;;982    				{
;;;983    					/* Setting our own priority down means there may now be another
;;;984    					task of higher priority that is ready to execute. */
;;;985    					xYieldRequired = pdTRUE;
00003e  2701              MOVS     r7,#1
                  |L13.64|
;;;986    				}
;;;987    
;;;988    				/* Remember the ready list the task might be referenced from
;;;989    				before its uxPriority member is changed so the
;;;990    				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;991    				uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;992    
;;;993    				#if ( configUSE_MUTEXES == 1 )
;;;994    				{
;;;995    					/* Only change the priority being used if the task is not
;;;996    					currently using an inherited priority. */
;;;997    					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
;;;998    					{
;;;999    						pxTCB->uxPriority = uxNewPriority;
;;;1000   					}
;;;1001   
;;;1002   					/* The base priority gets set whatever. */
;;;1003   					pxTCB->uxBasePriority = uxNewPriority;
;;;1004   				}
;;;1005   				#else
;;;1006   				{
;;;1007   					pxTCB->uxPriority = uxNewPriority;
;;;1008   				}
;;;1009   				#endif
;;;1010   
;;;1011   				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
000040  f1c50105          RSB      r1,r5,#5
;;;1012   
;;;1013   				/* If the task is in the blocked or suspended list we need do
;;;1014   				nothing more than change it's priority variable. However, if
;;;1015   				the task is in a ready list it needs to be removed and placed
;;;1016   				in the queue appropriate to its new priority. */
;;;1017   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
000044  62e5              STR      r5,[r4,#0x2c]
000046  61a1              STR      r1,[r4,#0x18]
000048  4d10              LDR      r5,|L13.140|
00004a  eb000080          ADD      r0,r0,r0,LSL #2
00004e  6961              LDR      r1,[r4,#0x14]
000050  eb050080          ADD      r0,r5,r0,LSL #2
000054  4281              CMP      r1,r0
000056  d110              BNE      |L13.122|
;;;1018   				{
;;;1019   					/* The task is currently in its ready list - remove before adding
;;;1020   					it to it's new ready list.  As we are in a critical section we
;;;1021   					can do this even if the scheduler is suspended. */
;;;1022   					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
000058  1d20              ADDS     r0,r4,#4
00005a  f7fffffe          BL       uxListRemove
;;;1023   					{
;;;1024   						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
;;;1025   					}
;;;1026   					prvAddTaskToReadyQueue( pxTCB );
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  f8d82014          LDR      r2,[r8,#0x14]  ; uxTopReadyPriority
000064  4641              MOV      r1,r8
000066  4290              CMP      r0,r2
000068  d900              BLS      |L13.108|
00006a  6148              STR      r0,[r1,#0x14]  ; uxTopReadyPriority
                  |L13.108|
00006c  eb000080          ADD      r0,r0,r0,LSL #2
000070  eb050080          ADD      r0,r5,r0,LSL #2
000074  1d21              ADDS     r1,r4,#4
000076  f7fffffe          BL       vListInsertEnd
                  |L13.122|
;;;1027   				}
;;;1028   
;;;1029   				if( xYieldRequired == pdTRUE )
00007a  b10f              CBZ      r7,|L13.128|
;;;1030   				{
;;;1031   					portYIELD_WITHIN_API();
00007c  f7fffffe          BL       vPortYield
                  |L13.128|
;;;1032   				}
;;;1033   
;;;1034   				/* Remove compiler warning about unused variables when the port
;;;1035   				optimised task selection is not being used. */
;;;1036   				( void ) uxPriorityUsedOnEntry;
;;;1037   			}
;;;1038   		}
;;;1039   		taskEXIT_CRITICAL();
000080  e8bd41f0          POP      {r4-r8,lr}
000084  f7ffbffe          B.W      vPortExitCritical
;;;1040   	}
;;;1041   
                          ENDP

                  |L13.136|
                          DCD      ||.data||
                  |L13.140|
                          DCD      ||.bss||

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1147   
;;;1148   	void vTaskResume( xTaskHandle xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1149   	{
;;;1150   	tskTCB *pxTCB;
;;;1151   
;;;1152   		/* It does not make sense to resume the calling task. */
;;;1153   		configASSERT( xTaskToResume );
;;;1154   
;;;1155   		/* Remove the task from whichever list it is currently in, and place
;;;1156   		it in the ready list. */
;;;1157   		pxTCB = ( tskTCB * ) xTaskToResume;
000002  0004              MOVS     r4,r0
000004  d025              BEQ      |L14.82|
;;;1158   
;;;1159   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1160   		currently executing task. */
;;;1161   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000006  4d13              LDR      r5,|L14.84|
000008  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000a  4284              CMP      r4,r0
00000c  d021              BEQ      |L14.82|
;;;1162   		{
;;;1163   			taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1164   			{
;;;1165   				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       xTaskIsTaskSuspended
000018  2801              CMP      r0,#1
00001a  d116              BNE      |L14.74|
;;;1166   				{
;;;1167   					traceTASK_RESUME( pxTCB );
;;;1168   
;;;1169   					/* As we are in a critical section we can access the ready
;;;1170   					lists even if the scheduler is suspended. */
;;;1171   					uxListRemove(  &( pxTCB->xGenericListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;1172   					prvAddTaskToReadyQueue( pxTCB );
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  6969              LDR      r1,[r5,#0x14]  ; uxTopReadyPriority
000026  4288              CMP      r0,r1
000028  d900              BLS      |L14.44|
00002a  6168              STR      r0,[r5,#0x14]  ; uxTopReadyPriority
                  |L14.44|
00002c  490a              LDR      r1,|L14.88|
00002e  eb000080          ADD      r0,r0,r0,LSL #2
000032  eb010080          ADD      r0,r1,r0,LSL #2
000036  1d21              ADDS     r1,r4,#4
000038  f7fffffe          BL       vListInsertEnd
;;;1173   
;;;1174   					/* We may have just resumed a higher priority task. */
;;;1175   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000040  6ac9              LDR      r1,[r1,#0x2c]
000042  4288              CMP      r0,r1
000044  d301              BCC      |L14.74|
;;;1176   					{
;;;1177   						/* This yield may not cause the task just resumed to run, but
;;;1178   						will leave the lists in the correct state for the next yield. */
;;;1179   						portYIELD_WITHIN_API();
000046  f7fffffe          BL       vPortYield
                  |L14.74|
;;;1180   					}
;;;1181   				}
;;;1182   			}
;;;1183   			taskEXIT_CRITICAL();
00004a  e8bd4070          POP      {r4-r6,lr}
00004e  f7ffbffe          B.W      vPortExitCritical
                  |L14.82|
;;;1184   		}
;;;1185   	}
000052  bd70              POP      {r4-r6,pc}
;;;1186   
                          ENDP

                  |L14.84|
                          DCD      ||.data||
                  |L14.88|
                          DCD      ||.bss||

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;1986   
;;;1987   void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
000000  4902              LDR      r1,|L15.12|
;;;1988   {
;;;1989   	configASSERT( pxTimeOut );
;;;1990   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6a8a              LDR      r2,[r1,#0x28]  ; xNumOfOverflows
;;;1991   	pxTimeOut->xTimeOnEntering = xTickCount;
000004  6002              STR      r2,[r0,#0]
000006  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000008  6041              STR      r1,[r0,#4]
;;;1992   }
00000a  4770              BX       lr
;;;1993   /*-----------------------------------------------------------*/
                          ENDP

                  |L15.12|
                          DCD      ||.data||

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1231   
;;;1232   void vTaskStartScheduler( void )
000000  b51f              PUSH     {r0-r4,lr}
;;;1233   {
;;;1234   portBASE_TYPE xReturn;
;;;1235   
;;;1236   	/* Add the idle task at the lowest priority. */
;;;1237   	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
;;;1238   	{
;;;1239   		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
;;;1240   		be returned by the xTaskGetIdleTaskHandle() function. */
;;;1241   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
;;;1242   	}
;;;1243   	#else
;;;1244   	{
;;;1245   		/* Create the idle task without storing its handle. */
;;;1246   		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  9401              STR      r4,[sp,#4]
000008  9402              STR      r4,[sp,#8]
00000a  4623              MOV      r3,r4
00000c  2280              MOVS     r2,#0x80
00000e  a109              ADR      r1,|L16.52|
000010  480a              LDR      r0,|L16.60|
000012  9403              STR      r4,[sp,#0xc]
000014  f7fffffe          BL       xTaskGenericCreate
;;;1247   	}
;;;1248   	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
;;;1249   
;;;1250   	#if ( configUSE_TIMERS == 1 )
;;;1251   	{
;;;1252   		if( xReturn == pdPASS )
;;;1253   		{
;;;1254   			xReturn = xTimerCreateTimerTask();
;;;1255   		}
;;;1256   	}
;;;1257   	#endif /* configUSE_TIMERS */
;;;1258   
;;;1259   	if( xReturn == pdPASS )
000018  2801              CMP      r0,#1
00001a  d109              BNE      |L16.48|
;;;1260   	{
;;;1261   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1262   		before or during the call to xPortStartScheduler().  The stacks of
;;;1263   		the created tasks contain a status word with interrupts switched on
;;;1264   		so interrupts will automatically get re-enabled when the first task
;;;1265   		starts to run.
;;;1266   
;;;1267   		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
;;;1268   		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
;;;1269   		portDISABLE_INTERRUPTS();
00001c  f7fffffe          BL       ulPortSetInterruptMask
;;;1270   
;;;1271   		xSchedulerRunning = pdTRUE;
000020  4807              LDR      r0,|L16.64|
000022  2101              MOVS     r1,#1
000024  6181              STR      r1,[r0,#0x18]  ; xSchedulerRunning
;;;1272   		xTickCount = ( portTickType ) 0U;
000026  60c4              STR      r4,[r0,#0xc]  ; xTickCount
;;;1273   
;;;1274   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1275   		macro must be defined to configure the timer/counter used to generate
;;;1276   		the run time counter time base. */
;;;1277   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1278   
;;;1279   		/* Setting up the timer tick is hardware specific and thus in the
;;;1280   		portable interface. */
;;;1281   		if( xPortStartScheduler() != pdFALSE )
000028  e8bd401f          POP      {r0-r4,lr}
00002c  f7ffbffe          B.W      xPortStartScheduler
                  |L16.48|
;;;1282   		{
;;;1283   			/* Should not reach here as if the scheduler is running the
;;;1284   			function will not return. */
;;;1285   		}
;;;1286   		else
;;;1287   		{
;;;1288   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1289   		}
;;;1290   	}
;;;1291   	else
;;;1292   	{
;;;1293   		/* This line will only be reached if the kernel could not be started,
;;;1294   		because there was not enough FreeRTOS heap to create the idle task
;;;1295   		or the timer task. */
;;;1296   		configASSERT( xReturn );
;;;1297   	}
;;;1298   }
000030  bd1f              POP      {r0-r4,pc}
;;;1299   /*-----------------------------------------------------------*/
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
000034  49444c45          DCB      "IDLE",0
000038  00      
000039  00                DCB      0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L16.60|
                          DCD      prvIdleTask
                  |L16.64|
                          DCD      ||.data||

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1046   
;;;1047   	void vTaskSuspend( xTaskHandle xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1048   	{
000002  4606              MOV      r6,r0
;;;1049   	tskTCB *pxTCB;
;;;1050   
;;;1051   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1052   		{
;;;1053   			/* Ensure a yield is performed if the current task is being
;;;1054   			suspended. */
;;;1055   			if( xTaskToSuspend == ( xTaskHandle ) pxCurrentTCB )
000008  4d16              LDR      r5,|L17.100|
00000a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000c  4286              CMP      r6,r0
00000e  d101              BNE      |L17.20|
;;;1056   			{
;;;1057   				xTaskToSuspend = NULL;
000010  2600              MOVS     r6,#0
000012  e018              B        |L17.70|
                  |L17.20|
;;;1058   			}
;;;1059   
;;;1060   			/* If null is passed in here then we are suspending ourselves. */
;;;1061   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000014  b1be              CBZ      r6,|L17.70|
000016  4634              MOV      r4,r6
                  |L17.24|
;;;1062   
;;;1063   			traceTASK_SUSPEND( pxTCB );
;;;1064   
;;;1065   			/* Remove task from the ready/delayed list and place in the	suspended list. */
;;;1066   			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
000018  1d20              ADDS     r0,r4,#4
00001a  f7fffffe          BL       uxListRemove
;;;1067   			{
;;;1068   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1069   			}
;;;1070   
;;;1071   			/* Is the task waiting on an event also? */
;;;1072   			if( pxTCB->xEventListItem.pvContainer != NULL )
00001e  6aa0              LDR      r0,[r4,#0x28]
000020  b118              CBZ      r0,|L17.42|
;;;1073   			{
;;;1074   				uxListRemove( &( pxTCB->xEventListItem ) );
000022  f1040018          ADD      r0,r4,#0x18
000026  f7fffffe          BL       uxListRemove
                  |L17.42|
;;;1075   			}
;;;1076   
;;;1077   			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
00002a  1d21              ADDS     r1,r4,#4
00002c  480e              LDR      r0,|L17.104|
00002e  f7fffffe          BL       vListInsertEnd
;;;1078   		}
;;;1079   		taskEXIT_CRITICAL();
000032  f7fffffe          BL       vPortExitCritical
;;;1080   
;;;1081   		if( ( void * ) xTaskToSuspend == NULL )
000036  2e00              CMP      r6,#0
000038  d10e              BNE      |L17.88|
;;;1082   		{
;;;1083   			if( xSchedulerRunning != pdFALSE )
00003a  69a8              LDR      r0,[r5,#0x18]  ; xSchedulerRunning
00003c  b128              CBZ      r0,|L17.74|
;;;1084   			{
;;;1085   				/* We have just suspended the current task. */
;;;1086   				portYIELD_WITHIN_API();
00003e  e8bd4070          POP      {r4-r6,lr}
000042  f7ffbffe          B.W      vPortYield
                  |L17.70|
000046  682c              LDR      r4,[r5,#0]            ;1061  ; pxCurrentTCB
000048  e7e6              B        |L17.24|
                  |L17.74|
;;;1087   			}
;;;1088   			else
;;;1089   			{
;;;1090   				/* The scheduler is not running, but the task that was pointed
;;;1091   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1092   				must be adjusted to point to a different task. */
;;;1093   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
00004a  4807              LDR      r0,|L17.104|
00004c  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
00004e  68a9              LDR      r1,[r5,#8]  ; uxCurrentNumberOfTasks
000050  4288              CMP      r0,r1
000052  d102              BNE      |L17.90|
;;;1094   				{
;;;1095   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1096   					NULL so when the next task is created pxCurrentTCB will
;;;1097   					be set to point to it no matter what its relative priority
;;;1098   					is. */
;;;1099   					pxCurrentTCB = NULL;
000054  2000              MOVS     r0,#0
000056  6028              STR      r0,[r5,#0]  ; pxCurrentTCB
                  |L17.88|
;;;1100   				}
;;;1101   				else
;;;1102   				{
;;;1103   					vTaskSwitchContext();
;;;1104   				}
;;;1105   			}
;;;1106   		}
;;;1107   	}
000058  bd70              POP      {r4-r6,pc}
                  |L17.90|
00005a  e8bd4070          POP      {r4-r6,lr}            ;1103
00005e  f7ffbffe          B.W      vTaskSwitchContext
;;;1108   
                          ENDP

000062  0000              DCW      0x0000
                  |L17.100|
                          DCD      ||.data||
                  |L17.104|
                          DCD      ||.bss||+0xb4

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1311   
;;;1312   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L18.12|
;;;1313   {
;;;1314   	/* A critical section is not required as the variable is of type
;;;1315   	portBASE_TYPE. */
;;;1316   	++uxSchedulerSuspended;
000002  69c1              LDR      r1,[r0,#0x1c]  ; uxSchedulerSuspended
000004  1c49              ADDS     r1,r1,#1
000006  61c1              STR      r1,[r0,#0x1c]  ; uxSchedulerSuspended
;;;1317   }
000008  4770              BX       lr
;;;1318   /*----------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;1802   
;;;1803   void vTaskSwitchContext( void )
000000  4810              LDR      r0,|L19.68|
;;;1804   {
;;;1805   	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
000002  69c2              LDR      r2,[r0,#0x1c]  ; uxSchedulerSuspended
;;;1806   	{
;;;1807   		/* The scheduler is currently suspended - do not allow a context
;;;1808   		switch. */
;;;1809   		xMissedYield = pdTRUE;
;;;1810   	}
;;;1811   	else
;;;1812   	{
;;;1813   		traceTASK_SWITCHED_OUT();
;;;1814   
;;;1815   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;1816   		{
;;;1817   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;1818   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;1819   				#else
;;;1820   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;1821   				#endif
;;;1822   
;;;1823   				/* Add the amount of time the task has been running to the accumulated
;;;1824   				time so far.  The time the task started running was stored in
;;;1825   				ulTaskSwitchedInTime.  Note that there is no overflow protection here
;;;1826   				so count values are only valid until the timer overflows.  Generally
;;;1827   				this will be about 1 hour assuming a 1uS timer increment. */
;;;1828   				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;1829   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;1830   		}
;;;1831   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;1832   
;;;1833   		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
;;;1834   		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
;;;1835   
;;;1836   		taskSELECT_HIGHEST_PRIORITY_TASK();
000004  4910              LDR      r1,|L19.72|
000006  b122              CBZ      r2,|L19.18|
000008  2101              MOVS     r1,#1                 ;1809
00000a  6241              STR      r1,[r0,#0x24]         ;1809  ; xMissedYield
;;;1837   
;;;1838   		traceTASK_SWITCHED_IN();
;;;1839   	}
;;;1840   }
00000c  4770              BX       lr
                  |L19.14|
00000e  1e52              SUBS     r2,r2,#1
000010  6142              STR      r2,[r0,#0x14]         ;1836  ; uxTopReadyPriority
                  |L19.18|
000012  6942              LDR      r2,[r0,#0x14]         ;1836  ; uxTopReadyPriority
000014  eb020282          ADD      r2,r2,r2,LSL #2       ;1836
000018  f8512022          LDR      r2,[r1,r2,LSL #2]     ;1836
00001c  2a00              CMP      r2,#0                 ;1836
00001e  6942              LDR      r2,[r0,#0x14]         ;1836  ; uxTopReadyPriority
000020  d0f5              BEQ      |L19.14|
000022  eb020282          ADD      r2,r2,r2,LSL #2       ;1836
000026  eb010182          ADD      r1,r1,r2,LSL #2       ;1836
00002a  684a              LDR      r2,[r1,#4]            ;1836
00002c  6852              LDR      r2,[r2,#4]            ;1836
00002e  f1010308          ADD      r3,r1,#8              ;1836
000032  604a              STR      r2,[r1,#4]            ;1836
000034  429a              CMP      r2,r3                 ;1836
000036  d101              BNE      |L19.60|
000038  6852              LDR      r2,[r2,#4]            ;1836
00003a  604a              STR      r2,[r1,#4]            ;1836
                  |L19.60|
00003c  68d1              LDR      r1,[r2,#0xc]          ;1836
00003e  6001              STR      r1,[r0,#0]            ;1836  ; pxCurrentTCB
000040  4770              BX       lr
;;;1841   /*-----------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L19.68|
                          DCD      ||.data||
                  |L19.72|
                          DCD      ||.bss||

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;1994   
;;;1995   portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;1996   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1997   portBASE_TYPE xReturn;
;;;1998   
;;;1999   	configASSERT( pxTimeOut );
;;;2000   	configASSERT( pxTicksToWait );
;;;2001   
;;;2002   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2003   	{
;;;2004   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;2005   			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
;;;2006   			the maximum block time then the task should block indefinitely, and
;;;2007   			therefore never time out. */
;;;2008   			if( *pxTicksToWait == portMAX_DELAY )
00000a  6828              LDR      r0,[r5,#0]
00000c  1c41              ADDS     r1,r0,#1
00000e  d014              BEQ      |L20.58|
;;;2009   			{
;;;2010   				xReturn = pdFALSE;
;;;2011   			}
;;;2012   			else /* We are not blocking indefinitely, perform the checks below. */
;;;2013   		#endif
;;;2014   
;;;2015   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
000010  4a0d              LDR      r2,|L20.72|
000012  6821              LDR      r1,[r4,#0]
000014  6a93              LDR      r3,[r2,#0x28]  ; xNumOfOverflows
000016  4299              CMP      r1,r3
000018  d003              BEQ      |L20.34|
00001a  6861              LDR      r1,[r4,#4]
00001c  68d3              LDR      r3,[r2,#0xc]  ; xTickCount
00001e  4299              CMP      r1,r3
000020  d90d              BLS      |L20.62|
                  |L20.34|
;;;2016   		{
;;;2017   			/* The tick count is greater than the time at which vTaskSetTimeout()
;;;2018   			was called, but has also overflowed since vTaskSetTimeOut() was called.
;;;2019   			It must have wrapped all the way around and gone past us again. This
;;;2020   			passed since vTaskSetTimeout() was called. */
;;;2021   			xReturn = pdTRUE;
;;;2022   		}
;;;2023   		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
000022  6861              LDR      r1,[r4,#4]
000024  68d3              LDR      r3,[r2,#0xc]  ; xTickCount
000026  1a5b              SUBS     r3,r3,r1
000028  4283              CMP      r3,r0
00002a  d208              BCS      |L20.62|
;;;2024   		{
;;;2025   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;2026   			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
00002c  68d2              LDR      r2,[r2,#0xc]  ; xTickCount
00002e  1a51              SUBS     r1,r2,r1
000030  1a40              SUBS     r0,r0,r1
;;;2027   			vTaskSetTimeOutState( pxTimeOut );
000032  6028              STR      r0,[r5,#0]
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       vTaskSetTimeOutState
                  |L20.58|
00003a  2400              MOVS     r4,#0                 ;2010
00003c  e000              B        |L20.64|
                  |L20.62|
;;;2028   			xReturn = pdFALSE;
;;;2029   		}
;;;2030   		else
;;;2031   		{
;;;2032   			xReturn = pdTRUE;
00003e  2401              MOVS     r4,#1
                  |L20.64|
;;;2033   		}
;;;2034   	}
;;;2035   	taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;2036   
;;;2037   	return xReturn;
000044  4620              MOV      r0,r4
;;;2038   }
000046  bd70              POP      {r4-r6,pc}
;;;2039   /*-----------------------------------------------------------*/
                          ENDP

                  |L20.72|
                          DCD      ||.data||

                          AREA ||i.xTaskGenericCreate||, CODE, READONLY, ALIGN=2

                  xTaskGenericCreate PROC
;;;493    
;;;494    signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;495    {
000004  469b              MOV      r11,r3
000006  e9dd680e          LDRD     r6,r8,[sp,#0x38]
00000a  4615              MOV      r5,r2
00000c  468a              MOV      r10,r1
00000e  2044              MOVS     r0,#0x44
000010  9f10              LDR      r7,[sp,#0x40]
000012  f7fffffe          BL       pvPortMalloc
000016  0004              MOVS     r4,r0
000018  d04c              BEQ      |L21.180|
00001a  00a8              LSLS     r0,r5,#2
00001c  4681              MOV      r9,r0
00001e  b3ef              CBZ      r7,|L21.156|
000020  4638              MOV      r0,r7
                  |L21.34|
000022  6320              STR      r0,[r4,#0x30]
000024  b3d8              CBZ      r0,|L21.158|
000026  22a5              MOVS     r2,#0xa5
000028  4649              MOV      r1,r9
00002a  f7fffffe          BL       __aeabi_memset
;;;496    signed portBASE_TYPE xReturn;
;;;497    tskTCB * pxNewTCB;
;;;498    
;;;499    	configASSERT( pxTaskCode );
;;;500    	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
;;;501    
;;;502    	/* Allocate the memory required by the TCB and stack for the new task,
;;;503    	checking that the allocation was successful. */
;;;504    	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
;;;505    
;;;506    	if( pxNewTCB != NULL )
;;;507    	{
;;;508    		portSTACK_TYPE *pxTopOfStack;
;;;509    
;;;510    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;511    			/* Should the task be created in privileged mode? */
;;;512    			portBASE_TYPE xRunPrivileged;
;;;513    			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;514    			{
;;;515    				xRunPrivileged = pdTRUE;
;;;516    			}
;;;517    			else
;;;518    			{
;;;519    				xRunPrivileged = pdFALSE;
;;;520    			}
;;;521    			uxPriority &= ~portPRIVILEGE_BIT;
;;;522    		#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;523    
;;;524    		/* Calculate the top of stack address.  This depends on whether the
;;;525    		stack grows from high memory to low (as per the 80x86) or visa versa.
;;;526    		portSTACK_GROWTH is used to make the result positive or negative as
;;;527    		required by the port. */
;;;528    		#if( portSTACK_GROWTH < 0 )
;;;529    		{
;;;530    			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
00002e  f06f0103          MVN      r1,#3
000032  eb010185          ADD      r1,r1,r5,LSL #2
000036  6b20              LDR      r0,[r4,#0x30]
;;;531    			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
;;;532    
;;;533    			/* Check the alignment of the calculated top of stack is correct. */
;;;534    			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;535    		}
;;;536    		#else /* portSTACK_GROWTH */
;;;537    		{
;;;538    			pxTopOfStack = pxNewTCB->pxStack;
;;;539    
;;;540    			/* Check the alignment of the stack buffer is correct. */
;;;541    			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;542    
;;;543    			/* If we want to use stack checking on architectures that use
;;;544    			a positive stack growth direction then we also need to store the
;;;545    			other extreme of the stack space. */
;;;546    			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
;;;547    		}
;;;548    		#endif /* portSTACK_GROWTH */
;;;549    
;;;550    		/* Setup the newly allocated TCB with the initial state of the task. */
;;;551    		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
000038  4635              MOV      r5,r6
00003a  4408              ADD      r0,r0,r1              ;530
00003c  f0200707          BIC      r7,r0,#7              ;531
000040  4651              MOV      r1,r10
000042  2210              MOVS     r2,#0x10
000044  f1040034          ADD      r0,r4,#0x34
000048  f7fffffe          BL       strncpy
00004c  2000              MOVS     r0,#0
00004e  f8840043          STRB     r0,[r4,#0x43]
000052  2d05              CMP      r5,#5
000054  d300              BCC      |L21.88|
000056  2504              MOVS     r5,#4
                  |L21.88|
000058  1d20              ADDS     r0,r4,#4
00005a  62e5              STR      r5,[r4,#0x2c]
00005c  f7fffffe          BL       vListInitialiseItem
000060  f1040018          ADD      r0,r4,#0x18
000064  f7fffffe          BL       vListInitialiseItem
000068  6124              STR      r4,[r4,#0x10]
00006a  f1c50105          RSB      r1,r5,#5
00006e  6264              STR      r4,[r4,#0x24]
000070  61a1              STR      r1,[r4,#0x18]
;;;552    
;;;553    		/* Initialize the TCB stack to look as if the task was already running,
;;;554    		but had been interrupted by the scheduler.  The return address is set
;;;555    		to the start of the task function. Once the stack has been initialised
;;;556    		the	top of stack variable is updated. */
;;;557    		#if( portUSING_MPU_WRAPPERS == 1 )
;;;558    		{
;;;559    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;560    		}
;;;561    		#else /* portUSING_MPU_WRAPPERS */
;;;562    		{
;;;563    			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000072  465a              MOV      r2,r11
000074  4638              MOV      r0,r7
000076  9900              LDR      r1,[sp,#0]
000078  f7fffffe          BL       pxPortInitialiseStack
;;;564    		}
;;;565    		#endif /* portUSING_MPU_WRAPPERS */
;;;566    
;;;567    		/* Check the alignment of the initialised stack. */
;;;568    		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;569    
;;;570    		if( ( void * ) pxCreatedTask != NULL )
00007c  6020              STR      r0,[r4,#0]
00007e  f1b80f00          CMP      r8,#0
000082  d001              BEQ      |L21.136|
;;;571    		{
;;;572    			/* Pass the TCB out - in an anonymous way.  The calling function/
;;;573    			task can use this as a handle to delete the task later if
;;;574    			required.*/
;;;575    			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
000084  f8c84000          STR      r4,[r8,#0]
                  |L21.136|
;;;576    		}
;;;577    
;;;578    		/* We are going to manipulate the task queues to add this task to a
;;;579    		ready list, so must make sure no interrupts occur. */
;;;580    		taskENTER_CRITICAL();
000088  f7fffffe          BL       vPortEnterCritical
;;;581    		{
;;;582    			uxCurrentNumberOfTasks++;
00008c  4d33              LDR      r5,|L21.348|
00008e  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000090  1c40              ADDS     r0,r0,#1
000092  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;583    			if( pxCurrentTCB == NULL )
000094  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000096  f8df80c8          LDR      r8,|L21.352|
00009a  e001              B        |L21.160|
                  |L21.156|
00009c  e004              B        |L21.168|
                  |L21.158|
00009e  e006              B        |L21.174|
                  |L21.160|
0000a0  b158              CBZ      r0,|L21.186|
;;;584    			{
;;;585    				/* There are no other tasks, or all the other tasks are in
;;;586    				the suspended state - make this the current task. */
;;;587    				pxCurrentTCB =  pxNewTCB;
;;;588    
;;;589    				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
;;;590    				{
;;;591    					/* This is the first task to be created so do the preliminary
;;;592    					initialisation required.  We will not recover if this call
;;;593    					fails, but we will report the failure. */
;;;594    					prvInitialiseTaskLists();
;;;595    				}
;;;596    			}
;;;597    			else
;;;598    			{
;;;599    				/* If the scheduler is not already running, make this task the
;;;600    				current task if it is the highest priority task to be created
;;;601    				so far. */
;;;602    				if( xSchedulerRunning == pdFALSE )
0000a2  69a8              LDR      r0,[r5,#0x18]  ; xSchedulerRunning
0000a4  b388              CBZ      r0,|L21.266|
0000a6  e036              B        |L21.278|
                  |L21.168|
0000a8  f7fffffe          BL       pvPortMalloc
0000ac  e7b9              B        |L21.34|
                  |L21.174|
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       vPortFree
                  |L21.180|
;;;603    				{
;;;604    					if( pxCurrentTCB->uxPriority <= uxPriority )
;;;605    					{
;;;606    						pxCurrentTCB = pxNewTCB;
;;;607    					}
;;;608    				}
;;;609    			}
;;;610    
;;;611    			/* Remember the top priority to make context switching faster.  Use
;;;612    			the priority in pxNewTCB as this has been capped to a valid value. */
;;;613    			if( pxNewTCB->uxPriority > uxTopUsedPriority )
;;;614    			{
;;;615    				uxTopUsedPriority = pxNewTCB->uxPriority;
;;;616    			}
;;;617    
;;;618    			uxTaskNumber++;
;;;619    
;;;620    			#if ( configUSE_TRACE_FACILITY == 1 )
;;;621    			{
;;;622    				/* Add a counter into the TCB for tracing only. */
;;;623    				pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;624    			}
;;;625    			#endif /* configUSE_TRACE_FACILITY */
;;;626    			traceTASK_CREATE( pxNewTCB );
;;;627    
;;;628    			prvAddTaskToReadyQueue( pxNewTCB );
;;;629    
;;;630    			xReturn = pdPASS;
;;;631    			portSETUP_TCB( pxNewTCB );
;;;632    		}
;;;633    		taskEXIT_CRITICAL();
;;;634    	}
;;;635    	else
;;;636    	{
;;;637    		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0000b4  f04f34ff          MOV      r4,#0xffffffff
0000b8  e04b              B        |L21.338|
                  |L21.186|
0000ba  602c              STR      r4,[r5,#0]            ;587  ; pxCurrentTCB
0000bc  68a8              LDR      r0,[r5,#8]            ;589  ; uxCurrentNumberOfTasks
0000be  2801              CMP      r0,#1                 ;589
0000c0  d129              BNE      |L21.278|
0000c2  2700              MOVS     r7,#0                 ;589
                  |L21.196|
0000c4  eb070187          ADD      r1,r7,r7,LSL #2       ;589
0000c8  eb080081          ADD      r0,r8,r1,LSL #2       ;589
0000cc  f7fffffe          BL       vListInitialise
0000d0  1c7f              ADDS     r7,r7,#1              ;589
0000d2  2f05              CMP      r7,#5                 ;589
0000d4  d3f6              BCC      |L21.196|
0000d6  4822              LDR      r0,|L21.352|
0000d8  3064              ADDS     r0,r0,#0x64           ;589
0000da  f7fffffe          BL       vListInitialise
0000de  4820              LDR      r0,|L21.352|
0000e0  3078              ADDS     r0,r0,#0x78           ;589
0000e2  f7fffffe          BL       vListInitialise
0000e6  481e              LDR      r0,|L21.352|
0000e8  308c              ADDS     r0,r0,#0x8c           ;589
0000ea  f7fffffe          BL       vListInitialise
0000ee  481c              LDR      r0,|L21.352|
0000f0  30a0              ADDS     r0,r0,#0xa0           ;589
0000f2  f7fffffe          BL       vListInitialise
0000f6  481a              LDR      r0,|L21.352|
0000f8  30b4              ADDS     r0,r0,#0xb4           ;589
0000fa  f7fffffe          BL       vListInitialise
0000fe  4818              LDR      r0,|L21.352|
000100  3064              ADDS     r0,r0,#0x64           ;589
000102  6368              STR      r0,[r5,#0x34]         ;589  ; pxDelayedTaskList
000104  3014              ADDS     r0,r0,#0x14           ;589
000106  63a8              STR      r0,[r5,#0x38]         ;589  ; pxOverflowDelayedTaskList
000108  e005              B        |L21.278|
                  |L21.266|
00010a  e7ff              B        |L21.268|
                  |L21.268|
00010c  6828              LDR      r0,[r5,#0]            ;604  ; pxCurrentTCB
00010e  6ac0              LDR      r0,[r0,#0x2c]         ;604
000110  42b0              CMP      r0,r6                 ;604
000112  d800              BHI      |L21.278|
000114  602c              STR      r4,[r5,#0]            ;606  ; pxCurrentTCB
                  |L21.278|
000116  6ae0              LDR      r0,[r4,#0x2c]         ;613
000118  6929              LDR      r1,[r5,#0x10]         ;613  ; uxTopUsedPriority
00011a  4288              CMP      r0,r1                 ;613
00011c  d900              BLS      |L21.288|
00011e  6128              STR      r0,[r5,#0x10]         ;615  ; uxTopUsedPriority
                  |L21.288|
000120  6ae9              LDR      r1,[r5,#0x2c]         ;618  ; uxTaskNumber
000122  1c49              ADDS     r1,r1,#1              ;618
000124  62e9              STR      r1,[r5,#0x2c]         ;628  ; uxTaskNumber
000126  6969              LDR      r1,[r5,#0x14]         ;628  ; uxTopReadyPriority
000128  4288              CMP      r0,r1                 ;628
00012a  d900              BLS      |L21.302|
00012c  6168              STR      r0,[r5,#0x14]         ;628  ; uxTopReadyPriority
                  |L21.302|
00012e  eb000180          ADD      r1,r0,r0,LSL #2       ;628
000132  eb080081          ADD      r0,r8,r1,LSL #2       ;628
000136  1d21              ADDS     r1,r4,#4              ;628
000138  f7fffffe          BL       vListInsertEnd
00013c  2401              MOVS     r4,#1                 ;630
00013e  f7fffffe          BL       vPortExitCritical
;;;638    		traceTASK_CREATE_FAILED();
;;;639    	}
;;;640    
;;;641    	if( xReturn == pdPASS )
;;;642    	{
;;;643    		if( xSchedulerRunning != pdFALSE )
000142  69a8              LDR      r0,[r5,#0x18]  ; xSchedulerRunning
000144  b128              CBZ      r0,|L21.338|
;;;644    		{
;;;645    			/* If the created task is of a higher priority than the current task
;;;646    			then it should run now. */
;;;647    			if( pxCurrentTCB->uxPriority < uxPriority )
000146  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000148  6ac0              LDR      r0,[r0,#0x2c]
00014a  42b0              CMP      r0,r6
00014c  d201              BCS      |L21.338|
;;;648    			{
;;;649    				portYIELD_WITHIN_API();
00014e  f7fffffe          BL       vPortYield
                  |L21.338|
;;;650    			}
;;;651    		}
;;;652    	}
;;;653    
;;;654    	return xReturn;
;;;655    }
000152  b004              ADD      sp,sp,#0x10
000154  4620              MOV      r0,r4                 ;654
000156  e8bd9ff0          POP      {r4-r12,pc}
;;;656    /*-----------------------------------------------------------*/
                          ENDP

00015a  0000              DCW      0x0000
                  |L21.348|
                          DCD      ||.data||
                  |L21.352|
                          DCD      ||.bss||

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;1424   
;;;1425   portTickType xTaskGetTickCount( void )
000000  b510              PUSH     {r4,lr}
;;;1426   {
;;;1427   portTickType xTicks;
;;;1428   
;;;1429   	/* Critical section required if running on a 16 bit processor. */
;;;1430   	taskENTER_CRITICAL();
000002  f7fffffe          BL       vPortEnterCritical
;;;1431   	{
;;;1432   		xTicks = xTickCount;
000006  4803              LDR      r0,|L22.20|
000008  68c4              LDR      r4,[r0,#0xc]  ; xTickCount
;;;1433   	}
;;;1434   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1435   
;;;1436   	return xTicks;
00000e  4620              MOV      r0,r4
;;;1437   }
000010  bd10              POP      {r4,pc}
;;;1438   /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;1439   
;;;1440   portTickType xTaskGetTickCountFromISR( void )
000000  b510              PUSH     {r4,lr}
;;;1441   {
;;;1442   portTickType xReturn;
;;;1443   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1444   
;;;1445   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;1446   	xReturn = xTickCount;
000006  4903              LDR      r1,|L23.20|
000008  68cc              LDR      r4,[r1,#0xc]  ; xTickCount
;;;1447   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00000a  f7fffffe          BL       vPortClearInterruptMask
;;;1448   
;;;1449   	return xReturn;
00000e  4620              MOV      r0,r4
;;;1450   }
000010  bd10              POP      {r4,pc}
;;;1451   /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      ||.data||

                          AREA ||i.xTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  xTaskIsTaskSuspended PROC
;;;1113   
;;;1114   	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
000000  4b06              LDR      r3,|L24.28|
;;;1115   	{
;;;1116   	portBASE_TYPE xReturn = pdFALSE;
;;;1117   	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
;;;1118   
;;;1119   		/* It does not make sense to check if the calling task is suspended. */
;;;1120   		configASSERT( xTask );
;;;1121   
;;;1122   		/* Is the task we are attempting to resume actually in the
;;;1123   		suspended list? */
;;;1124   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
000002  6942              LDR      r2,[r0,#0x14]
000004  2100              MOVS     r1,#0                 ;1116
000006  429a              CMP      r2,r3
000008  d106              BNE      |L24.24|
;;;1125   		{
;;;1126   			/* Has the task already been resumed from within an ISR? */
;;;1127   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
00000a  6a80              LDR      r0,[r0,#0x28]
00000c  f1a30228          SUB      r2,r3,#0x28
000010  4290              CMP      r0,r2
000012  d001              BEQ      |L24.24|
;;;1128   			{
;;;1129   				/* Is it in the suspended list because it is in the
;;;1130   				Suspended state?  It is possible to be in the suspended
;;;1131   				list because it is blocked on a task with no timeout
;;;1132   				specified. */
;;;1133   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
000014  b900              CBNZ     r0,|L24.24|
;;;1134   				{
;;;1135   					xReturn = pdTRUE;
000016  2101              MOVS     r1,#1
                  |L24.24|
;;;1136   				}
;;;1137   			}
;;;1138   		}
;;;1139   
;;;1140   		return xReturn;
000018  4608              MOV      r0,r1
;;;1141   	}
00001a  4770              BX       lr
;;;1142   
                          ENDP

                  |L24.28|
                          DCD      ||.bss||+0xb4

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;1935   
;;;1936   signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;1937   {
;;;1938   tskTCB *pxUnblockedTCB;
;;;1939   portBASE_TYPE xReturn;
;;;1940   
;;;1941   	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
;;;1942   	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
;;;1943   
;;;1944   	/* The event list is sorted in priority order, so we can remove the
;;;1945   	first in the list, remove the TCB from the delayed list, and add
;;;1946   	it to the ready list.
;;;1947   
;;;1948   	If an event is for a queue that is locked then this function will never
;;;1949   	get called - the lock count on the queue will get modified instead.  This
;;;1950   	means we can always expect exclusive access to the event list here.
;;;1951   
;;;1952   	This function assumes that a check has already been made to ensure that
;;;1953   	pxEventList is not empty. */
;;;1954   	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000002  68c0              LDR      r0,[r0,#0xc]
000004  68c4              LDR      r4,[r0,#0xc]
;;;1955   	configASSERT( pxUnblockedTCB );
;;;1956   	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000006  f1040018          ADD      r0,r4,#0x18
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       uxListRemove
;;;1957   
;;;1958   	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000010  4d0f              LDR      r5,|L25.80|
000012  69e8              LDR      r0,[r5,#0x1c]  ; uxSchedulerSuspended
000014  b110              CBZ      r0,|L25.28|
000016  4631              MOV      r1,r6
;;;1959   	{
;;;1960   		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
;;;1961   		prvAddTaskToReadyQueue( pxUnblockedTCB );
;;;1962   	}
;;;1963   	else
;;;1964   	{
;;;1965   		/* We cannot access the delayed or ready lists, so will hold this
;;;1966   		task pending until the scheduler is resumed. */
;;;1967   		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000018  480e              LDR      r0,|L25.84|
00001a  e00e              B        |L25.58|
                  |L25.28|
00001c  1d20              ADDS     r0,r4,#4              ;1960
00001e  f7fffffe          BL       uxListRemove
000022  6ae0              LDR      r0,[r4,#0x2c]         ;1961
000024  6969              LDR      r1,[r5,#0x14]         ;1961  ; uxTopReadyPriority
000026  4288              CMP      r0,r1                 ;1961
000028  d900              BLS      |L25.44|
00002a  6168              STR      r0,[r5,#0x14]         ;1961  ; uxTopReadyPriority
                  |L25.44|
00002c  4909              LDR      r1,|L25.84|
00002e  eb000080          ADD      r0,r0,r0,LSL #2       ;1961
000032  398c              SUBS     r1,r1,#0x8c           ;1961
000034  eb010080          ADD      r0,r1,r0,LSL #2       ;1961
000038  1d21              ADDS     r1,r4,#4              ;1961
                  |L25.58|
00003a  f7fffffe          BL       vListInsertEnd
;;;1968   	}
;;;1969   
;;;1970   	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000042  6ac9              LDR      r1,[r1,#0x2c]
000044  4288              CMP      r0,r1
000046  d301              BCC      |L25.76|
;;;1971   	{
;;;1972   		/* Return true if the task removed from the event list has
;;;1973   		a higher priority than the calling task.  This allows
;;;1974   		the calling task to know if it should force a context
;;;1975   		switch now. */
;;;1976   		xReturn = pdTRUE;
000048  2001              MOVS     r0,#1
;;;1977   	}
;;;1978   	else
;;;1979   	{
;;;1980   		xReturn = pdFALSE;
;;;1981   	}
;;;1982   
;;;1983   	return xReturn;
;;;1984   }
00004a  bd70              POP      {r4-r6,pc}
                  |L25.76|
00004c  2000              MOVS     r0,#0                 ;1980
00004e  bd70              POP      {r4-r6,pc}
;;;1985   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.80|
                          DCD      ||.data||
                  |L25.84|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;1347   
;;;1348   signed portBASE_TYPE xTaskResumeAll( void )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1349   {
;;;1350   register tskTCB *pxTCB;
;;;1351   signed portBASE_TYPE xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;1352   
;;;1353   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;1354   	previous call to vTaskSuspendAll(). */
;;;1355   	configASSERT( uxSchedulerSuspended );
;;;1356   
;;;1357   	/* It is possible that an ISR caused a task to be removed from an event
;;;1358   	list while the scheduler was suspended.  If this was the case then the
;;;1359   	removed task will have been added to the xPendingReadyList.  Once the
;;;1360   	scheduler has been resumed it is safe to move all the pending ready
;;;1361   	tasks from this list into their appropriate ready list. */
;;;1362   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;1363   	{
;;;1364   		--uxSchedulerSuspended;
00000a  4c24              LDR      r4,|L26.156|
00000c  69e0              LDR      r0,[r4,#0x1c]  ; uxSchedulerSuspended
00000e  1e40              SUBS     r0,r0,#1
000010  61e0              STR      r0,[r4,#0x1c]  ; uxSchedulerSuspended
;;;1365   
;;;1366   		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000012  69e0              LDR      r0,[r4,#0x1c]  ; uxSchedulerSuspended
000014  bb98              CBNZ     r0,|L26.126|
;;;1367   		{
;;;1368   			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
000016  68a0              LDR      r0,[r4,#8]  ; uxCurrentNumberOfTasks
000018  b388              CBZ      r0,|L26.126|
;;;1369   			{
;;;1370   				portBASE_TYPE xYieldRequired = pdFALSE;
;;;1371   
;;;1372   				/* Move any readied tasks from the pending list into the
;;;1373   				appropriate ready list. */
;;;1374   				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
;;;1375   				{
;;;1376   					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
00001a  f8df8084          LDR      r8,|L26.160|
00001e  2500              MOVS     r5,#0                 ;1370
;;;1377   					uxListRemove( &( pxTCB->xEventListItem ) );
;;;1378   					uxListRemove( &( pxTCB->xGenericListItem ) );
;;;1379   					prvAddTaskToReadyQueue( pxTCB );
000020  f1a8098c          SUB      r9,r8,#0x8c
000024  e01a              B        |L26.92|
                  |L26.38|
000026  68c0              LDR      r0,[r0,#0xc]          ;1376  ; xPendingReadyList
000028  68c7              LDR      r7,[r0,#0xc]          ;1376
00002a  f1070018          ADD      r0,r7,#0x18           ;1377
00002e  f7fffffe          BL       uxListRemove
000032  1d38              ADDS     r0,r7,#4              ;1378
000034  f7fffffe          BL       uxListRemove
000038  6af8              LDR      r0,[r7,#0x2c]
00003a  6961              LDR      r1,[r4,#0x14]  ; uxTopReadyPriority
00003c  4288              CMP      r0,r1
00003e  d900              BLS      |L26.66|
000040  6160              STR      r0,[r4,#0x14]  ; uxTopReadyPriority
                  |L26.66|
000042  eb000180          ADD      r1,r0,r0,LSL #2
000046  eb090081          ADD      r0,r9,r1,LSL #2
00004a  1d39              ADDS     r1,r7,#4
00004c  f7fffffe          BL       vListInsertEnd
;;;1380   
;;;1381   					/* If we have moved a task that has a priority higher than
;;;1382   					the current task then we should yield. */
;;;1383   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000050  6af8              LDR      r0,[r7,#0x2c]
000052  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000054  6ac9              LDR      r1,[r1,#0x2c]
000056  4288              CMP      r0,r1
000058  d300              BCC      |L26.92|
;;;1384   					{
;;;1385   						xYieldRequired = pdTRUE;
00005a  2501              MOVS     r5,#1
                  |L26.92|
00005c  f8d81000          LDR      r1,[r8,#0]            ;1374  ; xPendingReadyList
000060  4640              MOV      r0,r8                 ;1374
000062  2900              CMP      r1,#0                 ;1374
000064  d1df              BNE      |L26.38|
;;;1386   					}
;;;1387   				}
;;;1388   
;;;1389   				/* If any ticks occurred while the scheduler was suspended then
;;;1390   				they should be processed now.  This ensures the tick count does not
;;;1391   				slip, and that any delayed tasks are resumed at the correct time. */
;;;1392   				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
000066  6a20              LDR      r0,[r4,#0x20]  ; uxMissedTicks
000068  b928              CBNZ     r0,|L26.118|
00006a  e009              B        |L26.128|
                  |L26.108|
;;;1393   				{
;;;1394   					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
;;;1395   					{
;;;1396   						vTaskIncrementTick();
00006c  f7fffffe          BL       vTaskIncrementTick
;;;1397   						--uxMissedTicks;
000070  6a20              LDR      r0,[r4,#0x20]  ; uxMissedTicks
000072  1e40              SUBS     r0,r0,#1
000074  6220              STR      r0,[r4,#0x20]  ; uxMissedTicks
                  |L26.118|
000076  6a20              LDR      r0,[r4,#0x20]         ;1394  ; uxMissedTicks
000078  2800              CMP      r0,#0                 ;1394
00007a  d1f7              BNE      |L26.108|
00007c  e004              B        |L26.136|
                  |L26.126|
00007e  e008              B        |L26.146|
                  |L26.128|
;;;1398   					}
;;;1399   
;;;1400   					/* As we have processed some ticks it is appropriate to yield
;;;1401   					to ensure the highest priority task that is ready to run is
;;;1402   					the task actually running. */
;;;1403   					#if configUSE_PREEMPTION == 1
;;;1404   					{
;;;1405   						xYieldRequired = pdTRUE;
;;;1406   					}
;;;1407   					#endif
;;;1408   				}
;;;1409   
;;;1410   				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
000080  b915              CBNZ     r5,|L26.136|
000082  6a60              LDR      r0,[r4,#0x24]  ; xMissedYield
000084  2801              CMP      r0,#1
000086  d104              BNE      |L26.146|
                  |L26.136|
;;;1411   				{
;;;1412   					xAlreadyYielded = pdTRUE;
;;;1413   					xMissedYield = pdFALSE;
000088  2000              MOVS     r0,#0
00008a  2601              MOVS     r6,#1                 ;1412
00008c  6260              STR      r0,[r4,#0x24]  ; xMissedYield
;;;1414   					portYIELD_WITHIN_API();
00008e  f7fffffe          BL       vPortYield
                  |L26.146|
;;;1415   				}
;;;1416   			}
;;;1417   		}
;;;1418   	}
;;;1419   	taskEXIT_CRITICAL();
000092  f7fffffe          BL       vPortExitCritical
;;;1420   
;;;1421   	return xAlreadyYielded;
000096  4630              MOV      r0,r6
;;;1422   }
000098  e8bd87f0          POP      {r4-r10,pc}
;;;1423   /*-----------------------------------------------------------*/
                          ENDP

                  |L26.156|
                          DCD      ||.data||
                  |L26.160|
                          DCD      ||.bss||+0x8c

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1192   
;;;1193   	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1194   	{
;;;1195   	portBASE_TYPE xYieldRequired = pdFALSE;
000004  2600              MOVS     r6,#0
;;;1196   	tskTCB *pxTCB;
;;;1197   	unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1198   
;;;1199   		configASSERT( xTaskToResume );
;;;1200   
;;;1201   		pxTCB = ( tskTCB * ) xTaskToResume;
000006  4604              MOV      r4,r0
;;;1202   
;;;1203   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000008  f7fffffe          BL       ulPortSetInterruptMask
00000c  4607              MOV      r7,r0
;;;1204   		{
;;;1205   			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       xTaskIsTaskSuspended
000014  2801              CMP      r0,#1
000016  d11f              BNE      |L27.88|
;;;1206   			{
;;;1207   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1208   
;;;1209   				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000018  4d12              LDR      r5,|L27.100|
00001a  69e8              LDR      r0,[r5,#0x1c]  ; uxSchedulerSuspended
00001c  b118              CBZ      r0,|L27.38|
;;;1210   				{
;;;1211   					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
;;;1212   					uxListRemove(  &( pxTCB->xGenericListItem ) );
;;;1213   					prvAddTaskToReadyQueue( pxTCB );
;;;1214   				}
;;;1215   				else
;;;1216   				{
;;;1217   					/* We cannot access the delayed or ready lists, so will hold this
;;;1218   					task pending until the scheduler is resumed, at which point a
;;;1219   					yield will be performed if necessary. */
;;;1220   					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00001e  f1040118          ADD      r1,r4,#0x18
000022  4811              LDR      r0,|L27.104|
000024  e016              B        |L27.84|
                  |L27.38|
000026  6ae0              LDR      r0,[r4,#0x2c]         ;1211
000028  6829              LDR      r1,[r5,#0]            ;1211  ; pxCurrentTCB
00002a  6ac9              LDR      r1,[r1,#0x2c]         ;1211
00002c  4288              CMP      r0,r1                 ;1211
00002e  d301              BCC      |L27.52|
000030  2601              MOVS     r6,#1                 ;1211
000032  e000              B        |L27.54|
                  |L27.52|
000034  2600              MOVS     r6,#0                 ;1211
                  |L27.54|
000036  1d20              ADDS     r0,r4,#4              ;1212
000038  f7fffffe          BL       uxListRemove
00003c  6ae0              LDR      r0,[r4,#0x2c]         ;1213
00003e  6969              LDR      r1,[r5,#0x14]         ;1213  ; uxTopReadyPriority
000040  4288              CMP      r0,r1                 ;1213
000042  d900              BLS      |L27.70|
000044  6168              STR      r0,[r5,#0x14]         ;1213  ; uxTopReadyPriority
                  |L27.70|
000046  4908              LDR      r1,|L27.104|
000048  eb000080          ADD      r0,r0,r0,LSL #2       ;1213
00004c  398c              SUBS     r1,r1,#0x8c           ;1213
00004e  eb010080          ADD      r0,r1,r0,LSL #2       ;1213
000052  1d21              ADDS     r1,r4,#4              ;1213
                  |L27.84|
000054  f7fffffe          BL       vListInsertEnd
                  |L27.88|
;;;1221   				}
;;;1222   			}
;;;1223   		}
;;;1224   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       vPortClearInterruptMask
;;;1225   
;;;1226   		return xYieldRequired;
00005e  4630              MOV      r0,r6
;;;1227   	}
000060  e8bd81f0          POP      {r4-r8,pc}
;;;1228   
                          ENDP

                  |L27.100|
                          DCD      ||.data||
                  |L27.104|
                          DCD      ||.bss||+0x8c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxTasksDeleted
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopUsedPriority
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  uxMissedTicks
                          DCD      0x00000000
                  xMissedYield
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0xffffffff
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
