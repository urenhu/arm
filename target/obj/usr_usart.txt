; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usr_usart.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\usr_usart.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usr_usart.crf ..\usr_lib\usr_usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;92     // irq handler 
;;;93     void USART1_IRQHandler(void)                	
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95     	u8    res;
;;;96     #ifdef SYSTEM_SUPPORT_FREERTOS	 	
;;;97     	//portBASE_TYPE xHigherPriorityTaskWoken;
;;;98     	//xSemaphoreGiveFromISR(xBinarySemaphore,&xHigherPriorityTaskWoken);
;;;99     	//portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);  // this is not a good way !
;;;100    #endif
;;;101    	
;;;102    
;;;103    	if ( USART_GetITStatus(USART1, USART_IT_RXNE) != RESET ){
000002  4c09              LDR      r4,|L1.40|
000004  f2405125          MOV      r1,#0x525
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L1.36|
;;;104    		  res  =  USART_ReceiveData(USART1);  //(USART1->DR);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_ReceiveData
000018  b2c1              UXTB     r1,r0
;;;105    		  enQueue( &usartObj1.qrx, res);
00001a  e8bd4010          POP      {r4,lr}
00001e  4803              LDR      r0,|L1.44|
000020  f7ffbffe          B.W      enQueue
                  |L1.36|
;;;106      } 
;;;107    } 
000024  bd10              POP      {r4,pc}
;;;108    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40013800
                  |L1.44|
                          DCD      ||.bss||

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;20     
;;;21     _sys_exit(int x) { 	x = x; } 
000000  4770              BX       lr
;;;22     
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;23     // override fputc 
;;;24     int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;25     {      
;;;26     	while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); 
000002  4d07              LDR      r5,|L3.32|
000004  4604              MOV      r4,r0                 ;25
                  |L3.6|
000006  2140              MOVS     r1,#0x40
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L3.6|
;;;27         USART_SendData(USART1,(uint8_t)ch);   
000012  b2e1              UXTB     r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       USART_SendData
;;;28     	return ch;
00001a  4620              MOV      r0,r4
;;;29     }
00001c  bd70              POP      {r4-r6,pc}
;;;30     #endif 
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40013800

                          AREA ||i.usart_getc||, CODE, READONLY, ALIGN=2

                  usart_getc PROC
;;;108    
;;;109    int usart_getc (void)  
000000  b508              PUSH     {r3,lr}
;;;110    { 
;;;111        u8   data; 
;;;112        if ( deQueue ( &usartObj1.qrx, &data) == -1 ){
000002  4669              MOV      r1,sp
000004  4803              LDR      r0,|L4.20|
000006  f7fffffe          BL       deQueue
00000a  1c40              ADDS     r0,r0,#1
00000c  d001              BEQ      |L4.18|
;;;113    		return 0;
;;;114    	} else {
;;;115    		return (int) (data &0xFF);
00000e  f89d0000          LDRB     r0,[sp,#0]
                  |L4.18|
;;;116    	}
;;;117    }
000012  bd08              POP      {r3,pc}
;;;118    
                          ENDP

                  |L4.20|
                          DCD      ||.bss||

                          AREA ||i.usart_hitkey||, CODE, READONLY, ALIGN=2

                  usart_hitkey PROC
;;;118    
;;;119    int usart_hitkey (void)  
000000  b508              PUSH     {r3,lr}
                  |L5.2|
;;;120    { 
;;;121        u8   data; 
;;;122        while ( deQueue ( &usartObj1.qrx, &data) == -1 );
000002  4669              MOV      r1,sp
000004  4803              LDR      r0,|L5.20|
000006  f7fffffe          BL       deQueue
00000a  1c40              ADDS     r0,r0,#1
00000c  d0f9              BEQ      |L5.2|
;;;123        return (int) (data &0xFF);
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;124    }
000012  bd08              POP      {r3,pc}
;;;125    
                          ENDP

                  |L5.20|
                          DCD      ||.bss||

                          AREA ||i.usart_init||, CODE, READONLY, ALIGN=2

                  usart_init PROC
;;;45     
;;;46     void usart_init( u32 bound)
000000  b5f0              PUSH     {r4-r7,lr}
;;;47     {
000002  4605              MOV      r5,r0
000004  b087              SUB      sp,sp,#0x1c
;;;48         GPIO_InitTypeDef GPIO_InitStructure;
;;;49     	USART_InitTypeDef USART_InitStructure;
;;;50     	NVIC_InitTypeDef NVIC_InitStructure;
;;;51     	 
;;;52     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	  // uses  USART1£¬ and GPIOA clocking
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53      	USART_DeInit(USART1);  
000010  4e25              LDR      r6,|L6.168|
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       USART_DeInit
;;;54     
;;;55     	//USART1_TX   PA.9
;;;56         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000018  1570              ASRS     r0,r6,#21
00001a  f8ad0010          STRH     r0,[sp,#0x10]
;;;57         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2403              MOVS     r4,#3
000020  f88d4012          STRB     r4,[sp,#0x12]
;;;58         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	
000024  2018              MOVS     r0,#0x18
;;;59         GPIO_Init(GPIOA, &GPIO_InitStructure); // PA9
000026  4f21              LDR      r7,|L6.172|
000028  f88d0013          STRB     r0,[sp,#0x13]         ;58
00002c  a904              ADD      r1,sp,#0x10
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       GPIO_Init
;;;60        
;;;61         //USART1_RX	  PA.10
;;;62         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000034  1530              ASRS     r0,r6,#20
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;63         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0013          STRB     r0,[sp,#0x13]
;;;64         GPIO_Init(GPIOA, &GPIO_InitStructure);  // PA10
000040  a904              ADD      r1,sp,#0x10
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       GPIO_Init
;;;65     
;;;66        //USART 
;;;67     	USART_InitStructure.USART_BaudRate = bound;                   //default 9600;
;;;68     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000048  2100              MOVS     r1,#0
;;;69     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;70     	USART_InitStructure.USART_Parity = USART_Parity_No;
00004a  f8ad1008          STRH     r1,[sp,#8]
00004e  f8ad1004          STRH     r1,[sp,#4]            ;68
;;;71     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;72     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	// IMPORTANT!
000052  200c              MOVS     r0,#0xc
000054  f8ad1006          STRH     r1,[sp,#6]            ;69
000058  f8ad100c          STRH     r1,[sp,#0xc]          ;71
00005c  f8ad000a          STRH     r0,[sp,#0xa]
000060  9500              STR      r5,[sp,#0]            ;68
;;;73     
;;;74         USART_Init(USART1, &USART_InitStructure); 
000062  4669              MOV      r1,sp
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       USART_Init
;;;75     
;;;76        //Usart1 NVIC config 
;;;77         NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00006a  2025              MOVS     r0,#0x25
00006c  f88d0014          STRB     r0,[sp,#0x14]
;;;78     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3 ;
000070  f88d4015          STRB     r4,[sp,#0x15]
;;;79     	NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 3 ;
000074  f88d4016          STRB     r4,[sp,#0x16]
;;;80     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	//IRQ enable 
000078  2001              MOVS     r0,#1
00007a  f88d0017          STRB     r0,[sp,#0x17]
;;;81     	NVIC_Init(&NVIC_InitStructure);
00007e  a805              ADD      r0,sp,#0x14
000080  f7fffffe          BL       NVIC_Init
;;;82        
;;;83         USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       USART_ITConfig
;;;84     	
;;;85         USART_Cmd(USART1, ENABLE);
000090  2101              MOVS     r1,#1
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       USART_Cmd
;;;86     
;;;87         initQueue ( &usartObj1.qrx); 
000098  4805              LDR      r0,|L6.176|
00009a  f7fffffe          BL       initQueue
;;;88         usartObj1.baud         = bound; 
00009e  4804              LDR      r0,|L6.176|
0000a0  61c5              STR      r5,[r0,#0x1c]  ; usartObj1
;;;89     } //end 
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  bdf0              POP      {r4-r7,pc}
;;;90     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L6.168|
                          DCD      0x40013800
                  |L6.172|
                          DCD      0x40010800
                  |L6.176|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usartObj1
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
