; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ili9328.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\ili9328.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\core -I..\STM32F10x_StdPeriph_Driver\inc -I..\app -I..\usr_lib -I..\ctt -I..\glcd\st7066 -I..\sensor -I..\free_rtos -I..\glcd\glcd-ili9328 -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ili9328.crf ..\glcd\glcd-ili9328\ili9328.c]
                          THUMB

                          AREA ||i.PIN_RESET||, CODE, READONLY, ALIGN=2

                  PIN_RESET PROC
;;;71     //--------------------------------------------------------------
;;;72     static void PIN_RESET(int pin) {  GPIO_ResetBits(oGPIO[pin].port, oGPIO[pin].pin ); }
000000  eb000180          ADD      r1,r0,r0,LSL #2
000004  4803              LDR      r0,|L1.20|
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  8901              LDRH     r1,[r0,#8]
00000c  6840              LDR      r0,[r0,#4]
00000e  f7ffbffe          B.W      GPIO_ResetBits
;;;73     static void PIN_SET  (int pin) {  GPIO_SetBits  (oGPIO[pin].port, oGPIO[pin].pin ); }
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.PIN_SET||, CODE, READONLY, ALIGN=2

                  PIN_SET PROC
;;;72     static void PIN_RESET(int pin) {  GPIO_ResetBits(oGPIO[pin].port, oGPIO[pin].pin ); }
;;;73     static void PIN_SET  (int pin) {  GPIO_SetBits  (oGPIO[pin].port, oGPIO[pin].pin ); }
000000  eb000180          ADD      r1,r0,r0,LSL #2
000004  4803              LDR      r0,|L2.20|
000006  eb000081          ADD      r0,r0,r1,LSL #2
00000a  8901              LDRH     r1,[r0,#8]
00000c  6840              LDR      r0,[r0,#4]
00000e  f7ffbffe          B.W      GPIO_SetBits
;;;74     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.ili9328_command||, CODE, READONLY, ALIGN=1

                  ili9328_command PROC
;;;129    /**************************************************************************/
;;;130    static void ili9328_command (uint16_t command, uint16_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;131    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;132      PIN_RESET (LCD_CS) ;     // CS enable 
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       PIN_RESET
;;;133      ili9328_write_command (command);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       ili9328_write_command
;;;134      ili9328_write_data    (data);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       ili9328_write_data
;;;135      PIN_SET (LCD_CS) ;     // CS disable 
000018  e8bd4070          POP      {r4-r6,lr}
00001c  2001              MOVS     r0,#1
00001e  f7ffbffe          B.W      PIN_SET
;;;136    }
;;;137    
                          ENDP


                          AREA ||i.ili9328_home||, CODE, READONLY, ALIGN=1

                  ili9328_home PROC
;;;259    */
;;;260    void ili9328_home(void)
000000  b510              PUSH     {r4,lr}
;;;261    {
;;;262      ili9328_set_cursor(0, 0);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       ili9328_set_cursor
;;;263      ili9328_write_command (CMD_WRITEDATATOGRAM); 
00000a  e8bd4010          POP      {r4,lr}
00000e  2022              MOVS     r0,#0x22
000010  f7ffbffe          B.W      ili9328_write_command
;;;264    	// Write Data to GRAM (R22h)
;;;265    }
;;;266    
                          ENDP


                          AREA ||i.ili9328_init_display||, CODE, READONLY, ALIGN=2

                  ili9328_init_display PROC
;;;160    **************************************************************************/
;;;161    void ili9328_init_display(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;162    {
;;;163      GPIO_InitTypeDef        GPIO_InitStructure;
;;;164      int  pin;
;;;165    
;;;166      oDev.orientation      = 0;
000004  4c79              LDR      r4,|L5.492|
000006  2000              MOVS     r0,#0
;;;167     	oDev.color            = 1;	
;;;168    	oDev.property         = &oProperty; // {240, 320, 0, 1, 1}, 
;;;169    	oDev.gpio             = &oGPIO[0];
;;;170    	
;;;171      for(pin=0; pin < PIN_NUM; pin++) {
000008  2500              MOVS     r5,#0
00000a  6020              STR      r0,[r4,#0]            ;167  ; oDev
00000c  2001              MOVS     r0,#1                 ;167
00000e  6060              STR      r0,[r4,#4]            ;168  ; oDev
000010  4877              LDR      r0,|L5.496|
000012  60a0              STR      r0,[r4,#8]            ;169  ; oDev
000014  3828              SUBS     r0,r0,#0x28           ;169
;;;172        // Clock Enable
;;;173        RCC_APB2PeriphClockCmd(oDev.gpio[pin].clk, ENABLE);
000016  270c              MOVS     r7,#0xc
;;;174    
;;;175        // Config als Digital-output
;;;176        GPIO_InitStructure.GPIO_Pin     = oDev.gpio[pin].pin;
000018  f04f0808          MOV      r8,#8
;;;177        GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_AF_PP;
00001c  f04f0918          MOV      r9,#0x18
;;;178        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  f04f0a03          MOV      r10,#3
;;;179        GPIO_Init(oDev.gpio[pin].port, &GPIO_InitStructure);
000024  f04f0b04          MOV      r11,#4
000028  f8c4000c          STR.W    r0,[r4,#0xc]
                  |L5.44|
00002c  eb050685          ADD      r6,r5,r5,LSL #2       ;173
000030  68e0              LDR      r0,[r4,#0xc]          ;173  ; oDev
000032  eb070186          ADD      r1,r7,r6,LSL #2       ;173
000036  5840              LDR      r0,[r0,r1]            ;173
000038  2101              MOVS     r1,#1                 ;173
00003a  f7fffffe          BL       RCC_APB2PeriphClockCmd
00003e  68e0              LDR      r0,[r4,#0xc]          ;176  ; oDev
000040  eb080186          ADD      r1,r8,r6,LSL #2       ;176
000044  5a41              LDRH     r1,[r0,r1]            ;176
000046  f8ad1000          STRH     r1,[sp,#0]            ;176
00004a  f88d9003          STRB     r9,[sp,#3]            ;177
00004e  eb0b0186          ADD      r1,r11,r6,LSL #2
000052  f88da002          STRB     r10,[sp,#2]           ;178
000056  5840              LDR      r0,[r0,r1]
000058  4669              MOV      r1,sp
00005a  f7fffffe          BL       GPIO_Init
;;;180    
;;;181        // set default of each pin 
;;;182        if (oDev.gpio[pin].initValue == Bit_RESET) {
00005e  2010              MOVS     r0,#0x10
000060  68e1              LDR      r1,[r4,#0xc]  ; oDev
000062  eb000086          ADD      r0,r0,r6,LSL #2
000066  5c08              LDRB     r0,[r1,r0]
000068  2800              CMP      r0,#0
;;;183            PIN_RESET(pin);
;;;184        } else {
;;;185            PIN_SET(pin);
00006a  4628              MOV      r0,r5
00006c  d07d              BEQ      |L5.362|
00006e  f7fffffe          BL       PIN_SET
                  |L5.114|
000072  1c6d              ADDS     r5,r5,#1
000074  2d02              CMP      r5,#2                 ;171
000076  d3d9              BCC      |L5.44|
;;;186        }
;;;187      }
;;;188    
;;;189      usrspi2_init (2, 0, 0); // three wire, MSB first, mode = 0       
000078  2200              MOVS     r2,#0
00007a  4611              MOV      r1,r2
00007c  2002              MOVS     r0,#2
00007e  f7fffffe          BL       usrspi2_init
;;;190      usrspi2_setspeed(SPI_BaudRatePrescaler_256);  // SPI_BaudRatePrescaler_2); clk PW=0.025us = 28 ns/ 256 clk PW = 4us; 128 = 1.8us ( confirmed!!)
000082  2038              MOVS     r0,#0x38
000084  f7fffffe          BL       usrspi2_setspeed
;;;191    
;;;192      // reset LCD module ==========
;;;193      PIN_RESET (LCD_RST );    
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       PIN_RESET
;;;194      delay_ms(100);   
00008e  2064              MOVS     r0,#0x64
000090  f7fffffe          BL       delay_ms
;;;195      PIN_SET (LCD_RST );    
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       PIN_SET
;;;196      delay_ms(1);   
00009a  2001              MOVS     r0,#1
00009c  f7fffffe          BL       delay_ms
;;;197    
;;;198      // set commands  
;;;199      ili9328_command(CMD_DRIVEROUTPUTCONTROL1, 0x0100);  // Driver Output Control Register (R01h)
0000a0  f44f7180          MOV      r1,#0x100
0000a4  2001              MOVS     r0,#1
0000a6  f7fffffe          BL       ili9328_command
;;;200      ili9328_command(CMD_LCDDRIVINGCONTROL, 0x0700);     // LCD Driving Waveform Control (R02h)
0000aa  f44f61e0          MOV      r1,#0x700
0000ae  2002              MOVS     r0,#2
0000b0  f7fffffe          BL       ili9328_command
;;;201      ili9328_command(CMD_ENTRYMODE, 0x1030);             // Entry Mode (R03h)  
0000b4  f2410130          MOV      r1,#0x1030
0000b8  2003              MOVS     r0,#3
0000ba  f7fffffe          BL       ili9328_command
;;;202      ili9328_command(CMD_DISPLAYCONTROL2, 0x0302);
0000be  f2403102          MOV      r1,#0x302
0000c2  2008              MOVS     r0,#8
0000c4  f7fffffe          BL       ili9328_command
;;;203      ili9328_command(CMD_DISPLAYCONTROL3, 0x0000);
0000c8  2100              MOVS     r1,#0
0000ca  2009              MOVS     r0,#9
0000cc  f7fffffe          BL       ili9328_command
;;;204      ili9328_command(CMD_DISPLAYCONTROL4, 0x0000);       // Fmark On
0000d0  2100              MOVS     r1,#0
0000d2  200a              MOVS     r0,#0xa
0000d4  f7fffffe          BL       ili9328_command
;;;205      ili9328_command(CMD_POWERCONTROL1, 0x0000);         // Power Control 1 (R10h)
0000d8  2100              MOVS     r1,#0
0000da  2010              MOVS     r0,#0x10
0000dc  f7fffffe          BL       ili9328_command
;;;206      ili9328_command(CMD_POWERCONTROL2, 0x0007);         // Power Control 2 (R11h)
0000e0  2107              MOVS     r1,#7
0000e2  2011              MOVS     r0,#0x11
0000e4  f7fffffe          BL       ili9328_command
;;;207      ili9328_command(CMD_POWERCONTROL3, 0x0000);         // Power Control 3 (R12h)
0000e8  2100              MOVS     r1,#0
0000ea  2012              MOVS     r0,#0x12
0000ec  f7fffffe          BL       ili9328_command
;;;208      ili9328_command(CMD_POWERCONTROL4, 0x0000);         // Power Control 4 (R13h)
0000f0  2100              MOVS     r1,#0
0000f2  2013              MOVS     r0,#0x13
0000f4  f7fffffe          BL       ili9328_command
;;;209      
;;;210    	delay_ms(1000);  
0000f8  f44f707a          MOV      r0,#0x3e8
0000fc  f7fffffe          BL       delay_ms
;;;211      
;;;212    	ili9328_command(CMD_POWERCONTROL1, 0x14B0);         // Power Control 1 (R10h)  
000100  f24141b0          MOV      r1,#0x14b0
000104  2010              MOVS     r0,#0x10
000106  f7fffffe          BL       ili9328_command
;;;213      
;;;214    	delay_ms(500);  
00010a  f44f74fa          MOV      r4,#0x1f4
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       delay_ms
;;;215      
;;;216    	ili9328_command(CMD_POWERCONTROL2, 0x0007);         // Power Control 2 (R11h)  
000114  2107              MOVS     r1,#7
000116  2011              MOVS     r0,#0x11
000118  f7fffffe          BL       ili9328_command
;;;217      
;;;218    	delay_ms(500);  
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       delay_ms
;;;219      
;;;220    	ili9328_command(CMD_POWERCONTROL3, 0x008E);         // Power Control 3 (R12h)
000122  218e              MOVS     r1,#0x8e
000124  2012              MOVS     r0,#0x12
000126  f7fffffe          BL       ili9328_command
;;;221      ili9328_command(CMD_POWERCONTROL4, 0x0C00);         // Power Control 4 (R13h)
00012a  f44f6140          MOV      r1,#0xc00
00012e  2013              MOVS     r0,#0x13
000130  f7fffffe          BL       ili9328_command
;;;222      ili9328_command(CMD_POWERCONTROL7, 0x0015);         // NVM read data 2 (R29h)
000134  2115              MOVS     r1,#0x15
000136  2029              MOVS     r0,#0x29
000138  f7fffffe          BL       ili9328_command
;;;223      
;;;224    	delay_ms(500);
00013c  4620              MOV      r0,r4
00013e  f7fffffe          BL       delay_ms
;;;225      
;;;226    	ili9328_command(CMD_GAMMACONTROL1, 0x0000);         // Gamma Control 1
000142  2100              MOVS     r1,#0
000144  2030              MOVS     r0,#0x30
000146  f7fffffe          BL       ili9328_command
;;;227      ili9328_command(CMD_GAMMACONTROL2, 0x0107);         // Gamma Control 2
00014a  f2401107          MOV      r1,#0x107
00014e  2031              MOVS     r0,#0x31
000150  f7fffffe          BL       ili9328_command
;;;228      ili9328_command(CMD_GAMMACONTROL3, 0x0000);         // Gamma Control 3
000154  2100              MOVS     r1,#0
000156  2032              MOVS     r0,#0x32
000158  f7fffffe          BL       ili9328_command
;;;229      ili9328_command(CMD_GAMMACONTROL4, 0x0203);         // Gamma Control 4
00015c  f2402503          MOV      r5,#0x203
000160  4629              MOV      r1,r5
000162  2035              MOVS     r0,#0x35
000164  f7fffffe          BL       ili9328_command
;;;230      ili9328_command(CMD_GAMMACONTROL5, 0x0402);         // Gamma Control 5
000168  e000              B        |L5.364|
                  |L5.362|
00016a  e03b              B        |L5.484|
                  |L5.364|
00016c  f2404102          MOV      r1,#0x402
000170  2036              MOVS     r0,#0x36
000172  f7fffffe          BL       ili9328_command
;;;231      ili9328_command(CMD_GAMMACONTROL6, 0x0000);         // Gamma Control 6
000176  2100              MOVS     r1,#0
000178  2037              MOVS     r0,#0x37
00017a  f7fffffe          BL       ili9328_command
;;;232      ili9328_command(CMD_GAMMACONTROL7, 0x0207);         // Gamma Control 7
00017e  1d29              ADDS     r1,r5,#4
000180  2038              MOVS     r0,#0x38
000182  f7fffffe          BL       ili9328_command
;;;233      ili9328_command(CMD_GAMMACONTROL8, 0x0000);         // Gamma Control 8
000186  2100              MOVS     r1,#0
000188  2039              MOVS     r0,#0x39
00018a  f7fffffe          BL       ili9328_command
;;;234      ili9328_command(CMD_GAMMACONTROL9, 0x0203);         // Gamma Control 9
00018e  4629              MOV      r1,r5
000190  203c              MOVS     r0,#0x3c
000192  f7fffffe          BL       ili9328_command
;;;235      ili9328_command(CMD_GAMMACONTROL10, 0x0403);        // Gamma Control 10
000196  f2404103          MOV      r1,#0x403
00019a  203d              MOVS     r0,#0x3d
00019c  f7fffffe          BL       ili9328_command
;;;236      ili9328_command(CMD_HORIZONTALADDRESSSTARTPOSITION, 0x0000);                      // Window Horizontal RAM Address Start (R50h)
0001a0  2100              MOVS     r1,#0
0001a2  2050              MOVS     r0,#0x50
0001a4  f7fffffe          BL       ili9328_command
;;;237      
;;;238    	//ili9328_command(CMD_HORIZONTALADDRESSENDPOSITION, ili9328_Properties.width - 1);   // Window Horizontal RAM Address End (R51h)
;;;239      
;;;240    	ili9328_command(CMD_VERTICALADDRESSSTARTPOSITION, 0X0000);                        // Window Vertical RAM Address Start (R52h)
0001a8  2100              MOVS     r1,#0
0001aa  2052              MOVS     r0,#0x52
0001ac  f7fffffe          BL       ili9328_command
;;;241      
;;;242    	//ili9328_command(CMD_VERTICALADDRESSENDPOSITION, ili9328_Properties.height - 1);    // Window Vertical RAM Address End (R53h)
;;;243      
;;;244    	ili9328_command(CMD_DRIVEROUTPUTCONTROL2, 0xa700);    // Driver Output Control (R60h)
0001b0  f44f4127          MOV      r1,#0xa700
0001b4  2060              MOVS     r0,#0x60
0001b6  f7fffffe          BL       ili9328_command
;;;245      ili9328_command(CMD_BASEIMAGEDISPLAYCONTROL, 0x0003); // Driver Output Control (R61h) - enable VLE
0001ba  2103              MOVS     r1,#3
0001bc  2061              MOVS     r0,#0x61
0001be  f7fffffe          BL       ili9328_command
;;;246      ili9328_command(CMD_PANELINTERFACECONTROL1, 0X0010);  // Panel Interface Control 1 (R90h)
0001c2  2110              MOVS     r1,#0x10
0001c4  2090              MOVS     r0,#0x90
0001c6  f7fffffe          BL       ili9328_command
;;;247    
;;;248      // Display On
;;;249      ili9328_command(CMD_DISPLAYCONTROL1, 0x0133);     // Display Control (R07h)
0001ca  f2401133          MOV      r1,#0x133
0001ce  2007              MOVS     r0,#7
0001d0  f7fffffe          BL       ili9328_command
;;;250      
;;;251    	delay_ms (500);
0001d4  4620              MOV      r0,r4
0001d6  f7fffffe          BL       delay_ms
;;;252      
;;;253    	ili9328_write_command (CMD_WRITEDATATOGRAM);
0001da  2022              MOVS     r0,#0x22
0001dc  f7fffffe          BL       ili9328_write_command
;;;254    }
0001e0  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.484|
0001e4  f7fffffe          BL       PIN_RESET
0001e8  e743              B        |L5.114|
;;;255    
                          ENDP

0001ea  0000              DCW      0x0000
                  |L5.492|
                          DCD      ||.bss||
                  |L5.496|
                          DCD      ||.data||+0x28

                          AREA ||i.ili9328_set_cursor||, CODE, READONLY, ALIGN=2

                  ili9328_set_cursor PROC
;;;141    **************************************************************************/
;;;142    void ili9328_set_cursor(uint16_t x, uint16_t y)
000000  b510              PUSH     {r4,lr}
;;;143    {
000002  460c              MOV      r4,r1
;;;144      uint16_t al, ah;
;;;145      
;;;146      if (oDev.orientation == LCD_ORIENTATION_LANDSCAPE)  {
000004  4908              LDR      r1,|L6.40|
000006  6809              LDR      r1,[r1,#0]  ; oDev
000008  2901              CMP      r1,#1
00000a  d009              BEQ      |L6.32|
;;;147        al = y;
;;;148        ah = x;
;;;149      }  else  {
;;;150        al = x;
00000c  4601              MOV      r1,r0
                  |L6.14|
;;;151        ah = y;
;;;152      }
;;;153      ili9328_command ( CMD_HORIZONTALGRAMADDRESSSET, al);
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       ili9328_command
;;;154      ili9328_command ( CMD_VERTICALGRAMADDRESSSET  , ah);
000014  4621              MOV      r1,r4
000016  e8bd4010          POP      {r4,lr}
00001a  2021              MOVS     r0,#0x21
00001c  f7ffbffe          B.W      ili9328_command
                  |L6.32|
000020  4621              MOV      r1,r4                 ;147
000022  4604              MOV      r4,r0                 ;148
000024  e7f3              B        |L6.14|
;;;155    }
;;;156    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      ||.bss||

                          AREA ||i.ili9328_set_window||, CODE, READONLY, ALIGN=1

                  ili9328_set_window PROC
;;;269    **************************************************************************/
;;;270    void ili9328_set_window(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;271    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;272      ili9328_command(CMD_HORIZONTALADDRESSSTARTPOSITION, x0);
000008  4601              MOV      r1,r0
00000a  461e              MOV      r6,r3                 ;271
00000c  4617              MOV      r7,r2                 ;271
00000e  2050              MOVS     r0,#0x50
000010  f7fffffe          BL       ili9328_command
;;;273      ili9328_command(CMD_HORIZONTALADDRESSENDPOSITION,   x1);
000014  4639              MOV      r1,r7
000016  2051              MOVS     r0,#0x51
000018  f7fffffe          BL       ili9328_command
;;;274      ili9328_command(CMD_VERTICALADDRESSSTARTPOSITION,   y0);
00001c  4629              MOV      r1,r5
00001e  2052              MOVS     r0,#0x52
000020  f7fffffe          BL       ili9328_command
;;;275      ili9328_command(CMD_VERTICALADDRESSENDPOSITION,     y1);
000024  4631              MOV      r1,r6
000026  2053              MOVS     r0,#0x53
000028  f7fffffe          BL       ili9328_command
;;;276      ili9328_set_cursor(x0, y0);
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  e8bd41f0          POP      {r4-r8,lr}
000034  f7ffbffe          B.W      ili9328_set_cursor
;;;277    }
;;;278    
                          ENDP


                          AREA ||i.ili9328_write_command||, CODE, READONLY, ALIGN=1

                  ili9328_write_command PROC
;;;77     **************************************************************************/
;;;78     static void ili9328_write_command(uint16_t command) 
000000  b510              PUSH     {r4,lr}
;;;79     {
000002  4604              MOV      r4,r0
;;;80       unsigned char temp;   
;;;81     
;;;82       PIN_RESET (LCD_CS) ;     // CS enable 
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       PIN_RESET
;;;83       temp = 0x70;      //RS = 1, data  RW = 0, write mode   
00000a  2070              MOVS     r0,#0x70
;;;84       usrspi2_SendByte3Wire  (temp); 
00000c  f7fffffe          BL       usrspi2_SendByte3Wire
;;;85     	temp = (command >>8)&0xff;   
000010  0a20              LSRS     r0,r4,#8
;;;86       usrspi2_SendByte3Wire (temp); 
000012  f7fffffe          BL       usrspi2_SendByte3Wire
;;;87     	temp = (command>>0)&0xff;   
000016  b2e0              UXTB     r0,r4
;;;88       usrspi2_SendByte3Wire (temp);
000018  f7fffffe          BL       usrspi2_SendByte3Wire
;;;89       PIN_SET (LCD_CS) ;     // CS enable 
00001c  e8bd4010          POP      {r4,lr}
000020  2001              MOVS     r0,#1
000022  f7ffbffe          B.W      PIN_SET
;;;90     }
;;;91     
                          ENDP


                          AREA ||i.ili9328_write_data||, CODE, READONLY, ALIGN=1

                  ili9328_write_data PROC
;;;94     **************************************************************************/
;;;95     static void ili9328_write_data(uint16_t data)
000000  b510              PUSH     {r4,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97       unsigned char temp;   
;;;98     
;;;99       PIN_RESET (LCD_CS) ;     // CS enable 
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       PIN_RESET
;;;100      temp = 0x72;      //RS = 1, data  RW = 0, write mode   
00000a  2072              MOVS     r0,#0x72
;;;101      usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);// send SPI frame 
00000c  f7fffffe          BL       usrspi2_SendByte3Wire
;;;102      temp = (data>>8)&0xff;   
000010  0a20              LSRS     r0,r4,#8
;;;103      usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);// send SPI frame 
000012  f7fffffe          BL       usrspi2_SendByte3Wire
;;;104      temp = (data>>0)&0xff;   
000016  b2e0              UXTB     r0,r4
;;;105      usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);// send SPI frame 
000018  f7fffffe          BL       usrspi2_SendByte3Wire
;;;106    	PIN_SET (LCD_CS) ;     // CS enable 
00001c  e8bd4010          POP      {r4,lr}
000020  2001              MOVS     r0,#1
000022  f7ffbffe          B.W      PIN_SET
;;;107      
;;;108    }
;;;109      
                          ENDP


                          AREA ||i.lcd_draw_line||, CODE, READONLY, ALIGN=1

                  lcd_draw_line PROC
;;;399    /**************************************************************************/
;;;400    void lcd_draw_line(uint16_t x0, uint16_t x1, uint16_t y, uint16_t color)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;401    {
000004  4605              MOV      r5,r0
000006  461f              MOV      r7,r3
000008  460c              MOV      r4,r1
;;;402      // Allows for slightly better performance than setting individual pixels
;;;403      uint16_t x, pixels;
;;;404      if (x1 < x0) {   // Switch x1 and x0
00000a  42a9              CMP      r1,r5
00000c  d201              BCS      |L10.18|
;;;405        x = x1;
;;;406        x1 = x0;
00000e  462c              MOV      r4,r5
;;;407        x0 = x;
000010  460d              MOV      r5,r1
                  |L10.18|
;;;408      }
;;;409      // Check limits
;;;410      if (x1 >= lcd_get_width() ) {
000012  f7fffffe          BL       lcd_get_width
000016  42a0              CMP      r0,r4
000018  d803              BHI      |L10.34|
;;;411        x1 = lcd_get_width()  - 1;
00001a  f7fffffe          BL       lcd_get_width
00001e  1e40              SUBS     r0,r0,#1
000020  b284              UXTH     r4,r0
                  |L10.34|
;;;412      }
;;;413      if (x0 >= lcd_get_width() )  {
000022  f7fffffe          BL       lcd_get_width
000026  42a8              CMP      r0,r5
000028  d803              BHI      |L10.50|
;;;414        x0 = lcd_get_width()  - 1;
00002a  f7fffffe          BL       lcd_get_width
00002e  1e40              SUBS     r0,r0,#1
000030  b285              UXTH     r5,r0
                  |L10.50|
;;;415      }
;;;416    
;;;417      ili9328_set_cursor(x0, y);
000032  4611              MOV      r1,r2
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       ili9328_set_cursor
;;;418      ili9328_write_command (CMD_WRITEDATATOGRAM);  // Write Data to GRAM (R22h)
00003a  2022              MOVS     r0,#0x22
00003c  f7fffffe          BL       ili9328_write_command
;;;419      for (pixels = 0; pixels < x1 - x0 + 1; pixels++)  {
000040  2600              MOVS     r6,#0
000042  1b64              SUBS     r4,r4,r5
000044  1c64              ADDS     r4,r4,#1
000046  e004              B        |L10.82|
                  |L10.72|
;;;420        ili9328_write_data (color);
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       ili9328_write_data
00004e  1c76              ADDS     r6,r6,#1
000050  b2b6              UXTH     r6,r6                 ;419
                  |L10.82|
000052  42b4              CMP      r4,r6                 ;419
000054  dcf8              BGT      |L10.72|
;;;421      }
;;;422    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;423    
                          ENDP


                          AREA ||i.lcd_draw_pixel||, CODE, READONLY, ALIGN=1

                  lcd_draw_pixel PROC
;;;369    /**************************************************************************/
;;;370    void lcd_draw_pixel(uint16_t x, uint16_t y, uint16_t color)
000000  b510              PUSH     {r4,lr}
;;;371    {
000002  4614              MOV      r4,r2
;;;372      ili9328_set_cursor     (x, y);
000004  f7fffffe          BL       ili9328_set_cursor
;;;373      ili9328_write_command  (CMD_WRITEDATATOGRAM);  // Write Data to GRAM (R22h)
000008  2022              MOVS     r0,#0x22
00000a  f7fffffe          BL       ili9328_write_command
;;;374      ili9328_write_data     (color);
00000e  4620              MOV      r0,r4
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      ili9328_write_data
;;;375    }
;;;376    
                          ENDP


                          AREA ||i.lcd_draw_pixels||, CODE, READONLY, ALIGN=2

                  lcd_draw_pixels PROC
;;;382    /**************************************************************************/
;;;383    void lcd_draw_pixels (uint16_t x, uint16_t y, uint16_t *data, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
000002  461d              MOV      r5,r3
000004  4616              MOV      r6,r2
;;;385      uint32_t i = 0;
000006  2400              MOVS     r4,#0
;;;386      ili9328_set_cursor(x, y);
000008  f7fffffe          BL       ili9328_set_cursor
;;;387      ili9328_write_command  (CMD_WRITEDATATOGRAM);
00000c  2022              MOVS     r0,#0x22
00000e  f7fffffe          BL       ili9328_write_command
;;;388      do {
;;;389        ili9328_write_data (data[i]);
000012  bf00              NOP      
                  |L12.20|
000014  f8360014          LDRH     r0,[r6,r4,LSL #1]
000018  f7fffffe          BL       ili9328_write_data
00001c  1c64              ADDS     r4,r4,#1
;;;390        i++;
;;;391      } while (i<len);
00001e  42ac              CMP      r4,r5
000020  d3f8              BCC      |L12.20|
;;;392    }
000022  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP


                          AREA ||i.lcd_fill_RGB||, CODE, READONLY, ALIGN=1

                  lcd_fill_RGB PROC
;;;352    /**************************************************************************/
;;;353    void lcd_fill_RGB(uint16_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;354    {
000002  4606              MOV      r6,r0
;;;355      unsigned int i;
;;;356      uint32_t pixels = 320*240;
000004  f44f3596          MOV      r5,#0x12c00
;;;357      
;;;358      ili9328_home();
000008  f7fffffe          BL       ili9328_home
;;;359      
;;;360      for ( i=0; i < pixels; i++ ){
00000c  2400              MOVS     r4,#0
                  |L13.14|
;;;361        ili9328_write_data(data);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       ili9328_write_data
000014  1c64              ADDS     r4,r4,#1
000016  42ac              CMP      r4,r5                 ;360
000018  d3f9              BCC      |L13.14|
;;;362      } 
;;;363    }
00001a  bd70              POP      {r4-r6,pc}
;;;364    
                          ENDP


                          AREA ||i.lcd_get_height||, CODE, READONLY, ALIGN=2

                  lcd_get_height PROC
;;;499    /**************************************************************************/
;;;500    uint16_t lcd_get_height (void)
000000  4803              LDR      r0,|L14.16|
;;;501    {
;;;502    	
;;;503      switch (oDev.orientation)  {
000002  6801              LDR      r1,[r0,#0]  ; oDev
;;;504        case LCD_ORIENTATION_PORTRAIT:
;;;505          return (uint16_t)oDev.property->height;
000004  6880              LDR      r0,[r0,#8]
000006  b109              CBZ      r1,|L14.12|
;;;506          break;
;;;507        case LCD_ORIENTATION_LANDSCAPE:
;;;508        default:
;;;509          return (uint16_t)oDev.property->width;
000008  8800              LDRH     r0,[r0,#0]
;;;510      }
;;;511    }
00000a  4770              BX       lr
                  |L14.12|
00000c  8840              LDRH     r0,[r0,#2]            ;505
00000e  4770              BX       lr
;;;512    
                          ENDP

                  |L14.16|
                          DCD      ||.bss||

                          AREA ||i.lcd_get_orientation||, CODE, READONLY, ALIGN=2

                  lcd_get_orientation PROC
;;;470    /**************************************************************************/
;;;471    int lcd_get_orientation(void)
000000  4801              LDR      r0,|L15.8|
;;;472    {
;;;473      return oDev.orientation;
000002  6800              LDR      r0,[r0,#0]  ; oDev
;;;474    }
000004  4770              BX       lr
;;;475    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.bss||

                          AREA ||i.lcd_get_width||, CODE, READONLY, ALIGN=2

                  lcd_get_width PROC
;;;481    /**************************************************************************/
;;;482    uint16_t lcd_get_width (void)
000000  4803              LDR      r0,|L16.16|
;;;483    {
;;;484      switch (oDev.orientation)  {
000002  6801              LDR      r1,[r0,#0]  ; oDev
;;;485        case LCD_ORIENTATION_PORTRAIT:
;;;486          return (uint16_t)oDev.property->width;
000004  6880              LDR      r0,[r0,#8]
000006  b109              CBZ      r1,|L16.12|
;;;487          break;
;;;488        case LCD_ORIENTATION_LANDSCAPE:
;;;489        default:
;;;490          return (uint16_t)oDev.property->height;
000008  8840              LDRH     r0,[r0,#2]
;;;491      }
;;;492    }
00000a  4770              BX       lr
                  |L16.12|
00000c  8800              LDRH     r0,[r0,#0]            ;486
00000e  4770              BX       lr
;;;493    
                          ENDP

                  |L16.16|
                          DCD      ||.bss||

                          AREA ||i.lcd_init||, CODE, READONLY, ALIGN=1

                  lcd_init PROC
;;;281    /*************************************************/
;;;282    void lcd_init(void)
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284      // Set control line pins to output
;;;285      
;;;286      // Set data port pins to output
;;;287    
;;;288      // Disable pullups
;;;289      
;;;290      // Set backlight pin to output and turn it on
;;;291    
;;;292      // Set reset pin to output
;;;293      PIN_RESET (LCD_RST);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       PIN_RESET
;;;294      delay_ms(100);
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       delay_ms
;;;295      PIN_SET (LCD_RST);
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       PIN_SET
;;;296      delay_ms(100);
000014  2064              MOVS     r0,#0x64
000016  f7fffffe          BL       delay_ms
;;;297    
;;;298      // Initialize the display
;;;299      ili9328_init_display();
00001a  f7fffffe          BL       ili9328_init_display
;;;300    
;;;301      // Set lcd to default orientation
;;;302      lcd_set_orientation(LCD_ORIENTATION_PORTRAIT);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       lcd_set_orientation
;;;303    
;;;304      // Fill black
;;;305      lcd_fill_RGB(0xff);
000024  e8bd4010          POP      {r4,lr}
000028  20ff              MOVS     r0,#0xff
00002a  f7ffbffe          B.W      lcd_fill_RGB
;;;306      
;;;307      // Initialise the touch screen (and calibrate if necessary)
;;;308      // tsInit();
;;;309    }
;;;310    
                          ENDP


                          AREA ||i.lcd_scroll||, CODE, READONLY, ALIGN=2

                  lcd_scroll PROC
;;;518    /**************************************************************************/
;;;519    void lcd_scroll(int16_t pixels, uint16_t fillColor)
000000  b510              PUSH     {r4,lr}
;;;520    {
;;;521      int16_t y = pixels;
000002  4604              MOV      r4,r0
000004  e003              B        |L18.14|
000006  bf00              NOP                            ;520
                  |L18.8|
000008  f50474a0          ADD      r4,r4,#0x140          ;520
;;;522      while (y < 0)
;;;523        y += 320;
00000c  b224              SXTH     r4,r4
                  |L18.14|
00000e  2c00              CMP      r4,#0                 ;522
000010  dbfa              BLT      |L18.8|
;;;524      while (y >= 320)
000012  f44f70a0          MOV      r0,#0x140
                  |L18.22|
000016  4284              CMP      r4,r0
000018  db03              BLT      |L18.34|
00001a  f5a474a0          SUB      r4,r4,#0x140
;;;525        y -= 320;
00001e  b224              SXTH     r4,r4
000020  e7f9              B        |L18.22|
                  |L18.34|
;;;526    
;;;527      ili9328_write_command (CMD_VERTICALSCROLLCONTROL);
000022  206a              MOVS     r0,#0x6a
000024  f7fffffe          BL       ili9328_write_command
;;;528      ili9328_write_data (y);
000028  b2a0              UXTH     r0,r4
00002a  e8bd4010          POP      {r4,lr}
00002e  f7ffbffe          B.W      ili9328_write_data
;;;529    }
;;;530    
                          ENDP


                          AREA ||i.lcd_set_orientation||, CODE, READONLY, ALIGN=2

                  lcd_set_orientation PROC
;;;323    /**************************************************************************/
;;;324    void lcd_set_orientation (int orientation)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  0004              MOVS     r4,r0
;;;326      uint16_t entryMode     = 0x1030;
000004  f2410130          MOV      r1,#0x1030
;;;327      uint16_t outputControl = 0x0100;
000008  f44f7580          MOV      r5,#0x100
00000c  d004              BEQ      |L19.24|
;;;328    
;;;329      switch (orientation)  {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L19.24|
;;;330        case LCD_ORIENTATION_PORTRAIT:
;;;331          entryMode = 0x1030;
;;;332          outputControl = 0x0100;
;;;333          break;
;;;334        case LCD_ORIENTATION_LANDSCAPE:
;;;335          entryMode = 0x1028;
000012  f2410128          MOV      r1,#0x1028
;;;336          outputControl = 0x0000;
000016  2500              MOVS     r5,#0
                  |L19.24|
;;;337          break;
;;;338      }
;;;339    
;;;340      ili9328_command(CMD_ENTRYMODE, entryMode);
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       ili9328_command
;;;341      ili9328_command(CMD_DRIVEROUTPUTCONTROL1, outputControl);
00001e  4629              MOV      r1,r5
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       ili9328_command
;;;342      oDev.orientation = orientation;
000026  4804              LDR      r0,|L19.56|
;;;343    
;;;344      ili9328_set_cursor(0, 0);
000028  2100              MOVS     r1,#0
00002a  6004              STR      r4,[r0,#0]  ; oDev
00002c  e8bd4070          POP      {r4-r6,lr}
000030  4608              MOV      r0,r1
000032  f7ffbffe          B.W      ili9328_set_cursor
;;;345    }
;;;346    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  oDev
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  oGPIO
                          DCD      0x00000000
                          DCD      0x40010c00
000008  0100              DCW      0x0100
00000a  0000              DCB      0x00,0x00
                          DCD      0x00000008
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x00000001
                          DCD      0x40010800
00001c  0800              DCW      0x0800
00001e  0000              DCB      0x00,0x00
                          DCD      0x00000004
000024  00000000          DCB      0x00,0x00,0x00,0x00
                  oProperty
000028  00f00140          DCW      0x00f0,0x0140
00002c  00000001          DCW      0x0000,0x0001
000030  0001              DCW      0x0001
