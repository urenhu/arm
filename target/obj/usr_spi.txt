; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usr_spi.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\usr_spi.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usr_spi.crf ..\usr_lib\usr_spi.c]
                          THUMB

                          AREA ||i.usrspi2_ReadByte3Wire||, CODE, READONLY, ALIGN=2

                  usrspi2_ReadByte3Wire PROC
;;;153    
;;;154    u8   usrspi2_ReadByte3Wire()
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156        u8     result;
;;;157        u8     retry=0;                 
;;;158    
;;;159        SPI_BiDirectionalLineConfig (SPI2, SPI_Direction_Rx);  // change data pin to input mode 
000002  4c0c              LDR      r4,|L1.52|
000004  f64b71ff          MOV      r1,#0xbfff
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_BiDirectionalLineConfig
;;;160        SPI_I2S_SendData(SPI2, 0x00); // shift dumy to generate SPI clock   
00000e  2100              MOVS     r1,#0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI_I2S_SendData
;;;161        retry = 0;
;;;162        while (!(SPI2->SR & SPI_I2S_FLAG_RXNE)) {  // wait data received
000016  4807              LDR      r0,|L1.52|
000018  3008              ADDS     r0,r0,#8
                  |L1.26|
00001a  8801              LDRH     r1,[r0,#0]
00001c  07c9              LSLS     r1,r1,#31
00001e  d0fc              BEQ      |L1.26|
;;;163            retry++;
;;;164            //if (retry>200) 
;;;165    				//	break; // return 0;
;;;166        }
;;;167        SPI_BiDirectionalLineConfig(SPI2, SPI_Direction_Tx);// SPI1->CR1 |= SPI_Direction_Tx;  change data pin to output mode 
000020  f44f4180          MOV      r1,#0x4000
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       SPI_BiDirectionalLineConfig
;;;168    
;;;169        result = SPI_I2S_ReceiveData(SPI2);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SPI_I2S_ReceiveData
000030  b2c0              UXTB     r0,r0
;;;170    
;;;171        return result;
;;;172    }
000032  bd10              POP      {r4,pc}
;;;173    
                          ENDP

                  |L1.52|
                          DCD      0x40003800

                          AREA ||i.usrspi2_SendByte3Wire||, CODE, READONLY, ALIGN=2

                  usrspi2_SendByte3Wire PROC
;;;131    // ====================================================================
;;;132    void usrspi2_SendByte3Wire(u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
;;;134        u8 retry=0;                 
;;;135    
;;;136        retry=0;
;;;137        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET) { // wait tx buffer empty!
000002  4c09              LDR      r4,|L2.40|
000004  4605              MOV      r5,r0                 ;133
                  |L2.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;138            retry++;
;;;139            //if (retry>200)return ;
;;;140        }
;;;141    
;;;142        SPI_I2S_SendData(SPI2, data); 
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_I2S_SendData
                  |L2.26|
;;;143    
;;;144        retry=0;
;;;145        //while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) { 3-w mode, this one doesnt work
;;;146        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_BSY) == SET) { // wait finish sending 
00001a  2180              MOVS     r1,#0x80
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2801              CMP      r0,#1
000024  d0f9              BEQ      |L2.26|
;;;147            retry++;
;;;148            //if (retry>200)return ;
;;;149        }                             
;;;150        // SPI_I2S_ReceiveData(SPI2); // not for 3 wire mode                   
;;;151    }
000026  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

                  |L2.40|
                          DCD      0x40003800

                          AREA ||i.usrspi2_WriteReadAByte||, CODE, READONLY, ALIGN=2

                  usrspi2_WriteReadAByte PROC
;;;107    // for write data, call twice as well : address | data 
;;;108    u8 usrspi2_WriteReadAByte (u8 TxData)
000000  b570              PUSH     {r4-r6,lr}
;;;109    {       
;;;110        u8 retry=0;                 
;;;111    
;;;112        retry=0;
;;;113        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET) { // wait tx buffer empty
000002  4c0b              LDR      r4,|L3.48|
000004  4605              MOV      r5,r0                 ;109
                  |L3.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L3.6|
;;;114            retry++;
;;;115            //if (retry>200)return 0;
;;;116        }             
;;;117    
;;;118        SPI_I2S_SendData(SPI2, TxData);  // shift 1 byte out: clk, mosi
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_I2S_SendData
                  |L3.26|
;;;119    
;;;120        retry=0;
;;;121        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET) {
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L3.26|
;;;122            retry++;
;;;123            //if (retry>200)return 0;
;;;124        }                    
;;;125    	
;;;126        return SPI_I2S_ReceiveData(SPI2);                   
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c0              UXTB     r0,r0
;;;127    }
00002e  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP

                  |L3.48|
                          DCD      0x40003800

                          AREA ||i.usrspi2_init||, CODE, READONLY, ALIGN=2

                  usrspi2_init PROC
;;;19     ***********************************************************/
;;;20     void usrspi2_init ( int threewire, int lsbfirst, int spimode )
000000  b5f0              PUSH     {r4-r7,lr}
;;;21     {
000002  b087              SUB      sp,sp,#0x1c
000004  4616              MOV      r6,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d002              BEQ      |L4.18|
;;;22         GPIO_InitTypeDef   GPIO_InitStructure;
;;;23         SPI_InitTypeDef     SPI_InitStructure;
;;;24     
;;;25     	  // GPIO : enable SCK MOSI MISO and NSS GPIO clocks using =======
;;;26     		if ( threewire ) {
;;;27     			GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_15;
00000c  f44f4020          MOV      r0,#0xa000
000010  e001              B        |L4.22|
                  |L4.18|
;;;28     	  } else {
;;;29         	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13 |GPIO_Pin_14 | GPIO_Pin_15;
000012  f44f4060          MOV      r0,#0xe000
                  |L4.22|
000016  f8ad0014          STRH     r0,[sp,#0x14]
;;;30     	  }
;;;31     		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;  // push pull  AF: a;ternate Function
00001a  2518              MOVS     r5,#0x18
00001c  f88d5017          STRB     r5,[sp,#0x17]
;;;32         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0016          STRB     r0,[sp,#0x16]
;;;33         GPIO_Init(GPIOB, &GPIO_InitStructure);
000026  a905              ADD      r1,sp,#0x14
000028  4823              LDR      r0,|L4.184|
00002a  f7fffffe          BL       GPIO_Init
;;;34         if ( threewire ) {
;;;35         //  GPIO_ResetBits(GPIOB,GPIO_Pin_13|GPIO_Pin_15); // for mode 0  
;;;36     		} else {
;;;37     		//  GPIO_ResetBits(GPIOB,GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15); // for mode 0  
;;;38     		}
;;;39     		
;;;40         RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB, ENABLE );
00002e  2101              MOVS     r1,#1
000030  2008              MOVS     r0,#8
000032  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;41         //RCC_APB2PeriphClockCmd( RCC_APB2Periph_SPI1,  ENABLE ); 
;;;42         RCC_APB1PeriphClockCmd( RCC_APB1Periph_SPI2,  ENABLE );
000036  2101              MOVS     r1,#1
000038  0388              LSLS     r0,r1,#14
00003a  f7fffffe          BL       RCC_APB1PeriphClockCmd
00003e  2000              MOVS     r0,#0
;;;43     	  //RCC_APB1PeriphResetCmd( RCC_APB1Periph_SPI3,  ENABLE ); 
;;;44     
;;;45         if ( threewire ) {
000040  b11c              CBZ      r4,|L4.74|
;;;46             SPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx; // Initially Tx
000042  02e9              LSLS     r1,r5,#11
000044  f8ad1000          STRH     r1,[sp,#0]
000048  e001              B        |L4.78|
                  |L4.74|
;;;47         } else {
;;;48             SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
00004a  f8ad0000          STRH     r0,[sp,#0]
                  |L4.78|
;;;49         }
;;;50         SPI_InitStructure.SPI_Mode = SPI_Mode_Master;       
00004e  f44f7182          MOV      r1,#0x104
000052  f8ad1002          STRH     r1,[sp,#2]
000056  2101              MOVS     r1,#1                 ;40
;;;51         SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;       
000058  f8ad0004          STRH     r0,[sp,#4]
;;;52     
;;;53         switch (spimode) {
00005c  2e01              CMP      r6,#1
00005e  d007              BEQ      |L4.112|
000060  2202              MOVS     r2,#2                 ;21
000062  2e02              CMP      r6,#2
000064  d007              BEQ      |L4.118|
000066  2e03              CMP      r6,#3
000068  d00a              BEQ      |L4.128|
;;;54         case 0:
;;;55         default:
;;;56     			  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;     
00006a  f8ad0006          STRH     r0,[sp,#6]
;;;57             SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;      
;;;58             break;
00006e  e004              B        |L4.122|
                  |L4.112|
;;;59         case 1:
;;;60             SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;  //   
000070  f8ad0006          STRH     r0,[sp,#6]
;;;61             SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; //    
;;;62             break;
000074  e006              B        |L4.132|
                  |L4.118|
;;;63         case 2:
;;;64             SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;   //    
000076  f8ad2006          STRH     r2,[sp,#6]
                  |L4.122|
00007a  f8ad0008          STRH     r0,[sp,#8]            ;57
00007e  e003              B        |L4.136|
                  |L4.128|
;;;65             SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; //    
;;;66             break;
;;;67         case 3:
;;;68             SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;  // 1   
000080  f8ad2006          STRH     r2,[sp,#6]
                  |L4.132|
000084  f8ad1008          STRH     r1,[sp,#8]            ;61
                  |L4.136|
;;;69             SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge; // 1 mode 3   
;;;70             break;
;;;71         }
;;;72     
;;;73         SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;   
000088  f44f7100          MOV      r1,#0x200
00008c  f8ad100a          STRH     r1,[sp,#0xa]
;;;74         SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;    
000090  f8ad500c          STRH     r5,[sp,#0xc]
;;;75         if ( lsbfirst ) {
000094  b107              CBZ      r7,|L4.152|
;;;76             SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_LSB;
000096  2080              MOVS     r0,#0x80
                  |L4.152|
;;;77         } else {
;;;78             SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;  
000098  f8ad000e          STRH     r0,[sp,#0xe]
;;;79         }
;;;80         SPI_InitStructure.SPI_CRCPolynomial = 7;    
00009c  2007              MOVS     r0,#7
;;;81         SPI_Init(SPI2, &SPI_InitStructure);  
00009e  4c07              LDR      r4,|L4.188|
0000a0  f8ad0010          STRH     r0,[sp,#0x10]         ;80
0000a4  4669              MOV      r1,sp
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       SPI_Init
;;;82         
;;;83     		// SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, ENABLE );
;;;84     		// SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, ENABLE );
;;;85         
;;;86         SPI_Cmd(SPI2, ENABLE);
0000ac  2101              MOVS     r1,#1
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       SPI_Cmd
;;;87     }   
0000b4  b007              ADD      sp,sp,#0x1c
0000b6  bdf0              POP      {r4-r7,pc}
;;;88     
                          ENDP

                  |L4.184|
                          DCD      0x40010c00
                  |L4.188|
                          DCD      0x40003800

                          AREA ||i.usrspi2_setspeed||, CODE, READONLY, ALIGN=2

                  usrspi2_setspeed PROC
;;;93     //SPI_BaudRatePrescaler_256 256 
;;;94     void usrspi2_setspeed(u8 SPI_BaudRatePrescaler) 
000000  4601              MOV      r1,r0
;;;95     {
;;;96         assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_BaudRatePrescaler));
;;;97         SPI2->CR1&=0XFFC7;
000002  4805              LDR      r0,|L5.24|
000004  8802              LDRH     r2,[r0,#0]
000006  f0220238          BIC      r2,r2,#0x38
00000a  8002              STRH     r2,[r0,#0]
;;;98         SPI2->CR1|=SPI_BaudRatePrescaler;   
00000c  8802              LDRH     r2,[r0,#0]
00000e  430a              ORRS     r2,r2,r1
000010  8002              STRH     r2,[r0,#0]
;;;99         SPI_Cmd(SPI2,ENABLE); 
000012  2101              MOVS     r1,#1
000014  f7ffbffe          B.W      SPI_Cmd
;;;100    } 
;;;101    
                          ENDP

                  |L5.24|
                          DCD      0x40003800
