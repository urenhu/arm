L 1 "..\free_rtos\queue.c"
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060002
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 76 "..\free_rtos\queue.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060002
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 77 "..\free_rtos\queue.c" 2
N
N/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
Nall the API functions to use the MPU wrappers.  That should only be done when
Ntask.h is included from an application file. */
N#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
N
N#include "FreeRTOS.h"
L 1 "..\free_rtos\FreeRTOS.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems, who sell the code with commercial support,
N    indemnification and middleware, under the OpenRTOS brand.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N*/
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060002
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 83 "..\free_rtos\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 "..\free_rtos\projdefs.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/* Defines the prototype to which task functions must conform. */
Ntypedef void (*pdTASK_CODE)( void * );
N
N#define pdTRUE		( 1 )
N#define pdFALSE		( 0 )
N
N#define pdPASS									( 1 )
N#define pdFAIL									( 0 )
N#define errQUEUE_EMPTY							( 0 )
N#define errQUEUE_FULL							( 0 )
N
N/* Error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errNO_TASK_TO_RUN						( -2 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N#endif /* PROJDEFS_H */
N
N
N
L 86 "..\free_rtos\FreeRTOS.h" 2
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 "..\free_rtos\FreeRTOSConfig.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N#define configUSE_PREEMPTION		1
N#define configUSE_IDLE_HOOK			0
N#define configUSE_TICK_HOOK			0
N#define configCPU_CLOCK_HZ			( ( unsigned long ) 72000000 )	
N#define configTICK_RATE_HZ			( ( portTickType ) 1000 )
N#define configMAX_PRIORITIES		( ( unsigned portBASE_TYPE ) 5 )
N#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )
N#define configTOTAL_HEAP_SIZE		( ( size_t ) ( 17 * 1024 ) )
N#define configMAX_TASK_NAME_LEN		( 16 )
N#define configUSE_TRACE_FACILITY	0
N#define configUSE_16_BIT_TICKS		0
N#define configIDLE_SHOULD_YIELD		1
N
N/* Co-routine definitions. */
N#define configUSE_CO_ROUTINES 		0
N#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
N
N/* Set the following definitions to 1 to include the API function, or zero
Nto exclude the API function. */
N
N#define INCLUDE_vTaskPrioritySet		1
N#define INCLUDE_uxTaskPriorityGet		1
N#define INCLUDE_vTaskDelete				1
N#define INCLUDE_vTaskCleanUpResources	0
N#define INCLUDE_vTaskSuspend			1
N#define INCLUDE_vTaskDelayUntil			1
N#define INCLUDE_vTaskDelay				1
N
N/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
N(lowest) to 0 (1?) (highest). */
N#define configKERNEL_INTERRUPT_PRIORITY 		255
N/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
NSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	191 /* equivalent to 0xb0, or priority 11. */
N
N
N/* This is the value being used as per the ST library which permits 16
Npriority values, 0 to 15.  This must correspond to the
NconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
NNVIC value of 255. */
N#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY	15
N
N#endif /* FREERTOS_CONFIG_H */
N
L 89 "..\free_rtos\FreeRTOS.h" 2
N
N/* configUSE_PORT_OPTIMISED_TASK_SELECTION must be defined before portable.h
Nis included as it is used by the port layer. */
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
N	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 "..\free_rtos\portable.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Include the macro file relevant to the port being used. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "..\..\Source\portable\MPLAB\PIC18F\portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "..\..\Source\portable\MPLAB\PIC32MX\portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"	
N#endif
N	
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N	
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N	
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N	
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif	
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N	
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N	
N/* Catch all to ensure portmacro.h is included in the build.  Newer demos
Nhave the path as part of the project options, rather than as relative from
Nthe project location.  If portENTER_CRITICAL() has not been defined then
Nportmacro.h has not yet been included - as every portmacro.h provides a
NportENTER_CRITICAL() definition.  Check the demo application for your demo
Nto find the path to the correct portmacro.h file. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"	
L 1 "..\free_rtos\portmacro.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems, who sell the code with commercial support,
N    indemnification and middleware, under the OpenRTOS brand.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
N    engineered and independently SIL3 certified version for use in safety and
N    mission critical applications that require provable dependability.
N*/
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		     char
N#define portFLOAT		     float
N#define portDOUBLE		   double
N#define portLONG         long
N#define portSHORT	       short
N#define portSTACK_TYPE	 unsigned portLONG
N#define portBASE_TYPE	   long
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef unsigned portSHORT                portTickType;
S	#define portMAX_DELAY ( portTickType )    0xffff
N#else
N	typedef unsigned portLONG                 portTickType;
X	typedef unsigned long                 portTickType;
N	#define portMAX_DELAY ( portTickType )    0xffffffff
N#endif
N/*-----------------------------------------------------------*/
N/* Architecture specifics. */
N#define portSTACK_GROWTH			  ( -1 )
N#define portTICK_RATE_MS			  ( ( portTickType ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			 8
N/*-----------------------------------------------------------*/
N/* Scheduler utilities. */
Nextern void                        vPortYield( void );
N#define portNVIC_INT_CTRL_REG		   ( * ( ( volatile unsigned long * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		 ( 1UL << 28UL )
N#define portYIELD()					        vPortYield()
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
N/*-----------------------------------------------------------*/
N/* Critical section management. */
Nextern unsigned long   ulPortSetInterruptMask( void );
Nextern void            vPortClearInterruptMask( unsigned long ulNewMask );
Nextern void            vPortEnterCritical( void );
Nextern void            vPortExitCritical( void );
N
N#define portDISABLE_INTERRUPTS()				      ulPortSetInterruptMask()
N#define portENABLE_INTERRUPTS()					      vPortClearInterruptMask( 0 )
N#define portENTER_CRITICAL()					        vPortEnterCritical()
N#define portEXIT_CRITICAL()						        vPortExitCritical()
N#define portSET_INTERRUPT_MASK_FROM_ISR()		  ulPortSetInterruptMask()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortClearInterruptMask(x)
N/*-----------------------------------------------------------*/
N
N/* Tickless idle/low power functionality. */
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	extern void vPortSuppressTicksAndSleep( portTickType xExpectedIdleTime );
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdleTime )
N#endif
N/*-----------------------------------------------------------*/
N
N/* Port specific optimisations. */
N#if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
X#if 0 == 1
S	/* Check the configuration. */
S	#if( configMAX_PRIORITIES > 32 )
S		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32.  It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice.
S	#endif
S
S	/* Store/clear the ready priorities in a bit map. */
S	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities )        ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
S	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities )         ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )
S	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities )        uxTopPriority = ( 31 - __clz( ( uxReadyPriorities ) ) )
S
N#endif /* taskRECORD_READY_PRIORITY */
N/*-----------------------------------------------------------*/
N/* Task function macros as described on the FreeRTOS.org WEB site.  These are
N   not necessary for to use this port.  They are defined so the common demo files
N   (which build with all the ports) will build. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )  void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters )        void vFunction( void *pvParameters )
N
N/*-----------------------------------------------------------*/
N/* portNOP() is not required by this port. */
N#define portNOP()
N#ifdef __cplusplus
S}
N#endif
N#endif /* PORTMACRO_H */
N
L 329 "..\free_rtos\portable.h" 2
N#endif
N	
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 "..\free_rtos\mpu_wrappers.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		#define xTaskGenericCreate				MPU_xTaskGenericCreate
S		#define vTaskAllocateMPURegions			MPU_vTaskAllocateMPURegions
S		#define vTaskDelete						MPU_vTaskDelete
S		#define vTaskDelayUntil					MPU_vTaskDelayUntil
S		#define vTaskDelay						MPU_vTaskDelay
S		#define uxTaskPriorityGet				MPU_uxTaskPriorityGet
S		#define vTaskPrioritySet				MPU_vTaskPrioritySet
S		#define eTaskGetState					MPU_eTaskGetState
S		#define vTaskSuspend					MPU_vTaskSuspend
S		#define xTaskIsTaskSuspended			MPU_xTaskIsTaskSuspended
S		#define vTaskResume						MPU_vTaskResume
S		#define vTaskSuspendAll					MPU_vTaskSuspendAll
S		#define xTaskResumeAll					MPU_xTaskResumeAll
S		#define xTaskGetTickCount				MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks			MPU_uxTaskGetNumberOfTasks
S		#define vTaskList						MPU_vTaskList
S		#define vTaskGetRunTimeStats			MPU_vTaskGetRunTimeStats
S		#define vTaskSetApplicationTaskTag		MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag		MPU_xTaskGetApplicationTaskTag
S		#define xTaskCallApplicationTaskHook	MPU_xTaskCallApplicationTaskHook
S		#define uxTaskGetStackHighWaterMark		MPU_uxTaskGetStackHighWaterMark
S		#define xTaskGetCurrentTaskHandle		MPU_xTaskGetCurrentTaskHandle
S		#define xTaskGetSchedulerState			MPU_xTaskGetSchedulerState
S		#define xTaskGetIdleTaskHandle			MPU_xTaskGetIdleTaskHandle
S
S		#define xQueueGenericCreate				MPU_xQueueGenericCreate
S		#define xQueueCreateMutex				MPU_xQueueCreateMutex
S		#define xQueueGiveMutexRecursive		MPU_xQueueGiveMutexRecursive
S		#define xQueueTakeMutexRecursive		MPU_xQueueTakeMutexRecursive
S		#define xQueueCreateCountingSemaphore	MPU_xQueueCreateCountingSemaphore
S		#define xQueueGenericSend				MPU_xQueueGenericSend
S		#define xQueueAltGenericSend			MPU_xQueueAltGenericSend
S		#define xQueueAltGenericReceive			MPU_xQueueAltGenericReceive
S		#define xQueueGenericReceive			MPU_xQueueGenericReceive
S		#define uxQueueMessagesWaiting			MPU_uxQueueMessagesWaiting
S		#define vQueueDelete					MPU_vQueueDelete
S		#define xQueueGenericReset				MPU_xQueueGenericReset
S		#define xQueueCreateSet					MPU_xQueueCreateSet
S		#define xQueueSelectFromSet				MPU_xQueueSelectFromSet
S		#define xQueueAddToSet					MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet				MPU_xQueueRemoveFromSet
S
S		#define pvPortMalloc					MPU_pvPortMalloc
S		#define vPortFree						MPU_vPortFree
S		#define xPortGetFreeHeapSize			MPU_xPortGetFreeHeapSize
S		#define vPortInitialiseBlocks			MPU_vPortInitialiseBlocks
S
S		#if configQUEUE_REGISTRY_SIZE > 0
S			#define vQueueAddToRegistry				MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue			MPU_vQueueUnregisterQueue
S		#endif
S
S		/* Remove the privileged function macro. */
S		#define PRIVILEGED_FUNCTION
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S        //#define PRIVILEGED_DATA
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 360 "..\free_rtos\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters, portBASE_TYPE xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters );
X	unsigned long *pxPortInitialiseStack( unsigned long *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters );
N#endif
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NportBASE_TYPE xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
Xlong xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 ) 
X#if( 0 == 1 ) 
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, portSTACK_TYPE *pxBottomOfStack, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 98 "..\free_rtos\FreeRTOS.h" 2
N
N
N/* Defines the prototype to which the application task hook function must
Nconform. */
Ntypedef portBASE_TYPE (*pdTASK_HOOK_CODE)( void * );
Xtypedef long (*pdTASK_HOOK_CODE)( void * );
N
N
N
N
N
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
S	#error  Missing definition:  configUSE_CO_ROUTINES should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#error Missing definition:  INCLUDE_vTaskPrioritySet should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#error Missing definition:  INCLUDE_uxTaskPriorityGet should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#error Missing definition:  INCLUDE_vTaskDelete		 should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#error Missing definition:  INCLUDE_vTaskSuspend	 should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#error Missing definition:  INCLUDE_vTaskDelayUntil should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#error Missing definition:  INCLUDE_vTaskDelay should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS should be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTimerGetTimerDaemonTaskHandle
N	#define INCLUDE_xTimerGetTimerDaemonTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
N	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_pcTaskGetTaskName
N	#define INCLUDE_pcTaskGetTaskName 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
N	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
N	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
N	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
N	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
N	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
N	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
S	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if ( 16 ) < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N#endif
N
N#ifndef portALIGNMENT_ASSERT_pxCurrentTCB
N	#define portALIGNMENT_ASSERT_pxCurrentTCB configASSERT
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef INCLUDE_xTaskGetSchedulerState
N	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
N	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
N	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0U < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE unsigned long
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
N	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL()
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
N	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
N	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( unsigned portBASE_TYPE ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef pvPortMallocAligned
N	#define pvPortMallocAligned( x, puxStackBuffer ) ( ( ( puxStackBuffer ) == NULL ) ? ( pvPortMalloc( ( x ) ) ) : ( puxStackBuffer ) )
N#endif
N
N#ifndef vPortFreeAligned
N	#define vPortFreeAligned( pvBlockToFree ) vPortFree( pvBlockToFree )
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
S	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N/* For backward compatability. */
N#define eTaskStateGet eTaskGetState
N
N#endif /* INC_FREERTOS_H */
N
L 84 "..\free_rtos\queue.c" 2
N#include "task.h"
L 1 "..\free_rtos\task.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
N    Integrity Systems, who sell the code with commercial support,
N    indemnification and middleware, under the OpenRTOS brand.
N
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N
N#ifndef TASK_H
N#define TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "portable.h"
N#include "list.h"
L 1 "..\free_rtos\list.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * xLists can only store pointers to xListItems.  Each xListItem contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N
N#ifndef LIST_H
N#define LIST_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	portTickType xItemValue;				/*< The value being listed.  In most cases this is used to sort the list in descending order. */
N	volatile struct xLIST_ITEM * pxNext;	/*< Pointer to the next xListItem in the list. */
N	volatile struct xLIST_ITEM * pxPrevious;/*< Pointer to the previous xListItem in the list. */
N	void * pvOwner;							/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * pvContainer;						/*< Pointer to the list in which this list item is placed (if any). */
N};
Ntypedef struct xLIST_ITEM xListItem;		/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	portTickType xItemValue;
N	volatile struct xLIST_ITEM *pxNext;
N	volatile struct xLIST_ITEM *pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM xMiniListItem;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	volatile unsigned portBASE_TYPE uxNumberOfItems;
X	volatile unsigned long uxNumberOfItems;
N	volatile xListItem * pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to pvListGetOwnerOfNextEntry (). */
N	volatile xMiniListItem xListEnd;		/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N} xList;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( pxListItem )->pvOwner = ( void * ) ( pxOwner )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )		( pxListItem )->pvOwner
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )		( pxListItem )->xItemValue = ( xValue )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example a the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )				( ( pxListItem )->xItemValue )
N
N/*
N * Access macro the retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )			( (&( ( pxList )->xListEnd ))->pxNext->xItemValue )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )				( ( pxList )->uxNumberOfItems == ( unsigned portBASE_TYPE ) 0 )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )		( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entries pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )									\
N{																						\
NxList * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */			\
N	/* we don't return the marker used at the end of the list.  */						\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	if( ( pxConstList )->pxIndex == ( xListItem * ) &( ( pxConstList )->xListEnd ) )	\
N	{																					\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;					\
N	}																					\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;										\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )									{																						xList * const pxConstList = ( pxList );														 				 							( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							if( ( pxConstList )->pxIndex == ( xListItem * ) &( ( pxConstList )->xListEnd ) )		{																							( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						}																						( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;										}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE is the list item is in the list, otherwise pdFALSE.
N * pointer against
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the xList object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( xList *pxList );
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( xListItem *pxItem );
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item to that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( xList *pxList, xListItem *pxNewListItem );
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pvIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pvIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pvIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pvIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( xList *pxList, xListItem *pxNewListItem );
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N * 
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
Nunsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove );
Xunsigned long uxListRemove( xListItem *pxItemToRemove );
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 85 "..\free_rtos\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V7.4.2"
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an xTaskHandle variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \page xTaskHandle xTaskHandle
N * \ingroup Tasks
N */
Ntypedef void * xTaskHandle;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	portBASE_TYPE xOverflowCount;
X	long xOverflowCount;
N	portTickType  xTimeOnEntering;
N} xTimeOutType;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	unsigned long ulLengthInBytes;
N	unsigned long ulParameters;
N} xMemoryRegion;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMTERS
N{
N	pdTASK_CODE pvTaskCode;
N	const signed char * const pcName;
N	unsigned short usStackDepth;
N	void *pvParameters;
N	unsigned portBASE_TYPE uxPriority;
X	unsigned long uxPriority;
N	portSTACK_TYPE *puxStackBuffer;
X	unsigned long *puxStackBuffer;
N	xMemoryRegion xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	xMemoryRegion xRegions[ 1 ];
N} xTaskParameters;
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N} eTaskState;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N
N/*
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( unsigned portBASE_TYPE ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \page taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \page taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \page taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \page taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \page taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState(). */
N#define taskSCHEDULER_NOT_STARTED	0
N#define taskSCHEDULER_RUNNING		1
N#define taskSCHEDULER_SUSPENDED		2
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N portBASE_TYPE xTaskCreate(
N							  pdTASK_CODE pvTaskCode,
N							  const char * const pcName,
N							  unsigned short usStackDepth,
N							  void *pvParameters,
N							  unsigned portBASE_TYPE uxPriority,
N							  xTaskHandle *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by tskMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file errors. h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static unsigned char ucParameterToPass;
N xTaskHandle xHandle;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#define xTaskCreate( pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask ) xTaskGenericCreate( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( NULL ), ( NULL ) )
N
N/**
N * task. h
N *<pre>
N portBASE_TYPE xTaskCreateRestricted( xTaskParameters *pxTaskDefinition, xTaskHandle *pxCreatedTask );</pre>
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file errors. h
N *
N * Example usage:
N   <pre>
N// Create an xTaskParameters structure that defines the task to be created.
Nstatic const xTaskParameters xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NxTaskHandle xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#define xTaskCreateRestricted( x, pxCreatedTask ) xTaskGenericCreate( ((x)->pvTaskCode), ((x)->pcName), ((x)->usStackDepth), ((x)->pvParameters), ((x)->uxPriority), (pxCreatedTask), ((x)->puxStackBuffer), ((x)->xRegions) )
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an xMemoryRegion structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of xMemoryRegion structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const xMemoryRegion xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( xTaskHandle xTask, const xMemoryRegion * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( xTaskHandle xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernels management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( xTaskHandle xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( xTaskHandle xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( portTickType xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_RATE_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a cyclical task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const portTickType xDelay = 500 / portTICK_RATE_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( portTickType xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( portTickType xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( portTickType *pxPreviousWakeTime, portTickType xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by cyclical
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_RATE_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N portTickType xLastWakeTime;
N const portTickType xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask );</pre>
N *
N * INCLUDE_xTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
Nunsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskPriorityGet( xTaskHandle xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( xTaskHandle xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( xTaskHandle xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( xTaskHandle xTask, unsigned long uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( xTaskHandle xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( xTaskHandle xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( xTaskHandle xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( xTaskHandle xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one of more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N xTaskHandle xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with it priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( xTaskHandle xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( xTaskHandle xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( xTaskHandle xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one of more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NportBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume ) PRIVILEGED_FUNCTION;
Xlong xTaskResumeFromISR( xTaskHandle xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.  This function
N * does not return until an executing task calls vTaskEndScheduler ().
N *
N * At least one task should be created via a call to xTaskCreate ()
N * before calling vTaskStartScheduler ().  The idle task is created
N * automatically when the first application task is created.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends all real time kernel activity while keeping interrupts (including the
N * kernel tick) enabled.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>char xTaskResumeAll( void );</pre>
N *
N * Resumes real time kernel activity following a call to vTaskSuspendAll ().
N * After a call to vTaskSuspendAll () the kernel will take control of which
N * task is executing at any time.
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
Nsigned portBASE_TYPE xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
Xsigned long xTaskResumeAll( void ) ;
N
N/**
N * task. h
N * <pre>signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask );</pre>
N *
N * Utility task that simply returns pdTRUE if the task referenced by xTask is
N * currently in the Suspended state, or pdFALSE if the task referenced by xTask
N * is in any other state.
N *
N */
Nsigned portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xsigned long xTaskIsTaskSuspended( xTaskHandle xTask ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>portTickType xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \page xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NportTickType xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XportTickType xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>portTickType xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that portTickType is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \page xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NportTickType xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XportTickType xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>unsigned short uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \page uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
Nunsigned portBASE_TYPE uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQueury.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be
N * set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available.
N *
N * \page pcTaskGetTaskName pcTaskGetTaskName
N * \ingroup TaskUtils
N */
Nsigned char *pcTaskGetTaskName( xTaskHandle xTaskToQuery );
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * NOTE: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ascii form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \page vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( signed char *pcWriteBuffer ) PRIVILEGED_FUNCTION;
Xvoid vTaskList( signed char *pcWriteBuffer ) ;
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS must be defined as 1 for this function
N * to be available.  The application must also then provide definitions
N * for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and
N * portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter
N * and return the timers current count value respectively.  The counter
N * should be at least 10 times the frequency of the tick count.
N *
N * NOTE: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ascii form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \page vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( signed char *pcWriteBuffer ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetRunTimeStats( signed char *pcWriteBuffer ) ;
N
N/**
N * task.h
N * <PRE>unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in bytes)
N * since the task referenced by xTask was created.
N */
Nunsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
Xunsigned long uxTaskGetStackHighWaterMark( xTaskHandle xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include tasks.h before
NFreeRTOS.h.  When this is done pdTASK_HOOK_CODE will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( xTaskHandle xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N/**
N * task.h
N * <pre>portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.
N */
NportBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
Xlong xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NxTaskHandle xTaskGetIdleTaskHandle( void );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.
N */
Nvoid vTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_RATE_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
Nvoid vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList () will be called if either an event occurs to
N * unblock a task, or the block timeout period expires.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
Nsigned portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList ) PRIVILEGED_FUNCTION;
Xsigned long xTaskRemoveFromEventList( const xList * const pxEventList ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NxTaskHandle xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XxTaskHandle xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( xTimeOutType * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( xTimeOutType * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NportBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait ) PRIVILEGED_FUNCTION;
Xlong xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NportBASE_TYPE xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
Xlong xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
Nvoid vTaskPriorityInherit( xTaskHandle * const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityInherit( xTaskHandle * const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
Nvoid vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder ) ;
N
N/*
N * Generic version of the task creation function which is in turn called by the
N * xTaskCreate() and xTaskCreateRestricted() macros.
N */
Nsigned portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions ) PRIVILEGED_FUNCTION;
Xsigned long xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned long uxPriority, xTaskHandle *pxCreatedTask, unsigned long *puxStackBuffer, const xMemoryRegion * const xRegions ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
Nunsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask );
Xunsigned long uxTaskGetTaskNumber( xTaskHandle xTask );
N
N/*
N * Set the uxTCBNumber of the task referenced by the xTask parameter to
N * ucHandle.
N */
Nvoid vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle );
Xvoid vTaskSetTaskNumber( xTaskHandle xTask, unsigned long uxHandle );
N
N/*
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by the by
N * a time equal to the idle period.
N */
Nvoid vTaskStepTick( portTickType xTicksToJump );
N
N/*
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void );
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* TASK_H */
N
N
N
L 85 "..\free_rtos\queue.c" 2
N#include "queue.h"
L 1 "..\free_rtos\queue.h" 1
N/*
N    FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
N
N    FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
N    http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
N
N    ***************************************************************************
N     *                                                                       *
N     *    FreeRTOS tutorial books are available in pdf and paperback.        *
N     *    Complete, revised, and edited pdf reference manuals are also       *
N     *    available.                                                         *
N     *                                                                       *
N     *    Purchasing FreeRTOS documentation will not only help you, by       *
N     *    ensuring you get running as quickly as possible and with an        *
N     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
N     *    the FreeRTOS project to continue with its mission of providing     *
N     *    professional grade, cross platform, de facto standard solutions    *
N     *    for microcontrollers - completely free of charge!                  *
N     *                                                                       *
N     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
N     *                                                                       *
N     *    Thank you for using FreeRTOS, and thank you for your support!      *
N     *                                                                       *
N    ***************************************************************************
N
N
N    This file is part of the FreeRTOS distribution.
N
N    FreeRTOS is free software; you can redistribute it and/or modify it under
N    the terms of the GNU General Public License (version 2) as published by the
N    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
N
N    >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
N    distribute a combined work that includes FreeRTOS without being obliged to
N    provide the source code for proprietary components outside of the FreeRTOS
N    kernel.
N
N    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
N    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
N    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
N    details. You should have received a copy of the GNU General Public License
N    and the FreeRTOS license exception along with FreeRTOS; if not it can be
N    viewed here: http://www.freertos.org/a00114.html and also obtained by
N    writing to Real Time Engineers Ltd., contact details for whom are available
N    on the FreeRTOS WEB site.
N
N    1 tab == 4 spaces!
N
N    ***************************************************************************
N     *                                                                       *
N     *    Having a problem?  Start by reading the FAQ "My application does   *
N     *    not run, what could be wrong?"                                     *
N     *                                                                       *
N     *    http://www.FreeRTOS.org/FAQHelp.html                               *
N     *                                                                       *
N    ***************************************************************************
N
N
N    http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
N    license and Real Time Engineers Ltd. contact details.
N
N    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
N    including FreeRTOS+Trace - an indispensable productivity tool, and our new
N    fully thread aware and reentrant UDP/IP stack.
N
N    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
N    Integrity Systems, who sell the code with commercial support, 
N    indemnification and middleware, under the OpenRTOS brand.
N    
N    http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
N    engineered and independently SIL3 certified version for use in safety and 
N    mission critical applications that require provable dependability.
N*/
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N#include "mpu_wrappers.h"
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an xQueueHandle variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * xQueueHandle;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * xQueueSetHandle;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * xQueueSetMemberHandle is defined as a type to be used where a parameter or
N * return value can be either an xQueueHandle or an xSemaphoreHandle.
N */
Ntypedef void * xQueueSetMemberHandle;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK	( 0 )
N#define	queueSEND_TO_FRONT	( 1 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( 0U )
N#define queueQUEUE_TYPE_SET					( 0U )
N#define queueQUEUE_TYPE_MUTEX 				( 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
N
N/**
N * queue. h
N * <pre>
N xQueueHandle xQueueCreate(
N							  unsigned portBASE_TYPE uxQueueLength,
N							  unsigned portBASE_TYPE uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance.  This allocates the storage required by the
N * new queue and returns a handle for the queue.
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N xQueueHandle xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 unsigned long values.
N	xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( uxQueueLength, uxItemSize, queueQUEUE_TYPE_BASE )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSendToToFront(
N								   xQueueHandle	xQueue,
N								   const void	*	pvItemToQueue,
N								   portTickType	xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N unsigned long ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N xQueueHandle xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 unsigned long values.
N	xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an unsigned long.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSendToBack(
N								   xQueueHandle	xQueue,
N								   const	void	*	pvItemToQueue,
N								   portTickType	xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N unsigned long ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N xQueueHandle xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 unsigned long values.
N	xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an unsigned long.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSend(
N							  xQueueHandle xQueue,
N							  const void * pvItemToQueue,
N							  portTickType xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N unsigned long ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N xQueueHandle xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 unsigned long values.
N	xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an unsigned long.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( portTickType ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueGenericSend(
N									xQueueHandle xQueue,
N									const void * pvItemToQueue,
N									portTickType xTicksToWait
N									portBASE_TYPE xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N unsigned long ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N xQueueHandle xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 unsigned long values.
N	xQueue1 = xQueueCreate( 10, sizeof( unsigned long ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an unsigned long.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( portTickType ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( portTickType ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
Nsigned portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition );
Xsigned long xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, long xCopyPosition );
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueuePeek(
N							 xQueueHandle xQueue,
N							 void *pvBuffer,
N							 portTickType xTicksToWait
N						 );</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N xQueueHandle xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueReceive(
N								 xQueueHandle xQueue,
N								 void *pvBuffer,
N								 portTickType xTicksToWait
N							);</pre>
N *
N * This is a macro that calls the xQueueGenericReceive() function.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_RATE_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N xQueueHandle xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
N#define xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueGenericReceive(
N									   xQueueHandle	xQueue,
N									   void	*pvBuffer,
N									   portTickType	xTicksToWait
N									   portBASE_TYPE	xJustPeek
N									);</pre>
N *
N * It is preferred that the macro xQueueReceive() be used rather than calling
N * this function directly.
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_RATE_MS should be used to convert to real time if this is required.
N * xQueueGenericReceive() will return immediately if the queue is empty and
N * xTicksToWait is 0.
N *
N * @param xJustPeek When set to true, the item received from the queue is not
N * actually removed from the queue - meaning a subsequent call to
N * xQueueReceive() will return the same item.  When set to false, the item
N * being received from the queue is also removed from the queue.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N xQueueHandle xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
Nsigned portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeek );
Xsigned long xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, long xJustPeek );
N
N/**
N * queue. h
N * <pre>unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \page uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
Nunsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue );
Xunsigned long uxQueueMessagesWaiting( const xQueueHandle xQueue );
N
N/**
N * queue. h
N * <pre>void vQueueDelete( xQueueHandle xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \page vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( xQueueHandle xQueue );
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSendToFrontFromISR(
N										 xQueueHandle xQueue,
N										 const void *pvItemToQueue,
N										 portBASE_TYPE *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N portBASE_TYPE xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSendToBackFromISR(
N										 xQueueHandle xQueue,
N										 const void *pvItemToQueue,
N										 portBASE_TYPE *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N portBASE_TYPE xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueSendFromISR(
N									 xQueueHandle xQueue,
N									 const void *pvItemToQueue,
N									 portBASE_TYPE *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N portBASE_TYPE xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		taskYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueGenericSendFromISR(
N										   xQueueHandle		xQueue,
N										   const	void	*pvItemToQueue,
N										   portBASE_TYPE	*pxHigherPriorityTaskWoken,
N										   portBASE_TYPE	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N portBASE_TYPE xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
Nsigned portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition );
Xsigned long xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed long *pxHigherPriorityTaskWoken, long xCopyPosition );
N
N/**
N * queue. h
N * <pre>
N portBASE_TYPE xQueueReceiveFromISR(
N									   xQueueHandle	xQueue,
N									   void	*pvBuffer,
N									   portBASE_TYPE *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N xQueueHandle xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const portTickType xBlockTime = ( portTickType )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xBlockTime ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xBlockTime );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N portBASE_TYPE xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
Nsigned portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken );
Xsigned long xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed long *pxHigherPriorityTaskWoken );
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
Nsigned portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue );
Xsigned long xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue );
Nsigned portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue );
Xsigned long xQueueIsQueueFullFromISR( const xQueueHandle xQueue );
Nunsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue );
Xunsigned long uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue );
N
N
N/*
N * xQueueAltGenericSend() is an alternative version of xQueueGenericSend().
N * Likewise xQueueAltGenericReceive() is an alternative version of
N * xQueueGenericReceive().
N *
N * The source code that implements the alternative (Alt) API is much
N * simpler	because it executes everything from within a critical section.
N * This is	the approach taken by many other RTOSes, but FreeRTOS.org has the
N * preferred fully featured API too.  The fully featured API has more
N * complex	code that takes longer to execute, but makes much less use of
N * critical sections.  Therefore the alternative API sacrifices interrupt
N * responsiveness to gain execution speed, whereas the fully featured API
N * sacrifices execution speed to ensure better interrupt responsiveness.
N */
Nsigned portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition );
Xsigned long xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, long xCopyPosition );
Nsigned portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking );
Xsigned long xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, long xJustPeeking );
N#define xQueueAltSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N#define xQueueAltSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueAltGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N#define xQueueAltReceive( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
N#define xQueueAltPeek( xQueue, pvBuffer, xTicksToWait ) xQueueAltGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
Nsigned portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken );
Xsigned long xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed long xCoRoutinePreviouslyWoken );
Nsigned portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxTaskWoken );
Xsigned long xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed long *pxTaskWoken );
Nsigned portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait );
Xsigned long xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait );
Nsigned portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait );
Xsigned long xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NxQueueHandle xQueueCreateMutex( unsigned char ucQueueType );
NxQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount );
XxQueueHandle xQueueCreateCountingSemaphore( unsigned long uxCountValue, unsigned long uxInitialCount );
Nvoid* xQueueGetMutexHolder( xQueueHandle xSemaphore );
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NportBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime );
Xlong xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime );
NportBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex );
Xlong xQueueGiveMutexRecursive( xQueueHandle pxMutex );
N
N/*
N * Reset a queue back to its original empty state.  pdPASS is returned if the
N * queue is successfully reset.  pdFAIL is returned if the queue could not be
N * reset because there are tasks blocked on the queue waiting to either
N * receive from the queue or send to the queue.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.
N */
N#if configQUEUE_REGISTRY_SIZE > 0U
X#if 0U > 0U
S	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcName );
N#endif
N
N/*
N * Generic version of the queue creation function, which is in turn called by
N * any queue, semaphore or mutex creation function or macro.
N */
NxQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType );
XxQueueHandle xQueueGenericCreate( unsigned long uxQueueLength, unsigned long uxItemSize, unsigned char ucQueueType );
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are 
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NxQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength );
XxQueueSetHandle xQueueCreateSet( unsigned long uxEventQueueLength );
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an xQueueSetMemberHandle type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NportBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet );
Xlong xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet );
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only 
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an xQueueSetMemberHandle type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NportBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet );
Xlong xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet );
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are 
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xBlockTimeTicks The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a xQueueSetMemberHandle type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a xQueueSetMemberHandle type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NxQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks );
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NxQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet );
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait );
NportBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue );
Xlong xQueueGenericReset( xQueueHandle xQueue, long xNewQueue );
Nvoid vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber ) ;
Nunsigned char ucQueueGetQueueType( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
Xunsigned char ucQueueGetQueueType( xQueueHandle xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 86 "..\free_rtos\queue.c" 2
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S	#include "croutine.h"
N#endif
N
N#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
N
N/* Constants used with the cRxLock and xTxLock structure members. */
N#define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
N#define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
N
N#define queueERRONEOUS_UNBLOCK			( -1 )
N
N/* Effectively make a union out of the xQUEUE structure. */
N#define pxMutexHolder					pcTail
N#define uxQueueType						pcHead
N#define uxRecursiveCallCount			pcReadFrom
N#define queueQUEUE_IS_MUTEX				NULL
N
N/* Semaphores do not actually store or copy data, so have an items size of
Nzero. */
N#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
N#define queueDONT_BLOCK					 ( ( portTickType ) 0U )
N#define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
N
N
N/*
N * Definition of the queue used by the scheduler.
N * Items are queued by copy, not reference.
N */
Ntypedef struct QueueDefinition
N{
N	signed char *pcHead;					/*< Points to the beginning of the queue storage area. */
N	signed char *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
N
N	signed char *pcWriteTo;					/*< Points to the free next place in the storage area. */
N	signed char *pcReadFrom;				/*< Points to the last place that a queued item was read from. */
N
N	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
N	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
N
N	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. */
X	volatile unsigned long uxMessagesWaiting; 
N	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
X	unsigned long uxLength;		 
N	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
X	unsigned long uxItemSize;		 
N
N	volatile signed portBASE_TYPE xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
X	volatile signed long xRxLock;	 
N	volatile signed portBASE_TYPE xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
X	volatile signed long xTxLock;	 
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		unsigned char ucQueueNumber;
S		unsigned char ucQueueType;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		struct QueueDefinition *pxQueueSetContainer;
N	#endif
N
N} xQUEUE;
N/*-----------------------------------------------------------*/
N
N/*
N * The queue registry is just a means for kernel aware debuggers to locate
N * queue structures.  It has no other purpose so is an optional component.
N */
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0U > 0 )
S
S	/* The type stored within the queue registry array.  This allows a name
S	to be assigned to each queue making kernel aware debugging a little
S	more user friendly. */
S	typedef struct QUEUE_REGISTRY_ITEM
S	{
S		signed char *pcQueueName;
S		xQueueHandle xHandle;
S	} xQueueRegistryItem;
S
S	/* The queue registry is simply an array of xQueueRegistryItem structures.
S	The pcQueueName member of a structure being NULL is indicative of the
S	array position being vacant. */
S	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
S
S	/* Removes a queue from the registry by simply setting the pcQueueName
S	member to NULL. */
S	static void prvQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N
N/*
N * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
N * prevent an ISR from adding or removing items to the queue, but does prevent
N * an ISR from removing tasks from the queue event lists.  If an ISR finds a
N * queue is locked it will instead increment the appropriate queue lock count
N * to indicate that a task may require unblocking.  When the queue in unlocked
N * these lock counts are inspected, and the appropriate action taken.
N */
Nstatic void prvUnlockQueue( xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
Xstatic void prvUnlockQueue( xQUEUE *pxQueue ) ;
N
N/*
N * Uses a critical section to determine if there is any data in a queue.
N *
N * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
N */
Nstatic signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
Xstatic signed long prvIsQueueEmpty( const xQUEUE *pxQueue ) ;
N
N/*
N * Uses a critical section to determine if there is any space in a queue.
N *
N * @return pdTRUE if there is no space, otherwise pdFALSE;
N */
Nstatic signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue ) PRIVILEGED_FUNCTION;
Xstatic signed long prvIsQueueFull( const xQUEUE *pxQueue ) ;
N
N/*
N * Copies an item into the queue, either at the front of the queue or the
N * back of the queue.
N */
Nstatic void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition ) PRIVILEGED_FUNCTION;
Xstatic void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, long xPosition ) ;
N
N/*
N * Copies an item out of a queue.
N */
Nstatic void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTION;
Xstatic void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) ;
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S	/*
S	 * Checks to see if a queue is a member of a queue set, and if so, notifies
S	 * the queue set that the queue contains data.
S	 */
S	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition );
N#endif
N
N/*-----------------------------------------------------------*/
N
N/*
N * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
N * accessing the queue event lists.
N */
N#define prvLockQueue( pxQueue )								\
N	taskENTER_CRITICAL();									\
N	{														\
N		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
N		{													\
N			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
N		}													\
N		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
N		{													\
N			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
N		}													\
N	}														\
N	taskEXIT_CRITICAL()
X#define prvLockQueue( pxQueue )									taskENTER_CRITICAL();										{																if( ( pxQueue )->xRxLock == queueUNLOCKED )					{																( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;			}															if( ( pxQueue )->xTxLock == queueUNLOCKED )					{																( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;			}														}															taskEXIT_CRITICAL()
N/*-----------------------------------------------------------*/
N
NportBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
Xlong xQueueGenericReset( xQueueHandle xQueue, long xNewQueue )
N{
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
N		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
X		pxQueue->uxMessagesWaiting = ( unsigned long ) 0U;
N		pxQueue->pcWriteTo = pxQueue->pcHead;
N		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
X		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned long ) 1U ) * pxQueue->uxItemSize );
N		pxQueue->xRxLock = queueUNLOCKED;
X		pxQueue->xRxLock = ( ( signed long ) -1 );
N		pxQueue->xTxLock = queueUNLOCKED;
X		pxQueue->xTxLock = ( ( signed long ) -1 );
N
N		if( xNewQueue == pdFALSE )
X		if( xNewQueue == ( 0 ) )
N		{
N			/* If there are tasks blocked waiting to read from the queue, then
N			the tasks will remain blocked as after this function exits the queue
N			will still be empty.  If there are tasks blocked waiting to	write to
N			the queue, then one should be unblocked as after this function exits
N			it will be possible to write to it. */
N			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X			if( ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N			{
N				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
X				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == ( 1 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N			}
N		}
N		else
N		{
N			/* Ensure the event queues start in the correct state. */
N			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
N			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	/* A value is returned for calling semantic consistency with previous
N	versions. */
N	return pdPASS;
X	return ( 1 );
N}
N/*-----------------------------------------------------------*/
N
NxQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
XxQueueHandle xQueueGenericCreate( unsigned long uxQueueLength, unsigned long uxItemSize, unsigned char ucQueueType )
N{
NxQUEUE *pxNewQueue;
Nsize_t xQueueSizeInBytes;
NxQueueHandle xReturn = NULL;
XxQueueHandle xReturn = 0;
N
N	/* Remove compiler warnings about unused parameters should
N	configUSE_TRACE_FACILITY not be set to 1. */
N	( void ) ucQueueType;
N
N	/* Allocate the new queue structure. */
N	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
X	if( uxQueueLength > ( unsigned long ) 0 )
N	{
N		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
N		if( pxNewQueue != NULL )
X		if( pxNewQueue != 0 )
N		{
N			/* Create the list of pointers to queue items.  The queue is one byte
N			longer than asked for to make wrap checking easier/faster. */
N			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
N
N			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
N			if( pxNewQueue->pcHead != NULL )
X			if( pxNewQueue->pcHead != 0 )
N			{
N				/* Initialise the queue members as described above where the
N				queue type is defined. */
N				pxNewQueue->uxLength = uxQueueLength;
N				pxNewQueue->uxItemSize = uxItemSize;
N				xQueueGenericReset( pxNewQueue, pdTRUE );
X				xQueueGenericReset( pxNewQueue, ( 1 ) );
N
N				#if ( configUSE_TRACE_FACILITY == 1 )
X				#if ( 0 == 1 )
S				{
S					pxNewQueue->ucQueueType = ucQueueType;
S				}
N				#endif /* configUSE_TRACE_FACILITY */
N
N				#if( configUSE_QUEUE_SETS == 1 )
X				#if( 0 == 1 )
S				{
S					pxNewQueue->pxQueueSetContainer = NULL;
S				}
N				#endif /* configUSE_QUEUE_SETS */
N
N				traceQUEUE_CREATE( pxNewQueue );
X				;
N				xReturn = pxNewQueue;
N			}
N			else
N			{
N				traceQUEUE_CREATE_FAILED( ucQueueType );
X				;
N				vPortFree( pxNewQueue );
N			}
N		}
N	}
N
N	configASSERT( xReturn );
X	;
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_MUTEXES == 1 )
X#if ( 0 == 1 )
S
S	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
S	{
S	xQUEUE *pxNewQueue;
S
S		/* Prevent compiler warnings about unused parameters if
S		configUSE_TRACE_FACILITY does not equal 1. */
S		( void ) ucQueueType;
S
S		/* Allocate the new queue structure. */
S		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
S		if( pxNewQueue != NULL )
S		{
S			/* Information required for priority inheritance. */
S			pxNewQueue->pxMutexHolder = NULL;
S			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
S
S			/* Queues used as a mutex no data is actually copied into or out
S			of the queue. */
S			pxNewQueue->pcWriteTo = NULL;
S			pxNewQueue->pcReadFrom = NULL;
S
S			/* Each mutex has a length of 1 (like a binary semaphore) and
S			an item size of 0 as nothing is actually copied into or out
S			of the mutex. */
S			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
S			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
S			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
S			pxNewQueue->xRxLock = queueUNLOCKED;
S			pxNewQueue->xTxLock = queueUNLOCKED;
S
S			#if ( configUSE_TRACE_FACILITY == 1 )
S			{
S				pxNewQueue->ucQueueType = ucQueueType;
S			}
S			#endif
S
S			#if ( configUSE_QUEUE_SETS == 1 )
S			{
S				pxNewQueue->pxQueueSetContainer = NULL;
S			}
S			#endif
S
S			/* Ensure the event queues start with the correct state. */
S			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
S			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
S
S			traceCREATE_MUTEX( pxNewQueue );
S
S			/* Start with the semaphore in the expected state. */
S			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
S		}
S		else
S		{
S			traceCREATE_MUTEX_FAILED();
S		}
S
S		configASSERT( pxNewQueue );
S		return pxNewQueue;
S	}
S
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
X#if ( ( 0 == 1 ) && ( 0 == 1 ) )
S
S	void* xQueueGetMutexHolder( xQueueHandle xSemaphore )
S	{
S	void *pxReturn;
S
S		/* This function is called by xSemaphoreGetMutexHolder(), and should not
S		be called directly.  Note:  This is is a good way of determining if the
S		calling task is the mutex holder, but not a good way of determining the
S		identity of the mutex holder, as the holder may change between the
S		following critical section exiting and the function returning. */
S		taskENTER_CRITICAL();
S		{
S			if( ( ( xQUEUE * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
S			{
S				pxReturn = ( void * ) ( ( xQUEUE * ) xSemaphore )->pxMutexHolder;
S			}
S			else
S			{
S				pxReturn = NULL;
S			}
S		}
S		taskEXIT_CRITICAL();
S
S		return pxReturn;
S	}
S
N#endif
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_RECURSIVE_MUTEXES == 1 )
X#if ( 0 == 1 )
S
S	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex )
S	{
S	portBASE_TYPE xReturn;
S	xQUEUE *pxMutex;
S
S		pxMutex = ( xQUEUE * ) xMutex;
S		configASSERT( pxMutex );
S
S		/* If this is the task that holds the mutex then pxMutexHolder will not
S		change outside of this task.  If this task does not hold the mutex then
S		pxMutexHolder can never coincidentally equal the tasks handle, and as
S		this is the only condition we are interested in it does not matter if
S		pxMutexHolder is accessed simultaneously by another task.  Therefore no
S		mutual exclusion is required to test the pxMutexHolder variable. */
S		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
S		{
S			traceGIVE_MUTEX_RECURSIVE( pxMutex );
S
S			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
S			the task handle, therefore no underflow check is required.  Also,
S			uxRecursiveCallCount is only modified by the mutex holder, and as
S			there can only be one, no mutual exclusion is required to modify the
S			uxRecursiveCallCount member. */
S			( pxMutex->uxRecursiveCallCount )--;
S
S			/* Have we unwound the call count? */
S			if( pxMutex->uxRecursiveCallCount == 0 )
S			{
S				/* Return the mutex.  This will automatically unblock any other
S				task that might be waiting to access the mutex. */
S				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
S			}
S
S			xReturn = pdPASS;
S		}
S		else
S		{
S			/* We cannot give the mutex because we are not the holder. */
S			xReturn = pdFAIL;
S
S			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_RECURSIVE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_RECURSIVE_MUTEXES == 1 )
X#if ( 0 == 1 )
S
S	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime )
S	{
S	portBASE_TYPE xReturn;
S	xQUEUE *pxMutex;
S
S		pxMutex = ( xQUEUE * ) xMutex;
S		configASSERT( pxMutex );
S
S		/* Comments regarding mutual exclusion as per those within
S		xQueueGiveMutexRecursive(). */
S
S		traceTAKE_MUTEX_RECURSIVE( pxMutex );
S
S		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
S		{
S			( pxMutex->uxRecursiveCallCount )++;
S			xReturn = pdPASS;
S		}
S		else
S		{
S			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
S
S			/* pdPASS will only be returned if we successfully obtained the mutex,
S			we may have blocked to reach here. */
S			if( xReturn == pdPASS )
S			{
S				( pxMutex->uxRecursiveCallCount )++;
S			}
S			else
S			{
S				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
S			}
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_RECURSIVE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_COUNTING_SEMAPHORES == 1 )
X#if ( 0 == 1 )
S
S	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
S	{
S	xQueueHandle xHandle;
S
S		xHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
S
S		if( xHandle != NULL )
S		{
S			( ( xQUEUE * ) xHandle )->uxMessagesWaiting = uxInitialCount;
S
S			traceCREATE_COUNTING_SEMAPHORE();
S		}
S		else
S		{
S			traceCREATE_COUNTING_SEMAPHORE_FAILED();
S		}
S
S		configASSERT( xHandle );
S		return xHandle;
S	}
S
N#endif /* configUSE_COUNTING_SEMAPHORES */
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
Xsigned long xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, long xCopyPosition )
N{
Nsigned portBASE_TYPE xEntryTimeSet = pdFALSE;
Xsigned long xEntryTimeSet = ( 0 );
NxTimeOutType xTimeOut;
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
X	;
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Is there room on the queue now?  To be running we must be
N			the highest priority task wanting to access the queue. */
N			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
N			{
N				traceQUEUE_SEND( pxQueue );
X				;
N				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
N
N				#if ( configUSE_QUEUE_SETS == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->pxQueueSetContainer != NULL )
S					{
S						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
S						{
S							/* The queue is a member of a queue set, and posting
S							to the queue set caused a higher priority task to
S							unblock. A context switch is required. */
S							portYIELD_WITHIN_API();
S						}
S					}
S					else
S					{
S						/* If there was a task waiting for data to arrive on the
S						queue then unblock it now. */
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
S							{
S								/* The unblocked task has a priority higher than
S								our own so yield immediately.  Yes it is ok to
S								do this from within the critical section - the
S								kernel takes care of that. */
S								portYIELD_WITHIN_API();
S							}
S						}
S					}
S				}
N				#else /* configUSE_QUEUE_SETS */
N				{
N					/* If there was a task waiting for data to arrive on the
N					queue then unblock it now. */
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == ( 1 ) )
N						{
N							/* The unblocked task has a priority higher than
N							our own so yield immediately.  Yes it is ok to do
N							this from within the critical section - the kernel
N							takes care of that. */
N							portYIELD_WITHIN_API();
X							vPortYield();
N						}
N					}
N				}
N				#endif /* configUSE_QUEUE_SETS */
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N
N				/* Return to the original privilege level before exiting the
N				function. */
N				return pdPASS;
X				return ( 1 );
N			}
N			else
N			{
N				if( xTicksToWait == ( portTickType ) 0 )
N				{
N					/* The queue was full and no block time is specified (or
N					the block time has expired) so leave now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N
N					/* Return to the original privilege level before exiting
N					the function. */
N					traceQUEUE_SEND_FAILED( pxQueue );
X					;
N					return errQUEUE_FULL;
X					return ( 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( 0 ) )
N				{
N					/* The queue was full and a block time was specified so
N					configure the timeout structure. */
N					vTaskSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( 1 );
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can send to and receive from the queue
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->xRxLock == ( ( signed long ) -1 ) ) { ( pxQueue )->xRxLock = ( ( signed long ) 0 ); } if( ( pxQueue )->xTxLock == ( ( signed long ) -1 ) ) { ( pxQueue )->xTxLock = ( ( signed long ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( 0 ) )
N		{
N			if( prvIsQueueFull( pxQueue ) != pdFALSE )
X			if( prvIsQueueFull( pxQueue ) != ( 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
X				;
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
N
N				/* Unlocking the queue means queue events can effect the
N				event list.  It is possible	that interrupts occurring now
N				remove this task from the event	list again - but as the
N				scheduler is suspended the task will go onto the pending
N				ready last instead of the actual ready list. */
N				prvUnlockQueue( pxQueue );
N
N				/* Resuming the scheduler will move tasks from the pending
N				ready list into the ready list - so it is feasible that this
N				task is already in a ready list before it yields - in which
N				case the yield will not cause a context switch unless there
N				is also a higher priority task in the pending ready list. */
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N			}
N			else
N			{
N				/* Try again. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			/* The timeout has expired. */
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N
N			/* Return to the original privilege level before exiting the
N			function. */
N			traceQUEUE_SEND_FAILED( pxQueue );
X			;
N			return errQUEUE_FULL;
X			return ( 0 );
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_ALTERNATIVE_API == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
S	{
S	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
S	xTimeOutType xTimeOut;
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S		configASSERT( pxQueue );
S		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
S
S		for( ;; )
S		{
S			taskENTER_CRITICAL();
S			{
S				/* Is there room on the queue now?  To be running we must be
S				the highest priority task wanting to access the queue. */
S				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
S				{
S					traceQUEUE_SEND( pxQueue );
S					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
S
S					/* If there was a task waiting for data to arrive on the
S					queue then unblock it now. */
S					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S					{
S						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
S						{
S							/* The unblocked task has a priority higher than
S							our own so yield immediately. */
S							portYIELD_WITHIN_API();
S						}
S					}
S
S					taskEXIT_CRITICAL();
S					return pdPASS;
S				}
S				else
S				{
S					if( xTicksToWait == ( portTickType ) 0 )
S					{
S						taskEXIT_CRITICAL();
S						return errQUEUE_FULL;
S					}
S					else if( xEntryTimeSet == pdFALSE )
S					{
S						vTaskSetTimeOutState( &xTimeOut );
S						xEntryTimeSet = pdTRUE;
S					}
S				}
S			}
S			taskEXIT_CRITICAL();
S
S			taskENTER_CRITICAL();
S			{
S				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
S				{
S					if( prvIsQueueFull( pxQueue ) != pdFALSE )
S					{
S						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
S						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
S						portYIELD_WITHIN_API();
S					}
S				}
S				else
S				{
S					taskEXIT_CRITICAL();
S					traceQUEUE_SEND_FAILED( pxQueue );
S					return errQUEUE_FULL;
S				}
S			}
S			taskEXIT_CRITICAL();
S		}
S	}
S
N#endif /* configUSE_ALTERNATIVE_API */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_ALTERNATIVE_API == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
S	{
S	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
S	xTimeOutType xTimeOut;
S	signed char *pcOriginalReadPosition;
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S		configASSERT( pxQueue );
S		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
S
S		for( ;; )
S		{
S			taskENTER_CRITICAL();
S			{
S				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
S				{
S					/* Remember our read position in case we are just peeking. */
S					pcOriginalReadPosition = pxQueue->pcReadFrom;
S
S					prvCopyDataFromQueue( pxQueue, pvBuffer );
S
S					if( xJustPeeking == pdFALSE )
S					{
S						traceQUEUE_RECEIVE( pxQueue );
S
S						/* We are actually removing data. */
S						--( pxQueue->uxMessagesWaiting );
S
S						#if ( configUSE_MUTEXES == 1 )
S						{
S							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
S							{
S								/* Record the information required to implement
S								priority inheritance should it become necessary. */
S								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
S							}
S						}
S						#endif
S
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
S							{
S								portYIELD_WITHIN_API();
S							}
S						}
S					}
S					else
S					{
S						traceQUEUE_PEEK( pxQueue );
S
S						/* We are not removing the data, so reset our read
S						pointer. */
S						pxQueue->pcReadFrom = pcOriginalReadPosition;
S
S						/* The data is being left in the queue, so see if there are
S						any other tasks waiting for the data. */
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							/* Tasks that are removed from the event list will get added to
S							the pending ready list as the scheduler is still suspended. */
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S							{
S								/* The task waiting has a higher priority than this task. */
S								portYIELD_WITHIN_API();
S							}
S						}
S
S					}
S
S					taskEXIT_CRITICAL();
S					return pdPASS;
S				}
S				else
S				{
S					if( xTicksToWait == ( portTickType ) 0 )
S					{
S						taskEXIT_CRITICAL();
S						traceQUEUE_RECEIVE_FAILED( pxQueue );
S						return errQUEUE_EMPTY;
S					}
S					else if( xEntryTimeSet == pdFALSE )
S					{
S						vTaskSetTimeOutState( &xTimeOut );
S						xEntryTimeSet = pdTRUE;
S					}
S				}
S			}
S			taskEXIT_CRITICAL();
S
S			taskENTER_CRITICAL();
S			{
S				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
S				{
S					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
S					{
S						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
S
S						#if ( configUSE_MUTEXES == 1 )
S						{
S							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
S							{
S								portENTER_CRITICAL();
S								{
S									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
S								}
S								portEXIT_CRITICAL();
S							}
S						}
S						#endif
S
S						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
S						portYIELD_WITHIN_API();
S					}
S				}
S				else
S				{
S					taskEXIT_CRITICAL();
S					traceQUEUE_RECEIVE_FAILED( pxQueue );
S					return errQUEUE_EMPTY;
S				}
S			}
S			taskEXIT_CRITICAL();
S		}
S	}
S
S
N#endif /* configUSE_ALTERNATIVE_API */
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
Xsigned long xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed long *pxHigherPriorityTaskWoken, long xCopyPosition )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
Nunsigned portBASE_TYPE uxSavedInterruptStatus;
Xunsigned long uxSavedInterruptStatus;
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
X	;
N
N	/* Similar to xQueueGenericSend, except we don't block if there is no room
N	in the queue.  Also we don't directly wake a task that was blocked on a
N	queue read, instead we return a flag to say whether a context switch is
N	required or not (i.e. has a task with a higher priority than us been woken
N	by this	post). */
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulPortSetInterruptMask();
N	{
N		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
N		{
N			traceQUEUE_SEND_FROM_ISR( pxQueue );
X			;
N
N			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
N
N			/* If the queue is locked we do not alter the event list.  This will
N			be done when the queue is unlocked later. */
N			if( pxQueue->xTxLock == queueUNLOCKED )
X			if( pxQueue->xTxLock == ( ( signed long ) -1 ) )
N			{
N				#if ( configUSE_QUEUE_SETS == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->pxQueueSetContainer != NULL )
S					{
S						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
S						{
S							/* The queue is a member of a queue set, and posting
S							to the queue set caused a higher priority task to
S							unblock.  A context switch is required. */
S							if( pxHigherPriorityTaskWoken != NULL )
S							{
S								*pxHigherPriorityTaskWoken = pdTRUE;
S							}
S						}
S					}
S					else
S					{
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S							{
S								/* The task waiting has a higher priority so record that a
S								context	switch is required. */
S								if( pxHigherPriorityTaskWoken != NULL )
S								{
S									*pxHigherPriorityTaskWoken = pdTRUE;
S								}
S							}
S						}
S					}
S				}
N				#else /* configUSE_QUEUE_SETS */
N				{
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( 0 ) )
N						{
N							/* The task waiting has a higher priority so record that a
N							context	switch is required. */
N							if( pxHigherPriorityTaskWoken != NULL )
X							if( pxHigherPriorityTaskWoken != 0 )
N							{
N								*pxHigherPriorityTaskWoken = pdTRUE;
X								*pxHigherPriorityTaskWoken = ( 1 );
N							}
N						}
N					}
N				}
N				#endif /* configUSE_QUEUE_SETS */
N			}
N			else
N			{
N				/* Increment the lock count so the task that unlocks the queue
N				knows that data was posted while it was locked. */
N				++( pxQueue->xTxLock );
N			}
N
N			xReturn = pdPASS;
X			xReturn = ( 1 );
N		}
N		else
N		{
N			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
X			;
N			xReturn = errQUEUE_FULL;
X			xReturn = ( 0 );
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vPortClearInterruptMask(uxSavedInterruptStatus);
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
Xsigned long xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, long xJustPeeking )
N{
Nsigned portBASE_TYPE xEntryTimeSet = pdFALSE;
Xsigned long xEntryTimeSet = ( 0 );
NxTimeOutType xTimeOut;
Nsigned char *pcOriginalReadPosition;
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
X	;
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Is there data in the queue now?  To be running we must be
N			the highest priority task wanting to access the queue. */
N			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
X			if( pxQueue->uxMessagesWaiting > ( unsigned long ) 0 )
N			{
N				/* Remember our read position in case we are just peeking. */
N				pcOriginalReadPosition = pxQueue->pcReadFrom;
N
N				prvCopyDataFromQueue( pxQueue, pvBuffer );
N
N				if( xJustPeeking == pdFALSE )
X				if( xJustPeeking == ( 0 ) )
N				{
N					traceQUEUE_RECEIVE( pxQueue );
X					;
N
N					/* We are actually removing data. */
N					--( pxQueue->uxMessagesWaiting );
N
N					#if ( configUSE_MUTEXES == 1 )
X					#if ( 0 == 1 )
S					{
S						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
S						{
S							/* Record the information required to implement
S							priority inheritance should it become necessary. */
S							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
S						}
S					}
N					#endif
N
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X					if( ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == ( 1 ) )
N						{
N							portYIELD_WITHIN_API();
X							vPortYield();
N						}
N					}
N				}
N				else
N				{
N					traceQUEUE_PEEK( pxQueue );
X					;
N
N					/* The data is not being removed, so reset the read
N					pointer. */
N					pxQueue->pcReadFrom = pcOriginalReadPosition;
N
N					/* The data is being left in the queue, so see if there are
N					any other tasks waiting for the data. */
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N					{
N						/* Tasks that are removed from the event list will get added to
N						the pending ready list as the scheduler is still suspended. */
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( 0 ) )
N						{
N							/* The task waiting has a higher priority than this task. */
N							portYIELD_WITHIN_API();
X							vPortYield();
N						}
N					}
N				}
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N				return pdPASS;
X				return ( 1 );
N			}
N			else
N			{
N				if( xTicksToWait == ( portTickType ) 0 )
N				{
N					/* The queue was empty and no block time is specified (or
N					the block time has expired) so leave now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N					traceQUEUE_RECEIVE_FAILED( pxQueue );
X					;
N					return errQUEUE_EMPTY;
X					return ( 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( 0 ) )
N				{
N					/* The queue was empty and a block time was specified so
N					configure the timeout structure. */
N					vTaskSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( 1 );
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can send to and receive from the queue
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->xRxLock == ( ( signed long ) -1 ) ) { ( pxQueue )->xRxLock = ( ( signed long ) 0 ); } if( ( pxQueue )->xTxLock == ( ( signed long ) -1 ) ) { ( pxQueue )->xTxLock = ( ( signed long ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( 0 ) )
N		{
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
X				;
N
N				#if ( configUSE_MUTEXES == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
S					{
S						portENTER_CRITICAL();
S						{
S							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
S						}
S						portEXIT_CRITICAL();
S					}
S				}
N				#endif
N
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
N				prvUnlockQueue( pxQueue );
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N			}
N			else
N			{
N				/* Try again. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N			traceQUEUE_RECEIVE_FAILED( pxQueue );
X			;
N			return errQUEUE_EMPTY;
X			return ( 0 );
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
Xsigned long xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed long *pxHigherPriorityTaskWoken )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
Nunsigned portBASE_TYPE uxSavedInterruptStatus;
Xunsigned long uxSavedInterruptStatus;
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
X	;
N
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulPortSetInterruptMask();
N	{
N		/* We cannot block from an ISR, so check there is data available. */
N		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
X		if( pxQueue->uxMessagesWaiting > ( unsigned long ) 0 )
N		{
N			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
X			;
N
N			prvCopyDataFromQueue( pxQueue, pvBuffer );
N			--( pxQueue->uxMessagesWaiting );
N
N			/* If the queue is locked we will not modify the event list.  Instead
N			we update the lock count so the task that unlocks the queue will know
N			that an ISR has removed data while the queue was locked. */
N			if( pxQueue->xRxLock == queueUNLOCKED )
X			if( pxQueue->xRxLock == ( ( signed long ) -1 ) )
N			{
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X				if( ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( 0 ) )
N					{
N						/* The task waiting has a higher priority than us so
N						force a context switch. */
N						if( pxHigherPriorityTaskWoken != NULL )
X						if( pxHigherPriorityTaskWoken != 0 )
N						{
N							*pxHigherPriorityTaskWoken = pdTRUE;
X							*pxHigherPriorityTaskWoken = ( 1 );
N						}
N					}
N				}
N			}
N			else
N			{
N				/* Increment the lock count so the task that unlocks the queue
N				knows that data was removed while it was locked. */
N				++( pxQueue->xRxLock );
N			}
N
N			xReturn = pdPASS;
X			xReturn = ( 1 );
N		}
N		else
N		{
N			xReturn = pdFAIL;
X			xReturn = ( 0 );
N			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
X			;
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vPortClearInterruptMask(uxSavedInterruptStatus);
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nunsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
Xunsigned long uxQueueMessagesWaiting( const xQueueHandle xQueue )
N{
Nunsigned portBASE_TYPE uxReturn;
Xunsigned long uxReturn;
N
N	configASSERT( xQueue );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return uxReturn;
N}
N/*-----------------------------------------------------------*/
N
Nunsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
Xunsigned long uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
N{
Nunsigned portBASE_TYPE uxReturn;
Xunsigned long uxReturn;
N
N	configASSERT( xQueue );
X	;
N
N	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
N
N	return uxReturn;
N}
N/*-----------------------------------------------------------*/
N
Nvoid vQueueDelete( xQueueHandle xQueue )
N{
NxQUEUE *pxQueue;
N
N	pxQueue = ( xQUEUE * ) xQueue;
N	configASSERT( pxQueue );
X	;
N
N	traceQUEUE_DELETE( pxQueue );
X	;
N	#if ( configQUEUE_REGISTRY_SIZE > 0 )
X	#if ( 0U > 0 )
S	{
S		prvQueueUnregisterQueue( pxQueue );
S	}
N	#endif
N	vPortFree( pxQueue->pcHead );
N	vPortFree( pxQueue );
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	unsigned char ucQueueGetQueueNumber( xQueueHandle xQueue )
S	{
S		return ( ( xQUEUE * ) xQueue )->ucQueueNumber;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	void vQueueSetQueueNumber( xQueueHandle xQueue, unsigned char ucQueueNumber )
S	{
S		( ( xQUEUE * ) xQueue )->ucQueueNumber = ucQueueNumber;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	unsigned char ucQueueGetQueueType( xQueueHandle xQueue )
S	{
S		return ( ( xQUEUE * ) xQueue )->ucQueueType;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
Nstatic void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
Xstatic void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, long xPosition )
N{
N	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
X	if( pxQueue->uxItemSize == ( unsigned long ) 0 )
N	{
N		#if ( configUSE_MUTEXES == 1 )
X		#if ( 0 == 1 )
S		{
S			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
S			{
S				/* The mutex is no longer being held. */
S				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
S				pxQueue->pxMutexHolder = NULL;
S			}
S		}
N		#endif
N	}
N	else if( xPosition == queueSEND_TO_BACK )
X	else if( xPosition == ( 0 ) )
N	{
N		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
N		pxQueue->pcWriteTo += pxQueue->uxItemSize;
N		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
N		{
N			pxQueue->pcWriteTo = pxQueue->pcHead;
N		}
N	}
N	else
N	{
N		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
N		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
N		if( pxQueue->pcReadFrom < pxQueue->pcHead )
N		{
N			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
N		}
N	}
N
N	++( pxQueue->uxMessagesWaiting );
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
N{
N	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
X	if( pxQueue->pcHead != 0 )
N	{
N		pxQueue->pcReadFrom += pxQueue->uxItemSize;
N		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
N		{
N			pxQueue->pcReadFrom = pxQueue->pcHead;
N		}
N		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( size_t ) pxQueue->uxItemSize );
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvUnlockQueue( xQUEUE *pxQueue )
N{
N	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
N
N	/* The lock counts contains the number of extra data items placed or
N	removed from the queue while the queue was locked.  When a queue is
N	locked items can be added or removed, but the event lists cannot be
N	updated. */
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		/* See if data was added to the queue while it was locked. */
N		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
X		while( pxQueue->xTxLock > ( ( signed long ) 0 ) )
N		{
N			/* Data was posted while the queue was locked.  Are any tasks
N			blocked waiting for data to become available? */
N			#if ( configUSE_QUEUE_SETS == 1 )
X			#if ( 0 == 1 )
S			{
S				if( pxQueue->pxQueueSetContainer != NULL )
S				{
S					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
S					{
S						/* The queue is a member of a queue set, and posting to
S						the queue set caused a higher priority task to unblock.
S						A context switch is required. */
S						vTaskMissedYield();
S					}
S				}
S				else
S				{
S					/* Tasks that are removed from the event list will get added to
S					the pending ready list as the scheduler is still suspended. */
S					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S					{
S						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S						{
S							/* The task waiting has a higher priority so record that a
S							context	switch is required. */
S							vTaskMissedYield();
S						}
S					}
S					else
S					{
S						break;
S					}
S				}
S			}
N			#else /* configUSE_QUEUE_SETS */
N			{
N				/* Tasks that are removed from the event list will get added to
N				the pending ready list as the scheduler is still suspended. */
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X				if( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( 0 ) )
N					{
N						/* The task waiting has a higher priority so record that a
N						context	switch is required. */
N						vTaskMissedYield();
N					}
N				}
N				else
N				{
N					break;
N				}
N			}
N			#endif /* configUSE_QUEUE_SETS */
N
N			--( pxQueue->xTxLock );
N		}
N
N		pxQueue->xTxLock = queueUNLOCKED;
X		pxQueue->xTxLock = ( ( signed long ) -1 );
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	/* Do the same for the Rx lock. */
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
X		while( pxQueue->xRxLock > ( ( signed long ) 0 ) )
N		{
N			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X			if( ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( unsigned long ) 0 ) == ( 0 ) )
N			{
N				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( 0 ) )
N				{
N					vTaskMissedYield();
N				}
N
N				--( pxQueue->xRxLock );
N			}
N			else
N			{
N				break;
N			}
N		}
N
N		pxQueue->xRxLock = queueUNLOCKED;
X		pxQueue->xRxLock = ( ( signed long ) -1 );
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N}
N/*-----------------------------------------------------------*/
N
Nstatic signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
Xstatic signed long prvIsQueueEmpty( const xQUEUE *pxQueue )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		if( pxQueue->uxMessagesWaiting == 0 )
N		{
N			xReturn = pdTRUE;
X			xReturn = ( 1 );
N		}
N		else
N		{
N			xReturn = pdFALSE;
X			xReturn = ( 0 );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
Xsigned long xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
N
N	configASSERT( xQueue );
X	;
N	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
N	{
N		xReturn = pdTRUE;
X		xReturn = ( 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( 0 );
N	}
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nstatic signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
Xstatic signed long prvIsQueueFull( const xQUEUE *pxQueue )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
N		{
N			xReturn = pdTRUE;
X			xReturn = ( 1 );
N		}
N		else
N		{
N			xReturn = pdFALSE;
X			xReturn = ( 0 );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nsigned portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
Xsigned long xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
N{
Nsigned portBASE_TYPE xReturn;
Xsigned long xReturn;
N
N	configASSERT( xQueue );
X	;
N	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
N	{
N		xReturn = pdTRUE;
X		xReturn = ( 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( 0 );
N	}
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
S	{
S	signed portBASE_TYPE xReturn;
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S
S		/* If the queue is already full we may have to block.  A critical section
S		is required to prevent an interrupt removing something from the queue
S		between the check to see if the queue is full and blocking on the queue. */
S		portDISABLE_INTERRUPTS();
S		{
S			if( prvIsQueueFull( pxQueue ) != pdFALSE )
S			{
S				/* The queue is full - do we want to block or just leave without
S				posting? */
S				if( xTicksToWait > ( portTickType ) 0 )
S				{
S					/* As this is called from a coroutine we cannot block directly, but
S					return indicating that we need to block. */
S					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
S					portENABLE_INTERRUPTS();
S					return errQUEUE_BLOCKED;
S				}
S				else
S				{
S					portENABLE_INTERRUPTS();
S					return errQUEUE_FULL;
S				}
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
S			{
S				/* There is room in the queue, copy the data into the queue. */
S				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
S				xReturn = pdPASS;
S
S				/* Were any co-routines waiting for data to become available? */
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S				{
S					/* In this instance the co-routine could be placed directly
S					into the ready list as we are within a critical section.
S					Instead the same pending ready list mechanism is used as if
S					the event were caused from within an interrupt. */
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S					{
S						/* The co-routine waiting has a higher priority so record
S						that a yield might be appropriate. */
S						xReturn = errQUEUE_YIELD;
S					}
S				}
S			}
S			else
S			{
S				xReturn = errQUEUE_FULL;
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
S	{
S	signed portBASE_TYPE xReturn;
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S
S		/* If the queue is already empty we may have to block.  A critical section
S		is required to prevent an interrupt adding something to the queue
S		between the check to see if the queue is empty and blocking on the queue. */
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
S			{
S				/* There are no messages in the queue, do we want to block or just
S				leave with nothing? */
S				if( xTicksToWait > ( portTickType ) 0 )
S				{
S					/* As this is a co-routine we cannot block directly, but return
S					indicating that we need to block. */
S					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
S					portENABLE_INTERRUPTS();
S					return errQUEUE_BLOCKED;
S				}
S				else
S				{
S					portENABLE_INTERRUPTS();
S					return errQUEUE_FULL;
S				}
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
S			{
S				/* Data is available from the queue. */
S				pxQueue->pcReadFrom += pxQueue->uxItemSize;
S				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
S				{
S					pxQueue->pcReadFrom = pxQueue->pcHead;
S				}
S				--( pxQueue->uxMessagesWaiting );
S				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
S
S				xReturn = pdPASS;
S
S				/* Were any co-routines waiting for space to become available? */
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
S				{
S					/* In this instance the co-routine could be placed directly
S					into the ready list as we are within a critical section.
S					Instead the same pending ready list mechanism is used as if
S					the event were caused from within an interrupt. */
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
S					{
S						xReturn = errQUEUE_YIELD;
S					}
S				}
S			}
S			else
S			{
S				xReturn = pdFAIL;
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
S	{
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S
S		/* Cannot block within an ISR so if there is no space on the queue then
S		exit without doing anything. */
S		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
S		{
S			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
S
S			/* We only want to wake one co-routine per ISR, so check that a
S			co-routine has not already been woken. */
S			if( xCoRoutinePreviouslyWoken == pdFALSE )
S			{
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S				{
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S					{
S						return pdTRUE;
S					}
S				}
S			}
S		}
S
S		return xCoRoutinePreviouslyWoken;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
S	{
S	signed portBASE_TYPE xReturn;
S	xQUEUE * pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S
S		/* We cannot block from an ISR, so check there is data available. If
S		not then just leave without doing anything. */
S		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
S		{
S			/* Copy the data from the queue. */
S			pxQueue->pcReadFrom += pxQueue->uxItemSize;
S			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
S			{
S				pxQueue->pcReadFrom = pxQueue->pcHead;
S			}
S			--( pxQueue->uxMessagesWaiting );
S			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
S
S			if( ( *pxCoRoutineWoken ) == pdFALSE )
S			{
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
S				{
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
S					{
S						*pxCoRoutineWoken = pdTRUE;
S					}
S				}
S			}
S
S			xReturn = pdPASS;
S		}
S		else
S		{
S			xReturn = pdFAIL;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0U > 0 )
S
S	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
S	{
S	unsigned portBASE_TYPE ux;
S
S		/* See if there is an empty space in the registry.  A NULL name denotes
S		a free slot. */
S		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
S		{
S			if( xQueueRegistry[ ux ].pcQueueName == NULL )
S			{
S				/* Store the information on this queue. */
S				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
S				xQueueRegistry[ ux ].xHandle = xQueue;
S				break;
S			}
S		}
S	}
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N/*-----------------------------------------------------------*/
N
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0U > 0 )
S
S	static void prvQueueUnregisterQueue( xQueueHandle xQueue )
S	{
S	unsigned portBASE_TYPE ux;
S
S		/* See if the handle of the queue being unregistered in actually in the
S		registry. */
S		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
S		{
S			if( xQueueRegistry[ ux ].xHandle == xQueue )
S			{
S				/* Set the name to NULL to show that this slot if free again. */
S				xQueueRegistry[ ux ].pcQueueName = NULL;
S				break;
S			}
S		}
S
S	}
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TIMERS == 1 )
X#if ( 0 == 1 )
S
S	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
S	{
S	xQUEUE *pxQueue;
S
S		pxQueue = ( xQUEUE * ) xQueue;
S
S		/* This function should not be called by application code hence the
S		'Restricted' in its name.  It is not part of the public API.  It is
S		designed for use by kernel code, and has special calling requirements.
S		It can result in vListInsert() being called on a list that can only
S		possibly ever have one item in it, so the list will be fast, but even
S		so it should be called with the scheduler locked and not from a critical
S		section. */
S
S		/* Only do anything if there are no messages in the queue.  This function
S		will not actually cause the task to block, just place it on a blocked
S		list.  It will not block until the scheduler is unlocked - at which
S		time a yield will be performed.  If an item is added to the queue while
S		the queue is locked, and the calling task blocks on the queue, then the
S		calling task will be immediately unblocked when the queue is unlocked. */
S		prvLockQueue( pxQueue );
S		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
S		{
S			/* There is nothing in the queue, block for the specified period. */
S			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
S		}
S		prvUnlockQueue( pxQueue );
S	}
S
N#endif /* configUSE_TIMERS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	xQueueSetHandle xQueueCreateSet( unsigned portBASE_TYPE uxEventQueueLength )
S	{
S	xQueueSetHandle pxQueue;
S
S		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( xQUEUE * ), queueQUEUE_TYPE_SET );
S
S		return pxQueue;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	portBASE_TYPE xQueueAddToSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
S	{
S	portBASE_TYPE xReturn;
S
S		if( ( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
S		{
S			xReturn = pdFAIL;
S		}
S		else
S		{
S			taskENTER_CRITICAL();
S			{
S				( ( xQUEUE * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
S			}
S			taskEXIT_CRITICAL();
S			xReturn = pdPASS;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	portBASE_TYPE xQueueRemoveFromSet( xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet )
S	{
S	portBASE_TYPE xReturn;
S	xQUEUE *pxQueueOrSemaphore;
S
S		pxQueueOrSemaphore = ( xQUEUE * ) xQueueOrSemaphore;
S
S		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
S		{
S			/* The queue was not a member of the set. */
S			xReturn = pdFAIL;
S		}
S		else if( pxQueueOrSemaphore->uxMessagesWaiting != 0 )
S		{
S			/* It is dangerous to remove a queue from a set when the queue is
S			not empty because the queue set will still hold pending events for
S			the queue. */
S			xReturn = pdFAIL;
S		}
S		else
S		{
S			taskENTER_CRITICAL();
S			{
S				/* The queue is no longer contained in the set. */
S				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
S			}
S			taskEXIT_CRITICAL();
S			xReturn = pdPASS;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	xQueueSetMemberHandle xQueueSelectFromSet( xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks )
S	{
S	xQueueSetMemberHandle xReturn = NULL;
S
S		xQueueGenericReceive( ( xQueueHandle ) xQueueSet, &xReturn, xBlockTimeTicks, pdFALSE );
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	xQueueSetMemberHandle xQueueSelectFromSetFromISR( xQueueSetHandle xQueueSet )
S	{
S	xQueueSetMemberHandle xReturn = NULL;
S
S		xQueueReceiveFromISR( ( xQueueHandle ) xQueueSet, &xReturn, NULL );
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	static portBASE_TYPE prvNotifyQueueSetContainer( xQUEUE *pxQueue, portBASE_TYPE xCopyPosition )
S	{
S	xQUEUE *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
S	portBASE_TYPE xReturn = pdFALSE;
S
S		configASSERT( pxQueueSetContainer );
S		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
S
S		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
S		{
S			traceQUEUE_SEND( pxQueueSetContainer );
S			/* The data copies is the handle of the queue that contains data. */
S			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
S			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
S			{
S				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
S				{
S					/* The task waiting has a higher priority */
S					xReturn = pdTRUE;
S				}
S			}
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N
