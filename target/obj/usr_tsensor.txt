; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usr_tsensor.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\usr_tsensor.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usr_tsensor.crf ..\usr_lib\usr_tsensor.c]
                          THUMB

                          AREA ||i.usrtadc_getadc||, CODE, READONLY, ALIGN=2

                  usrtadc_getadc PROC
;;;32     
;;;33     u16 usrtadc_getadc (u8 ch)   
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35      	ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_239Cycles5 );	//ADC1,ADC通道3,第一个转换,采样时间为239.5周期	  			    
000002  4c0b              LDR      r4,|L1.48|
000004  4601              MOV      r1,r0
000006  2307              MOVS     r3,#7
000008  2201              MOVS     r2,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       ADC_RegularChannelConfig
;;;36      	ADC_SoftwareStartConvCmd(ADC1, ENABLE);		//使能指定的ADC1的软件转换启动功能
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       ADC_SoftwareStartConvCmd
                  |L1.24|
;;;37     	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));//等待转换结束
000018  2102              MOVS     r1,#2
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       ADC_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L1.24|
;;;38     	return ADC_GetConversionValue(ADC1);	//返回最近一次ADC1规则组的转换结果
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      ADC_GetConversionValue
;;;39     }
;;;40     
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0x40012400

                          AREA ||i.usrtadc_gettm||, CODE, READONLY, ALIGN=1

                  usrtadc_gettm PROC
;;;40     
;;;41     u16 usrtadc_gettm (int filter_len )
000000  b570              PUSH     {r4-r6,lr}
;;;42     {
;;;43     	u16  temp_val=0;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;42
;;;44     	u8   t;
;;;45     	if (filter_len>20) 
000006  2814              CMP      r0,#0x14
000008  dd02              BLE      |L2.16|
;;;46     		filter_len = 20;
00000a  2414              MOVS     r4,#0x14
;;;47     	
;;;48     	for(t=0; t<filter_len; t++){
00000c  2600              MOVS     r6,#0
00000e  e001              B        |L2.20|
                  |L2.16|
000010  2600              MOVS     r6,#0
000012  e009              B        |L2.40|
                  |L2.20|
;;;49     		temp_val += usrtadc_getadc (ADC_Channel_16);	 // TampSensor
000014  2010              MOVS     r0,#0x10
000016  f7fffffe          BL       usrtadc_getadc
00001a  4428              ADD      r0,r0,r5
00001c  b285              UXTH     r5,r0
;;;50     		delay_ms(5);
00001e  2005              MOVS     r0,#5
000020  f7fffffe          BL       delay_ms
000024  1c76              ADDS     r6,r6,#1
000026  b2f6              UXTB     r6,r6                 ;48
                  |L2.40|
000028  42a6              CMP      r6,r4                 ;48
00002a  dbf3              BLT      |L2.20|
;;;51     	}
;;;52     	return temp_val/filter_len;
00002c  fb95f0f4          SDIV     r0,r5,r4
000030  b280              UXTH     r0,r0
;;;53     }
000032  bd70              POP      {r4-r6,pc}
;;;54     
                          ENDP


                          AREA ||i.usrtadc_init||, CODE, READONLY, ALIGN=2

                  usrtadc_init PROC
;;;5      
;;;6      void usrtadc_init(void)
000000  b510              PUSH     {r4,lr}
;;;7      {
000002  b086              SUB      sp,sp,#0x18
;;;8      	ADC_InitTypeDef ADC_InitStructure; 
;;;9      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1	, ENABLE );	  //使能GPIOA,ADC1通道时钟
000004  2101              MOVS     r1,#1
000006  f44f7001          MOV      r0,#0x204
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;10       
;;;11     	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //分频因子6时钟为72M/6=12MHz
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;12     
;;;13      	ADC_DeInit(ADC1);  //将外设 ADC1 的全部寄存器重设为缺省值
000016  4c17              LDR      r4,|L3.116|
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ADC_DeInit
;;;14      
;;;15     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC工作模式:ADC1和ADC2工作在独立模式
00001e  2100              MOVS     r1,#0
;;;16     	ADC_InitStructure.ADC_ScanConvMode = DISABLE;	//模数转换工作在单通道模式
;;;17     	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;	//模数转换工作在单次转换模式
;;;18     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//转换由软件而不是外部触发启动
000020  f44f2060          MOV      r0,#0xe0000
000024  e9cd0102          STRD     r0,r1,[sp,#8]
000028  f88d1004          STRB     r1,[sp,#4]            ;16
;;;19     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	//ADC数据右对齐
;;;20     	ADC_InitStructure.ADC_NbrOfChannel = 1;	//顺序进行规则转换的ADC通道的数目
00002c  2001              MOVS     r0,#1
00002e  9100              STR      r1,[sp,#0]            ;16
000030  f88d1005          STRB     r1,[sp,#5]            ;17
000034  f88d0010          STRB     r0,[sp,#0x10]
;;;21     	ADC_Init(ADC1, &ADC_InitStructure);	//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器
000038  4669              MOV      r1,sp
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       ADC_Init
;;;22     
;;;23     	ADC_TempSensorVrefintCmd(ENABLE); //开启内部温度传感器
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       ADC_TempSensorVrefintCmd
;;;24     	
;;;25     	ADC_Cmd(ADC1, ENABLE);	//使能指定的ADC1
000046  2101              MOVS     r1,#1
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       ADC_Cmd
;;;26     	ADC_ResetCalibration(ADC1);	//重置指定的ADC1的复位寄存器
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       ADC_ResetCalibration
                  |L3.84|
;;;27       while(ADC_GetResetCalibrationStatus(ADC1));	//获取ADC1重置校准寄存器的状态,设置状态则等待
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       ADC_GetResetCalibrationStatus
00005a  2800              CMP      r0,#0
00005c  d1fa              BNE      |L3.84|
;;;28     
;;;29     	ADC_StartCalibration(ADC1);	 //
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       ADC_StartCalibration
                  |L3.100|
;;;30     	while(ADC_GetCalibrationStatus(ADC1));		//获取指定ADC1的校准程序,设置状态则等待
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       ADC_GetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L3.100|
;;;31     }
00006e  b006              ADD      sp,sp,#0x18
000070  bd10              POP      {r4,pc}
;;;32     
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      0x40012400
