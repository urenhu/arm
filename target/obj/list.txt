; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\list.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\list.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\list.crf ..\free_rtos\list.c]
                          THUMB

                          AREA ||i.uxListRemove||, CODE, READONLY, ALIGN=1

                  uxListRemove PROC
;;;190    
;;;191    unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
000000  e9d01201          LDRD     r1,r2,[r0,#4]
;;;192    {
;;;193    xList * pxList;
;;;194    
;;;195    	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
000004  608a              STR      r2,[r1,#8]
000006  e9d01201          LDRD     r1,r2,[r0,#4]
;;;196    	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
00000a  6051              STR      r1,[r2,#4]
;;;197    
;;;198    	/* The list item knows which list it is in.  Obtain the list from the list
;;;199    	item. */
;;;200    	pxList = ( xList * ) pxItemToRemove->pvContainer;
;;;201    
;;;202    	/* Make sure the index is left pointing to a valid item. */
;;;203    	if( pxList->pxIndex == pxItemToRemove )
00000c  6901              LDR      r1,[r0,#0x10]
00000e  684a              LDR      r2,[r1,#4]
000010  4282              CMP      r2,r0
000012  d101              BNE      |L1.24|
;;;204    	{
;;;205    		pxList->pxIndex = pxItemToRemove->pxPrevious;
000014  6882              LDR      r2,[r0,#8]
000016  604a              STR      r2,[r1,#4]
                  |L1.24|
;;;206    	}
;;;207    
;;;208    	pxItemToRemove->pvContainer = NULL;
000018  2200              MOVS     r2,#0
;;;209    	( pxList->uxNumberOfItems )--;
00001a  6102              STR      r2,[r0,#0x10]
00001c  6808              LDR      r0,[r1,#0]
00001e  1e40              SUBS     r0,r0,#1
000020  6008              STR      r0,[r1,#0]
;;;210    
;;;211    	return pxList->uxNumberOfItems;
000022  6808              LDR      r0,[r1,#0]
;;;212    }
000024  4770              BX       lr
;;;213    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialise||, CODE, READONLY, ALIGN=1

                  vListInitialise PROC
;;;83     
;;;84     void vListInitialise( xList *pxList )
000000  f1000108          ADD      r1,r0,#8
;;;85     {
;;;86     	/* The list structure contains a list item which is used to mark the
;;;87     	end of the list.  To initialise the list the list end is inserted
;;;88     	as the only list entry. */
;;;89     	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
;;;90     
;;;91     	/* The list end value is the highest possible value in the list to
;;;92     	ensure it remains at the end of the list. */
;;;93     	pxList->xListEnd.xItemValue = portMAX_DELAY;
000004  f04f32ff          MOV      r2,#0xffffffff
000008  e9c01201          STRD     r1,r2,[r0,#4]
;;;94     
;;;95     	/* The list end next and previous pointers point to itself so we know
;;;96     	when the list is empty. */
;;;97     	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
00000c  60c1              STR      r1,[r0,#0xc]
;;;98     	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
00000e  6101              STR      r1,[r0,#0x10]
;;;99     
;;;100    	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
000010  2100              MOVS     r1,#0
000012  6001              STR      r1,[r0,#0]
;;;101    }
000014  4770              BX       lr
;;;102    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInitialiseItem||, CODE, READONLY, ALIGN=1

                  vListInitialiseItem PROC
;;;103    
;;;104    void vListInitialiseItem( xListItem *pxItem )
000000  2100              MOVS     r1,#0
;;;105    {
;;;106    	/* Make sure the list item is not recorded as being on a list. */
;;;107    	pxItem->pvContainer = NULL;
000002  6101              STR      r1,[r0,#0x10]
;;;108    }
000004  4770              BX       lr
;;;109    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsert||, CODE, READONLY, ALIGN=1

                  vListInsert PROC
;;;133    
;;;134    void vListInsert( xList *pxList, xListItem *pxNewListItem )
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136    volatile xListItem *pxIterator;
;;;137    portTickType xValueOfInsertion;
;;;138    
;;;139    	/* Insert the new list item into the list, sorted in ulListItem order. */
;;;140    	xValueOfInsertion = pxNewListItem->xItemValue;
;;;141    
;;;142    	/* If the list already contains a list item with the same item value then
;;;143    	the new list item should be placed after it.  This ensures that TCB's which
;;;144    	are stored in ready lists (all of which have the same ulListItem value)
;;;145    	get an equal share of the CPU.  However, if the xItemValue is the same as
;;;146    	the back marker the iteration loop below will not end.  This means we need
;;;147    	to guard against this by checking the value first and modifying the
;;;148    	algorithm slightly if necessary. */
;;;149    	if( xValueOfInsertion == portMAX_DELAY )
000002  680b              LDR      r3,[r1,#0]
000004  1c5a              ADDS     r2,r3,#1
000006  d002              BEQ      |L4.14|
;;;150    	{
;;;151    		pxIterator = pxList->xListEnd.pxPrevious;
;;;152    	}
;;;153    	else
;;;154    	{
;;;155    		/* *** NOTE ***********************************************************
;;;156    		If you find your application is crashing here then likely causes are:
;;;157    			1) Stack overflow -
;;;158    			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
;;;159    			2) Incorrect interrupt priority assignment, especially on Cortex-M3
;;;160    			   parts where numerically high priority values denote low actual
;;;161    			   interrupt priories, which can seem counter intuitive.  See
;;;162    			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
;;;163    			3) Calling an API function from within a critical section or when
;;;164    			   the scheduler is suspended.
;;;165    			4) Using a queue or semaphore before it has been initialised or
;;;166    			   before the scheduler has been started (are interrupts firing
;;;167    			   before vTaskStartScheduler() has been called?).
;;;168    		See http://www.freertos.org/FAQHelp.html for more tips.
;;;169    		**********************************************************************/
;;;170    
;;;171    		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
000008  f1000208          ADD      r2,r0,#8
00000c  e002              B        |L4.20|
                  |L4.14|
00000e  6902              LDR      r2,[r0,#0x10]         ;151
000010  e004              B        |L4.28|
                  |L4.18|
000012  6852              LDR      r2,[r2,#4]
                  |L4.20|
000014  6854              LDR      r4,[r2,#4]
000016  6824              LDR      r4,[r4,#0]
000018  429c              CMP      r4,r3
00001a  d9fa              BLS      |L4.18|
                  |L4.28|
;;;172    		{
;;;173    			/* There is nothing to do here, we are just iterating to the
;;;174    			wanted insertion position. */
;;;175    		}
;;;176    	}
;;;177    
;;;178    	pxNewListItem->pxNext = pxIterator->pxNext;
00001c  6853              LDR      r3,[r2,#4]
;;;179    	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
00001e  604b              STR      r3,[r1,#4]
000020  6099              STR      r1,[r3,#8]
;;;180    	pxNewListItem->pxPrevious = pxIterator;
;;;181    	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
000022  608a              STR      r2,[r1,#8]
000024  6051              STR      r1,[r2,#4]
;;;182    
;;;183    	/* Remember which list the item is in.  This allows fast removal of the
;;;184    	item later. */
;;;185    	pxNewListItem->pvContainer = ( void * ) pxList;
;;;186    
;;;187    	( pxList->uxNumberOfItems )++;
000026  6108              STR      r0,[r1,#0x10]
000028  6801              LDR      r1,[r0,#0]
00002a  1c49              ADDS     r1,r1,#1
00002c  6001              STR      r1,[r0,#0]
;;;188    }
00002e  bd10              POP      {r4,pc}
;;;189    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vListInsertEnd||, CODE, READONLY, ALIGN=1

                  vListInsertEnd PROC
;;;110    
;;;111    void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
000000  6842              LDR      r2,[r0,#4]
;;;112    {
;;;113    volatile xListItem * pxIndex;
;;;114    
;;;115    	/* Insert a new list item into pxList, but rather than sort the list,
;;;116    	makes the new list item the last item to be removed by a call to
;;;117    	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
;;;118    	the pxIndex member. */
;;;119    	pxIndex = pxList->pxIndex;
;;;120    
;;;121    	pxNewListItem->pxNext = pxIndex->pxNext;
000002  6853              LDR      r3,[r2,#4]
;;;122    	pxNewListItem->pxPrevious = pxList->pxIndex;
000004  604b              STR      r3,[r1,#4]
000006  6843              LDR      r3,[r0,#4]
;;;123    	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
000008  608b              STR      r3,[r1,#8]
00000a  6853              LDR      r3,[r2,#4]
00000c  6099              STR      r1,[r3,#8]
;;;124    	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
00000e  6051              STR      r1,[r2,#4]
;;;125    	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
;;;126    
;;;127    	/* Remember which list the item is in. */
;;;128    	pxNewListItem->pvContainer = ( void * ) pxList;
000010  6041              STR      r1,[r0,#4]
;;;129    
;;;130    	( pxList->uxNumberOfItems )++;
000012  6108              STR      r0,[r1,#0x10]
000014  6801              LDR      r1,[r0,#0]
000016  1c49              ADDS     r1,r1,#1
000018  6001              STR      r1,[r0,#0]
;;;131    }
00001a  4770              BX       lr
;;;132    /*-----------------------------------------------------------*/
                          ENDP

