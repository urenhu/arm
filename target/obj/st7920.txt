; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\st7920.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\st7920.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\core -I..\STM32F10x_StdPeriph_Driver\inc -I..\app -I..\usr_lib -I..\ctt -I..\glcd -I..\sensor -IC:\Users\tisdk\Desktop\imgcapture_prototype\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\st7920.crf ..\glcd\st7920.c]
                          THUMB

                          AREA ||i.LCD_ClearRam||, CODE, READONLY, ALIGN=1

                  LCD_ClearRam PROC
;;;173    //********************************************************   
;;;174    void LCD_ClearRam(void)   
000000  b510              PUSH     {r4,lr}
;;;175    {   
;;;176        LCD_Write(LCD_COMMAND,LCD_BASIC_FUNCTION);          //基本指令集   
000002  2130              MOVS     r1,#0x30
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       LCD_Write
;;;177        LCD_Write(LCD_COMMAND,LCD_CLEAR_SCREEN);            //清屏   
00000a  2101              MOVS     r1,#1
00000c  e8bd4010          POP      {r4,lr}
000010  4608              MOV      r0,r1
000012  f7ffbffe          B.W      LCD_Write
;;;178    }   
;;;179    
                          ENDP


                          AREA ||i.LCD_DisplayCLR||, CODE, READONLY, ALIGN=1

                  LCD_DisplayCLR PROC
;;;251    
;;;252    void LCD_DisplayCLR()   
000000  b570              PUSH     {r4-r6,lr}
;;;253    {   
;;;254        unsigned char i,j;   
;;;255        LCD_GraphModeSet(0x00); //先关闭图形显示功能   
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       LCD_GraphModeSet
;;;256        for (j=0;j<32;j++) {
000008  2500              MOVS     r5,#0
                  |L2.10|
;;;257            for (i=0;i<8;i++) {
00000a  2400              MOVS     r4,#0
;;;258                LCD_Write(LCD_COMMAND,0x80+j);      //设定垂直坐标   
00000c  f1050680          ADD      r6,r5,#0x80
                  |L2.16|
000010  b2f1              UXTB     r1,r6
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       LCD_Write
;;;259                LCD_Write(LCD_COMMAND,0x80+i);      //设定水平坐标   
000018  f1040080          ADD      r0,r4,#0x80
00001c  b2c1              UXTB     r1,r0
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       LCD_Write
;;;260                LCD_Write(LCD_DATA,0x00);   //放入数据高字节   
000024  2100              MOVS     r1,#0
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       LCD_Write
;;;261                LCD_Write(LCD_DATA,0x00);   //放入数据低字节   
00002c  2100              MOVS     r1,#0
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       LCD_Write
000034  1c64              ADDS     r4,r4,#1
000036  b2e4              UXTB     r4,r4                 ;257
000038  2c08              CMP      r4,#8                 ;257
00003a  d3e9              BCC      |L2.16|
00003c  1c6d              ADDS     r5,r5,#1              ;257
00003e  b2ed              UXTB     r5,r5                 ;256
000040  2d20              CMP      r5,#0x20              ;256
000042  d3e2              BCC      |L2.10|
;;;262            }   
;;;263        }   
;;;264        for (j=32;j<64;j++) {
000044  2420              MOVS     r4,#0x20
                  |L2.70|
;;;265            for (i=0;i<8;i++) {
000046  2500              MOVS     r5,#0
;;;266                LCD_Write(LCD_COMMAND,0x80+j-32);   
000048  f1040660          ADD      r6,r4,#0x60
                  |L2.76|
00004c  b2f1              UXTB     r1,r6
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       LCD_Write
;;;267                LCD_Write(LCD_COMMAND,0x88+i);   
000054  f1050088          ADD      r0,r5,#0x88
000058  b2c1              UXTB     r1,r0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       LCD_Write
;;;268                LCD_Write(LCD_DATA,0x00);   
000060  2100              MOVS     r1,#0
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       LCD_Write
;;;269                LCD_Write(LCD_DATA,0x00);   
000068  2100              MOVS     r1,#0
00006a  4608              MOV      r0,r1
00006c  f7fffffe          BL       LCD_Write
000070  1c6d              ADDS     r5,r5,#1
000072  b2ed              UXTB     r5,r5                 ;265
000074  2d08              CMP      r5,#8                 ;265
000076  d3e9              BCC      |L2.76|
000078  1c64              ADDS     r4,r4,#1              ;265
00007a  b2e4              UXTB     r4,r4                 ;264
00007c  2c40              CMP      r4,#0x40              ;264
00007e  d3e2              BCC      |L2.70|
;;;270            }   
;;;271        }   
;;;272        LCD_GraphModeSet(0x01);//最后打开图形显示功能   
000080  e8bd4070          POP      {r4-r6,lr}
000084  2001              MOVS     r0,#1
000086  f7ffbffe          B.W      LCD_GraphModeSet
;;;273    }   
;;;274    
                          ENDP


                          AREA ||i.LCD_DisplayString||, CODE, READONLY, ALIGN=1

                  LCD_DisplayString PROC
;;;375    
;;;376    void LCD_DisplayString(int X, int Y,char *ptrt, int len)
000000  b570              PUSH     {r4-r6,lr}
;;;377    {
000002  461d              MOV      r5,r3
000004  4616              MOV      r6,r2
000006  b130              CBZ      r0,|L3.22|
;;;378      int i;
;;;379    
;;;380      switch(X){
000008  2801              CMP      r0,#1
00000a  d007              BEQ      |L3.28|
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L3.34|
000010  2803              CMP      r0,#3
000012  d10b              BNE      |L3.44|
000014  e008              B        |L3.40|
                  |L3.22|
;;;381         case 0:  Y|=0x80;break;
000016  f0410180          ORR      r1,r1,#0x80
00001a  e007              B        |L3.44|
                  |L3.28|
;;;382         case 1:  Y|=0x90;break;
00001c  f0410190          ORR      r1,r1,#0x90
000020  e004              B        |L3.44|
                  |L3.34|
;;;383         case 2:  Y|=0x88;break;
000022  f0410188          ORR      r1,r1,#0x88
000026  e001              B        |L3.44|
                  |L3.40|
;;;384         case 3:  Y|=0x98;break;
000028  f0410198          ORR      r1,r1,#0x98
                  |L3.44|
;;;385         default: break;
;;;386      }
;;;387    
;;;388      LCD_Write(LCD_COMMAND, Y); // set start address of string in text mode 
00002c  b2c9              UXTB     r1,r1
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       LCD_Write
;;;389      for(i=0; i<len; i++){ 
000034  2400              MOVS     r4,#0
000036  e004              B        |L3.66|
                  |L3.56|
;;;390        	LCD_Write(LCD_DATA, ptrt[i]); //
000038  5d31              LDRB     r1,[r6,r4]
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       LCD_Write
000040  1c64              ADDS     r4,r4,#1
                  |L3.66|
000042  42ac              CMP      r4,r5                 ;389
000044  dbf8              BLT      |L3.56|
;;;391      }
;;;392    }
000046  bd70              POP      {r4-r6,pc}
                          ENDP


                          AREA ||i.LCD_GDRAM_AddressSet||, CODE, READONLY, ALIGN=1

                  LCD_GDRAM_AddressSet PROC
;;;127    //*******************************************************************************   
;;;128    void LCD_GDRAM_AddressSet(unsigned char ucGDramAdd)   
000000  b510              PUSH     {r4,lr}
;;;129    {   
000002  4604              MOV      r4,r0
;;;130        LCD_Write(LCD_COMMAND,LCD_EXTEND_FUNCTION);         //扩展指令集   
000004  2134              MOVS     r1,#0x34
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       LCD_Write
;;;131        LCD_Write(LCD_COMMAND,ucGDramAdd);         
00000c  4621              MOV      r1,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2001              MOVS     r0,#1
000014  f7ffbffe          B.W      LCD_Write
;;;132    }   
;;;133    
                          ENDP


                          AREA ||i.LCD_GraphModeSet||, CODE, READONLY, ALIGN=1

                  LCD_GraphModeSet PROC
;;;196    //*****************************************************   
;;;197    void LCD_GraphModeSet(unsigned char Select)   
000000  b510              PUSH     {r4,lr}
;;;198    {   
000002  4604              MOV      r4,r0
;;;199        LCD_Write(LCD_COMMAND,LCD_EXTEND_FUNCTION); //扩展指令集   
000004  2134              MOVS     r1,#0x34
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       LCD_Write
;;;200        if (Select) {
00000c  b10c              CBZ      r4,|L5.18|
;;;201            LCD_Write(LCD_COMMAND,LCD_GRAPH_ON);        //打开绘图模式   
00000e  2136              MOVS     r1,#0x36
000010  e000              B        |L5.20|
                  |L5.18|
;;;202        } else {
;;;203            LCD_Write(LCD_COMMAND,LCD_GRAPH_OFF);       //关闭绘图模式       
000012  2134              MOVS     r1,#0x34
                  |L5.20|
000014  e8bd4010          POP      {r4,lr}
000018  2001              MOVS     r0,#1
00001a  f7ffbffe          B.W      LCD_Write
;;;204        }   
;;;205    }   
;;;206    
                          ENDP


                          AREA ||i.LCD_ImgDisplay||, CODE, READONLY, ALIGN=1

                  LCD_ImgDisplay PROC
;;;227    //*********************************************************************   
;;;228    void LCD_ImgDisplay(unsigned char *img)   
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;229    {   
000004  4606              MOV      r6,r0
;;;230        unsigned char i,j;   
;;;231    
;;;232        LCD_GraphModeSet(0x00); //先关闭图形显示功能   
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       LCD_GraphModeSet
;;;233        for (j=0;j<32;j++) {
00000c  2400              MOVS     r4,#0
                  |L6.14|
;;;234            for (i=0;i<8;i++) {
00000e  2500              MOVS     r5,#0
;;;235                LCD_Write(LCD_COMMAND,0x80+j);      //设定垂直坐标   
000010  f1040980          ADD      r9,r4,#0x80
000014  ea4f1804          LSL      r8,r4,#4
                  |L6.24|
000018  f00901ff          AND      r1,r9,#0xff
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       LCD_Write
;;;236                LCD_Write(LCD_COMMAND,0x80+i);      //设定水平坐标   
000022  f1050080          ADD      r0,r5,#0x80
000026  b2c1              UXTB     r1,r0
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       LCD_Write
;;;237                LCD_Write(LCD_DATA,img[j*16+i*2]);  //放入数据高字节   
00002e  eb080745          ADD      r7,r8,r5,LSL #1
000032  2000              MOVS     r0,#0
000034  5df1              LDRB     r1,[r6,r7]
000036  f7fffffe          BL       LCD_Write
;;;238                LCD_Write(LCD_DATA,img[j*16+i*2+1]);    //放入数据低字节   
00003a  19b8              ADDS     r0,r7,r6
00003c  7841              LDRB     r1,[r0,#1]
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       LCD_Write
000044  1c6d              ADDS     r5,r5,#1
000046  b2ed              UXTB     r5,r5                 ;234
000048  2d08              CMP      r5,#8                 ;234
00004a  d3e5              BCC      |L6.24|
00004c  1c64              ADDS     r4,r4,#1              ;234
00004e  b2e4              UXTB     r4,r4                 ;233
000050  2c20              CMP      r4,#0x20              ;233
000052  d3dc              BCC      |L6.14|
;;;239            }   
;;;240        }   
;;;241        for (j=32;j<64;j++) {
000054  2420              MOVS     r4,#0x20
                  |L6.86|
;;;242            for (i=0;i<8;i++) {
000056  2500              MOVS     r5,#0
;;;243                LCD_Write(LCD_COMMAND,0x80+j-32);   
000058  f1040960          ADD      r9,r4,#0x60
00005c  ea4f1804          LSL      r8,r4,#4
                  |L6.96|
000060  f00901ff          AND      r1,r9,#0xff
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       LCD_Write
;;;244                LCD_Write(LCD_COMMAND,0x88+i);   
00006a  f1050088          ADD      r0,r5,#0x88
00006e  b2c1              UXTB     r1,r0
000070  2001              MOVS     r0,#1
000072  f7fffffe          BL       LCD_Write
;;;245                LCD_Write(LCD_DATA,img[j*16+i*2]);   
000076  eb080745          ADD      r7,r8,r5,LSL #1
00007a  2000              MOVS     r0,#0
00007c  5df1              LDRB     r1,[r6,r7]
00007e  f7fffffe          BL       LCD_Write
;;;246                LCD_Write(LCD_DATA,img[j*16+i*2+1]);   
000082  19b8              ADDS     r0,r7,r6
000084  7841              LDRB     r1,[r0,#1]
000086  2000              MOVS     r0,#0
000088  f7fffffe          BL       LCD_Write
00008c  1c6d              ADDS     r5,r5,#1
00008e  b2ed              UXTB     r5,r5                 ;242
000090  2d08              CMP      r5,#8                 ;242
000092  d3e5              BCC      |L6.96|
000094  1c64              ADDS     r4,r4,#1              ;242
000096  b2e4              UXTB     r4,r4                 ;241
000098  2c40              CMP      r4,#0x40              ;241
00009a  d3dc              BCC      |L6.86|
;;;247            }   
;;;248        }   
;;;249        LCD_GraphModeSet(0x01);//最后打开图形显示功能   
00009c  e8bd47f0          POP      {r4-r10,lr}
0000a0  2001              MOVS     r0,#1
0000a2  f7ffbffe          B.W      LCD_GraphModeSet
;;;250    }   
;;;251    
                          ENDP


                          AREA ||i.LCD_ImgDisplayCharacter||, CODE, READONLY, ALIGN=1

                  LCD_ImgDisplayCharacter PROC
;;;297    //******************************************************************************   
;;;298    void LCD_ImgDisplayCharacter(unsigned char x,unsigned char y,unsigned char *img)   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;299    {   
000004  4605              MOV      r5,r0
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
;;;300        unsigned char i;   
;;;301        LCD_GraphModeSet(0x00);     //先关闭图形显示功能   
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       LCD_GraphModeSet
;;;302        LCD_Write(LCD_COMMAND,LCD_EXTEND_FUNCTION);   
000010  2134              MOVS     r1,#0x34
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       LCD_Write
;;;303        for (i=0;i<16;i++) {
000018  2400              MOVS     r4,#0
00001a  3580              ADDS     r5,r5,#0x80
                  |L7.28|
;;;304            LCD_GDRAM_AddressSet(0x80+y+i);   
00001c  1938              ADDS     r0,r7,r4
00001e  3080              ADDS     r0,r0,#0x80
000020  b2c0              UXTB     r0,r0
000022  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;305            LCD_GDRAM_AddressSet(0x80+x);   
000026  b2e8              UXTB     r0,r5
000028  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;306            LCD_Write(LCD_DATA,img[i*2]);   
00002c  f8161014          LDRB     r1,[r6,r4,LSL #1]
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       LCD_Write
;;;307            LCD_Write(LCD_DATA,img[i*2+1]);   
000036  eb060044          ADD      r0,r6,r4,LSL #1
00003a  7841              LDRB     r1,[r0,#1]
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       LCD_Write
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4                 ;303
000046  2c10              CMP      r4,#0x10              ;303
000048  d3e8              BCC      |L7.28|
;;;308        }   
;;;309        LCD_GraphModeSet(0x01);              //最后打开图形显示功能   
00004a  e8bd41f0          POP      {r4-r8,lr}
00004e  2001              MOVS     r0,#1
000050  f7ffbffe          B.W      LCD_GraphModeSet
;;;310    }   
;;;311    
                          ENDP


                          AREA ||i.LCD_Init||, CODE, READONLY, ALIGN=2

                  LCD_Init PROC
;;;137    //*******************************************   
;;;138    void LCD_Init(void)   
000000  b538              PUSH     {r3-r5,lr}
;;;139    {   
;;;140        GPIO_InitTypeDef     GPIO_InitStructure;
;;;141        RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB, ENABLE );
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;142    
;;;143        GPIO_InitStructure.GPIO_Pin    = GPIO_Pin_12;       // PB12 ==> CS 
00000a  f44f5480          MOV      r4,#0x1000
00000e  f8ad4000          STRH     r4,[sp,#0]
;;;144        GPIO_InitStructure.GPIO_Mode   = GPIO_Mode_Out_PP;  // DO 
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;145        GPIO_InitStructure.GPIO_Speed  = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
;;;146        GPIO_Init(GPIOB, &GPIO_InitStructure);
00001a  4d21              LDR      r5,|L8.160|
00001c  f88d0002          STRB     r0,[sp,#2]            ;145
000020  4669              MOV      r1,sp
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       GPIO_Init
;;;147        GPIO_ResetBits(GPIOB,GPIO_Pin_12);
000028  4621              MOV      r1,r4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       GPIO_ResetBits
;;;148    
;;;149        GPIO_InitStructure.GPIO_Pin    = GPIO_Pin_11;       // PB11 ==> RST 
000030  1064              ASRS     r4,r4,#1
000032  f8ad4000          STRH     r4,[sp,#0]
;;;150        GPIO_Init(GPIOB, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_Init
;;;151        GPIO_SetBits(GPIOB,GPIO_Pin_11);
00003e  4621              MOV      r1,r4
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GPIO_SetBits
;;;152    
;;;153        usrspi2_init(1, 0, 0); // three wire, MSB first, mode = 0       
000046  2200              MOVS     r2,#0
000048  4611              MOV      r1,r2
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       usrspi2_init
;;;154        usrspi2_setspeed(SPI_BaudRatePrescaler_256);  // SPI_BaudRatePrescaler_2); clk PW=0.025us = 28 ns
000050  2038              MOVS     r0,#0x38
000052  f7fffffe          BL       usrspi2_setspeed
;;;155                                                      // 256 clk PW = 4us; 128 = 1.8us ( confirmed!!)
;;;156        LCD_RST = 0;    
000056  4c13              LDR      r4,|L8.164|
000058  2000              MOVS     r0,#0
00005a  f8c401ac          STR      r0,[r4,#0x1ac]
;;;157        delay_ms(100);   
00005e  2064              MOVS     r0,#0x64
000060  f50474d6          ADD      r4,r4,#0x1ac
000064  f7fffffe          BL       delay_ms
;;;158        LCD_RST = 1; // 复位后拉高，停止复位   
000068  2001              MOVS     r0,#1
00006a  6020              STR      r0,[r4,#0]
;;;159        delay_ms(1);   
00006c  f7fffffe          BL       delay_ms
;;;160    	  
;;;161    		LCD_Write(LCD_COMMAND,LCD_BASIC_FUNCTION);       
000070  2130              MOVS     r1,#0x30
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       LCD_Write
;;;162        LCD_Write(LCD_COMMAND,LCD_CLEAR_SCREEN);    //clear AC <= 00H   
000078  2101              MOVS     r1,#1
00007a  4608              MOV      r0,r1
00007c  f7fffffe          BL       LCD_Write
;;;163        LCD_Write(LCD_COMMAND,0x06);                // entry mode: increase !  
000080  2106              MOVS     r1,#6
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       LCD_Write
;;;164        LCD_Write(LCD_COMMAND,0x0C);                // display on   
000088  210c              MOVS     r1,#0xc
00008a  2001              MOVS     r0,#1
00008c  f7fffffe          BL       LCD_Write
;;;165        LCD_Write(LCD_COMMAND,0x80);                // set ddram address <= 0 
000090  2180              MOVS     r1,#0x80
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       LCD_Write
;;;166    
;;;167    		LCD_GraphModeSet(1);	
000098  2001              MOVS     r0,#1
00009a  f7fffffe          BL       LCD_GraphModeSet
;;;168    		
;;;169    }   
00009e  bd38              POP      {r3-r5,pc}
;;;170    
                          ENDP

                  |L8.160|
                          DCD      0x40010c00
                  |L8.164|
                          DCD      0x42218000

                          AREA ||i.LCD_Point||, CODE, READONLY, ALIGN=1

                  LCD_Point PROC
;;;335    //******************************************************************************   
;;;336    void LCD_Point(unsigned char x,unsigned char y,unsigned char color)   
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;337    {   
;;;338        unsigned char i,AddrX,AddrY;    //寄存器地址   
;;;339        unsigned char BitTemp;      //该点在16bit的位置   
;;;340        unsigned char DataH,DataL;   
;;;341    
;;;342        AddrX = x>>4;             // x/16   
000004  0906              LSRS     r6,r0,#4
000006  4692              MOV      r10,r2                ;337
;;;343        AddrY = y&0x3F;             // y%64   
000008  f001053f          AND      r5,r1,#0x3f
;;;344        if (y > 31) {
00000c  291f              CMP      r1,#0x1f
00000e  d902              BLS      |L9.22|
000010  3d20              SUBS     r5,r5,#0x20           ;337
;;;345            AddrX += 8;   
;;;346            AddrY -= 32;   
000012  b2ed              UXTB     r5,r5
000014  3608              ADDS     r6,r6,#8
                  |L9.22|
;;;347        }
;;;348        BitTemp = x&0x0F;           // x%16   
000016  f000080f          AND      r8,r0,#0xf
;;;349    
;;;350        LCD_GraphModeSet(0x00);   
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       LCD_GraphModeSet
;;;351        for (i=0;i<4;i++) {
000020  2700              MOVS     r7,#0
000022  3580              ADDS     r5,r5,#0x80
000024  3680              ADDS     r6,r6,#0x80
                  |L9.38|
;;;352            LCD_GDRAM_AddressSet(0x80+AddrY);   
000026  b2e8              UXTB     r0,r5
000028  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;353            LCD_GDRAM_AddressSet(0x80+AddrX);   
00002c  b2f0              UXTB     r0,r6
00002e  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;354            DataH = LCD_ReadCurrentRam();   
000032  f7fffffe          BL       LCD_ReadCurrentRam
;;;355            DataH = LCD_ReadCurrentRam();   
000036  f7fffffe          BL       LCD_ReadCurrentRam
00003a  4681              MOV      r9,r0
;;;356            DataL = LCD_ReadCurrentRam();   
00003c  f7fffffe          BL       LCD_ReadCurrentRam
000040  1c7f              ADDS     r7,r7,#1
000042  b2ff              UXTB     r7,r7                 ;351
000044  4604              MOV      r4,r0
000046  2f04              CMP      r7,#4                 ;351
000048  d3ed              BCC      |L9.38|
;;;357        }   
;;;358    
;;;359        if (color == LCD_COLOR_BLACK) {
00004a  f1ba0f01          CMP      r10,#1
00004e  d10c              BNE      |L9.106|
;;;360            if (BitTemp > 7) {
;;;361                DataL |= (0x80>>(BitTemp-8));   
000050  2080              MOVS     r0,#0x80
000052  f1b80f07          CMP      r8,#7                 ;360
000056  d904              BLS      |L9.98|
000058  f1a80108          SUB      r1,r8,#8
00005c  40c8              LSRS     r0,r0,r1
00005e  4304              ORRS     r4,r4,r0
000060  e003              B        |L9.106|
                  |L9.98|
;;;362            } else {
;;;363                DataH |= (0x80>>(BitTemp));   
000062  fa20f008          LSR      r0,r0,r8
000066  ea400909          ORR      r9,r0,r9
                  |L9.106|
;;;364            }   
;;;365        }
;;;366        
;;;367        LCD_GDRAM_AddressSet(0x80+AddrY);   
00006a  b2e8              UXTB     r0,r5
00006c  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;368        LCD_GDRAM_AddressSet(0x80+AddrX);   
000070  b2f0              UXTB     r0,r6
000072  f7fffffe          BL       LCD_GDRAM_AddressSet
;;;369        LCD_Write(LCD_DATA,DataH);   
000076  4649              MOV      r1,r9
000078  2000              MOVS     r0,#0
00007a  f7fffffe          BL       LCD_Write
;;;370        LCD_Write(LCD_DATA,DataL);   
00007e  4621              MOV      r1,r4
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       LCD_Write
;;;371    
;;;372        LCD_GraphModeSet(0x01); 
000086  e8bd47f0          POP      {r4-r10,lr}
00008a  2001              MOVS     r0,#1
00008c  f7ffbffe          B.W      LCD_GraphModeSet
;;;373        // 
;;;374    }   
;;;375    
                          ENDP


                          AREA ||i.LCD_ReadCurrentRam||, CODE, READONLY, ALIGN=2

                  LCD_ReadCurrentRam PROC
;;;100    
;;;101    static unsigned char LCD_ReadCurrentRam(  )   
000000  b570              PUSH     {r4-r6,lr}
;;;102    {    
;;;103      unsigned char temp;   
;;;104      temp = 0xfe;
;;;105    
;;;106      LCD_CS = 1;	  
000002  4d0a              LDR      r5,|L10.44|
000004  24fe              MOVS     r4,#0xfe              ;104
000006  2001              MOVS     r0,#1
000008  f8c501b0          STR      r0,[r5,#0x1b0]
;;;107      delay_us(72);   // 72 us
00000c  2048              MOVS     r0,#0x48
00000e  f50575d8          ADD      r5,r5,#0x1b0
000012  f7fffffe          BL       delay_us
;;;108      usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);// send SPI frame   
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       usrspi2_SendByte3Wire
;;;109      temp = usrspi2_ReadByte3Wire(); 
00001c  f7fffffe          BL       usrspi2_ReadByte3Wire
;;;110    	delay_us(72);   // 72 us
000020  2048              MOVS     r0,#0x48
000022  f7fffffe          BL       delay_us
;;;111      LCD_CS = 0;	  
000026  2000              MOVS     r0,#0
000028  6028              STR      r0,[r5,#0]
;;;112    
;;;113    }   
00002a  bd70              POP      {r4-r6,pc}
;;;114    
                          ENDP

                  |L10.44|
                          DCD      0x42218000

                          AREA ||i.LCD_Write||, CODE, READONLY, ALIGN=2

                  LCD_Write PROC
;;;39     //************************************************************************************   
;;;40     static void LCD_Write( unsigned char command , unsigned char uc_Content )   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;41     {    
;;;42       unsigned char temp;   
;;;43     
;;;44       LCD_CS = 1;	  
000004  4e1b              LDR      r6,|L11.116|
000006  0005              MOVS     r5,r0                 ;41
000008  f04f0001          MOV      r0,#1
00000c  460c              MOV      r4,r1                 ;41
00000e  f8c601b0          STR      r0,[r6,#0x1b0]
;;;45     
;;;46       if ( command && uc_Content==0x01)
;;;47     		delay_us(1600); // 1.6ms 
000012  f44f67c8          MOV      r7,#0x640
000016  d009              BEQ      |L11.44|
000018  2c01              CMP      r4,#1                 ;46
00001a  d005              BEQ      |L11.40|
;;;48     	else 
;;;49     		delay_us(72);   // 72 us
00001c  f05f0048          MOVS.W   r0,#0x48
                  |L11.32|
000020  f7fffffe          BL       delay_us
;;;50     	
;;;51       if (command) {
;;;52         temp = 0xFA;    //RS = 1, data  RW = 0, write mode   
000024  20fa              MOVS     r0,#0xfa
000026  e005              B        |L11.52|
                  |L11.40|
000028  4638              MOV      r0,r7                 ;47
00002a  e7f9              B        |L11.32|
                  |L11.44|
00002c  2048              MOVS     r0,#0x48              ;49
00002e  f7fffffe          BL       delay_us
;;;53       } else {
;;;54         temp = 0xF8;    //RS = 0, command  RW = 0, write mode    
000032  20f8              MOVS     r0,#0xf8
                  |L11.52|
;;;55       }   
;;;56       usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);// send SPI frame 
000034  f7fffffe          BL       usrspi2_SendByte3Wire
;;;57     	
;;;58       temp = uc_Content&0xF0;   
000038  f00400f0          AND      r0,r4,#0xf0
;;;59       usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);   
00003c  f7fffffe          BL       usrspi2_SendByte3Wire
000040  0720              LSLS     r0,r4,#28
;;;60     	
;;;61       temp = (uc_Content<<4)&0xF0;   
000042  0e00              LSRS     r0,r0,#24
;;;62       usrspi2_SendByte3Wire  (temp); //LCD_SendByte(temp);   
000044  f7fffffe          BL       usrspi2_SendByte3Wire
;;;63     	
;;;64     
;;;65       if ( command && uc_Content==0x01)
000048  b10d              CBZ      r5,|L11.78|
00004a  2c01              CMP      r4,#1
00004c  d00d              BEQ      |L11.106|
                  |L11.78|
;;;66     		delay_us(1600); // 1.6ms 
;;;67     	else 
;;;68     		delay_us(72);   // 72 us
00004e  2048              MOVS     r0,#0x48
                  |L11.80|
000050  f7fffffe          BL       delay_us
;;;69     
;;;70     	LCD_CS = 0;
000054  2000              MOVS     r0,#0
000056  f8c601b0          STR      r0,[r6,#0x1b0]
00005a  b10d              CBZ      r5,|L11.96|
;;;71     
;;;72       if ( command && uc_Content==0x01)
00005c  2c01              CMP      r4,#1
00005e  d006              BEQ      |L11.110|
                  |L11.96|
;;;73     		delay_us(1600); // 1.6ms 
;;;74     	else 
;;;75     		delay_us(72);   // 72 us
000060  2048              MOVS     r0,#0x48
                  |L11.98|
000062  e8bd41f0          POP      {r4-r8,lr}
000066  f7ffbffe          B.W      delay_us
                  |L11.106|
00006a  4638              MOV      r0,r7                 ;66
00006c  e7f0              B        |L11.80|
                  |L11.110|
00006e  4638              MOV      r0,r7                 ;73
000070  e7f7              B        |L11.98|
;;;76     }   
;;;77     
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
                          DCD      0x42218000
