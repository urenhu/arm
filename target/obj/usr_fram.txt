; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usr_fram.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\usr_fram.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usr_fram.crf ..\usr_lib\usr_fram.c]
                          THUMB

                          AREA ||i.usr_fram_init||, CODE, READONLY, ALIGN=2

                  usr_fram_init PROC
;;;12     
;;;13     void usr_fram_init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;14     {   
;;;15         GPIO_InitTypeDef     GPIO_InitStructure;
;;;16         RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOG, ENABLE );
000002  2101              MOVS     r1,#1
000004  f44f7094          MOV      r0,#0x128
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;17     
;;;18         GPIO_InitStructure.GPIO_Pin    = GPIO_Pin_12;       // PB12 ==> CS 
00000c  f44f5480          MOV      r4,#0x1000
000010  f8ad4000          STRH     r4,[sp,#0]
;;;19         GPIO_InitStructure.GPIO_Mode   = GPIO_Mode_Out_PP;  // DO 
000014  2010              MOVS     r0,#0x10
000016  f88d0003          STRB     r0,[sp,#3]
;;;20         GPIO_InitStructure.GPIO_Speed  = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
;;;21         GPIO_Init(GPIOB, &GPIO_InitStructure);
00001c  4d09              LDR      r5,|L1.68|
00001e  f88d0002          STRB     r0,[sp,#2]            ;20
000022  4669              MOV      r1,sp
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       GPIO_Init
;;;22         GPIO_SetBits(GPIOB,GPIO_Pin_12);
00002a  4621              MOV      r1,r4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       GPIO_SetBits
;;;23     
;;;24         usrspi2_init(0,0,3);        
000032  2100              MOVS     r1,#0
000034  2203              MOVS     r2,#3
000036  4608              MOV      r0,r1
000038  f7fffffe          BL       usrspi2_init
;;;25         usrspi2_setspeed(SPI_BaudRatePrescaler_2);
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       usrspi2_setspeed
;;;26     }  
000042  bd38              POP      {r3-r5,pc}
;;;27     
                          ENDP

                  |L1.68|
                          DCD      0x40010c00

                          AREA ||i.usr_fram_read||, CODE, READONLY, ALIGN=2

                  usr_fram_read PROC
;;;61     
;;;62     void usr_fram_read  (u8* pBuffer, u16 len, u16 adr )   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;63     { 
;;;64         u16 i;                                                      
;;;65         FRAM_CS=0;   // enable chip selection                         
000004  4e0f              LDR      r6,|L2.68|
000006  4607              MOV      r7,r0                 ;63
000008  2000              MOVS     r0,#0
00000a  4614              MOV      r4,r2                 ;63
00000c  460d              MOV      r5,r1                 ;63
00000e  f8c601b0          STR      r0,[r6,#0x1b0]
;;;66         usrspi2_WriteReadAByte(FRAM_READ_DATA);         
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       usrspi2_WriteReadAByte
;;;67         //usrspi2_WriteReadAByte((u8)((adr)>>16));      
;;;68         usrspi2_WriteReadAByte((u8)((adr)>>8));   
000018  0a20              LSRS     r0,r4,#8
00001a  f7fffffe          BL       usrspi2_WriteReadAByte
;;;69         usrspi2_WriteReadAByte((u8)adr);   
00001e  b2e0              UXTB     r0,r4
000020  f7fffffe          BL       usrspi2_WriteReadAByte
;;;70         for (i=0;i<len;i++) {
000024  2400              MOVS     r4,#0
000026  e005              B        |L2.52|
                  |L2.40|
;;;71             pBuffer[i]=usrspi2_WriteReadAByte(0XFF);   
000028  20ff              MOVS     r0,#0xff
00002a  f7fffffe          BL       usrspi2_WriteReadAByte
00002e  5538              STRB     r0,[r7,r4]
000030  1c64              ADDS     r4,r4,#1
000032  b2a4              UXTH     r4,r4                 ;70
                  |L2.52|
000034  42ac              CMP      r4,r5                 ;70
000036  d3f7              BCC      |L2.40|
;;;72         }
;;;73         FRAM_CS=1;                                    
000038  2001              MOVS     r0,#1
00003a  f8c601b0          STR      r0,[r6,#0x1b0]
;;;74     }  
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;75     
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x42218000

                          AREA ||i.usr_fram_read_sr||, CODE, READONLY, ALIGN=2

                  usr_fram_read_sr PROC
;;;27     
;;;28     u8   usr_fram_read_sr (void)
000000  b510              PUSH     {r4,lr}
;;;29     {  
;;;30         u8 byte=0;
;;;31     
;;;32         FRAM_CS = 0;                           
000002  4c07              LDR      r4,|L3.32|
000004  2000              MOVS     r0,#0
000006  f8c401b0          STR      r0,[r4,#0x1b0]
;;;33         usrspi2_WriteReadAByte(FRAM_READ_SR);
00000a  2005              MOVS     r0,#5
00000c  f50474d8          ADD      r4,r4,#0x1b0
000010  f7fffffe          BL       usrspi2_WriteReadAByte
;;;34         byte=usrspi2_WriteReadAByte(0Xff); // any dammy data, as it is for clock generating !!!!            
000014  20ff              MOVS     r0,#0xff
000016  f7fffffe          BL       usrspi2_WriteReadAByte
;;;35         FRAM_CS =1;                           
00001a  2101              MOVS     r1,#1
00001c  6021              STR      r1,[r4,#0]
;;;36     
;;;37         return byte;   
;;;38     } 
00001e  bd10              POP      {r4,pc}
;;;39     
                          ENDP

                  |L3.32|
                          DCD      0x42218000

                          AREA ||i.usr_fram_wait_busy||, CODE, READONLY, ALIGN=2

                  usr_fram_wait_busy PROC
;;;93     
;;;94     void usr_fram_wait_busy(void)   
000000  e92d4010          PUSH.W   {r4,lr}
                  |L4.4|
;;;95     {   
;;;96         while ((usr_fram_read_sr()&0x01)==0x01);   
000004  f7fffffe          BL       usr_fram_read_sr
000008  07c0              LSLS     r0,r0,#31
00000a  d1fb              BNE      |L4.4|
;;;97     }  
00000c  bd10              POP      {r4,pc}
;;;98     
                          ENDP


                          AREA ||i.usr_fram_write||, CODE, READONLY, ALIGN=2

                  usr_fram_write PROC
;;;75     
;;;76     void usr_fram_write  (u8* pBuffer, u16 len, u16 adr )   
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;77     { 
000004  4c19              LDR      r4,|L5.108|
000006  2500              MOVS     r5,#0
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  4681              MOV      r9,r0
00000e  f8c451b0          STR      r5,[r4,#0x1b0]
000012  2006              MOVS     r0,#6
000014  f50474d8          ADD      r4,r4,#0x1b0
000018  f7fffffe          BL       usrspi2_WriteReadAByte
00001c  f04f0801          MOV      r8,#1
000020  f8c48000          STR      r8,[r4,#0]
;;;78         u16 i;                                                      
;;;79         usr_fram_write_enable();         
;;;80     	
;;;81         FRAM_CS=0;   // enable chip selection             
000024  6025              STR      r5,[r4,#0]
;;;82         usrspi2_WriteReadAByte(FRAM_WRITE_DATA);         
000026  2002              MOVS     r0,#2
000028  f5a474d8          SUB      r4,r4,#0x1b0
00002c  f7fffffe          BL       usrspi2_WriteReadAByte
;;;83         //usrspi2_WriteReadAByte((u8)((adr)>>16));      
;;;84         usrspi2_WriteReadAByte((u8)((adr)>>8));   
000030  0a30              LSRS     r0,r6,#8
000032  f7fffffe          BL       usrspi2_WriteReadAByte
;;;85         usrspi2_WriteReadAByte((u8)adr);   
000036  b2f0              UXTB     r0,r6
000038  f7fffffe          BL       usrspi2_WriteReadAByte
;;;86         for (i=0;i<len;i++) {
00003c  2600              MOVS     r6,#0
00003e  e005              B        |L5.76|
                  |L5.64|
;;;87             usrspi2_WriteReadAByte(pBuffer[i]);   
000040  f8190006          LDRB     r0,[r9,r6]
000044  f7fffffe          BL       usrspi2_WriteReadAByte
000048  1c76              ADDS     r6,r6,#1
00004a  b2b6              UXTH     r6,r6                 ;86
                  |L5.76|
00004c  42be              CMP      r6,r7                 ;86
00004e  d3f7              BCC      |L5.64|
;;;88         }
;;;89      	FRAM_CS=1;                                    
000050  4646              MOV      r6,r8
000052  f8c481b0          STR      r8,[r4,#0x1b0]
000056  f8c451b0          STR      r5,[r4,#0x1b0]
00005a  2004              MOVS     r0,#4
00005c  f50474d8          ADD      r4,r4,#0x1b0
000060  f7fffffe          BL       usrspi2_WriteReadAByte
000064  6026              STR      r6,[r4,#0]
;;;90     
;;;91     	usr_fram_write_disable();         
;;;92     }
000066  e8bd87f0          POP      {r4-r10,pc}
;;;93     
                          ENDP

00006a  0000              DCW      0x0000
                  |L5.108|
                          DCD      0x42218000

                          AREA ||i.usr_fram_write_sr||, CODE, READONLY, ALIGN=2

                  usr_fram_write_sr PROC
;;;39     
;;;40     void usr_fram_write_sr(u8 sr)   
000000  b570              PUSH     {r4-r6,lr}
;;;41     {   
;;;42         FRAM_CS=0;    
000002  4c08              LDR      r4,|L6.36|
000004  4605              MOV      r5,r0                 ;41
000006  2000              MOVS     r0,#0
000008  f8c401b0          STR      r0,[r4,#0x1b0]
;;;43         usrspi2_WriteReadAByte(FRAM_WRITE_SR);
00000c  2001              MOVS     r0,#1
00000e  f50474d8          ADD      r4,r4,#0x1b0
000012  f7fffffe          BL       usrspi2_WriteReadAByte
;;;44         usrspi2_WriteReadAByte(sr);                
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       usrspi2_WriteReadAByte
;;;45         FRAM_CS=1;    
00001c  2001              MOVS     r0,#1
00001e  6020              STR      r0,[r4,#0]
;;;46     }   
000020  bd70              POP      {r4-r6,pc}
;;;47     
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x42218000
