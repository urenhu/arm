; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\port.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\port.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\port.crf ..\free_rtos\port.c]
                          THUMB

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=1

                  pxPortInitialiseStack PROC
;;;178     */
;;;179    portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181    	/* Simulate the stack frame as it would be created by a context switch
;;;182    	interrupt. */
;;;183    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
000002  1f03              SUBS     r3,r0,#4
;;;184    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000004  f04f7480          MOV      r4,#0x1000000
;;;185    	pxTopOfStack--;
;;;186    	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
;;;187    	pxTopOfStack--;
;;;188    	*pxTopOfStack = 0;	/* LR */
;;;189    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;190    	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
;;;191    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;192    
;;;193    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  6019              STR      r1,[r3,#0]
00000e  1f19              SUBS     r1,r3,#4
000010  2300              MOVS     r3,#0                 ;188
000012  600b              STR      r3,[r1,#0]
000014  3914              SUBS     r1,r1,#0x14
000016  3840              SUBS     r0,r0,#0x40           ;190
000018  600a              STR      r2,[r1,#0]            ;190
;;;194    }
00001a  bd10              POP      {r4,pc}
;;;195    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=1

                  vPortEndScheduler PROC
;;;254    
;;;255    void vPortEndScheduler( void )
000000  4770              BX       lr
;;;256    {
;;;257    	/* It is unlikely that the CM3 port will require this function as there
;;;258    	is nothing to return to.  */
;;;259    }
;;;260    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;273    
;;;274    void vPortEnterCritical( void )
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276    	portDISABLE_INTERRUPTS();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;277    	uxCriticalNesting++;
000006  4804              LDR      r0,|L3.24|
000008  6801              LDR      r1,[r0,#0]  ; uxCriticalNesting
00000a  1c49              ADDS     r1,r1,#1
;;;278    	__dsb( portSY_FULL_READ_WRITE );
00000c  6001              STR      r1,[r0,#0]  ; uxCriticalNesting
00000e  f3bf8f4f          DSB      
;;;279    	__isb( portSY_FULL_READ_WRITE );
000012  f3bf8f6f          ISB      
;;;280    }
000016  bd10              POP      {r4,pc}
;;;281    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.24|
                          DCD      ||.data||

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;282    
;;;283    void vPortExitCritical( void )
000000  4903              LDR      r1,|L4.16|
;;;284    {
;;;285    	uxCriticalNesting--;
000002  6808              LDR      r0,[r1,#0]  ; uxCriticalNesting
000004  1e40              SUBS     r0,r0,#1
000006  6008              STR      r0,[r1,#0]            ;284  ; uxCriticalNesting
000008  d101              BNE      |L4.14|
;;;286    	if( uxCriticalNesting == 0 )
;;;287    	{
;;;288    		portENABLE_INTERRUPTS();
00000a  f7ffbffe          B.W      vPortClearInterruptMask
                  |L4.14|
;;;289    	}
;;;290    }
00000e  4770              BX       lr
;;;291    /*-----------------------------------------------------------*/
                          ENDP

                  |L4.16|
                          DCD      ||.data||

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;485    
;;;486    	void vPortSetupTimerInterrupt( void )
000000  f04f20e0          MOV      r0,#0xe000e000
;;;487    	{
;;;488    		/* Calculate the constants required to configure the tick interrupt. */
;;;489    		#if configUSE_TICKLESS_IDLE == 1
;;;490    		{
;;;491    			ulTimerReloadValueForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
;;;492    			xMaximumPossibleSuppressedTicks = 0xffffffUL / ( ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL );
;;;493    			ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;494    		}
;;;495    		#endif /* configUSE_TICKLESS_IDLE */
;;;496    
;;;497    		/* Configure SysTick to interrupt at the requested rate. */
;;;498    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
000004  4902              LDR      r1,|L5.16|
000006  6141              STR      r1,[r0,#0x14]
;;;499    		portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
000008  2107              MOVS     r1,#7
00000a  6101              STR      r1,[r0,#0x10]
;;;500    	}
00000c  4770              BX       lr
;;;501    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x0001193f

                          AREA ||i.vPortYield||, CODE, READONLY, ALIGN=2

                  vPortYield PROC
;;;261    
;;;262    void vPortYield( void )
000000  4904              LDR      r1,|L6.20|
;;;263    {
;;;264    	/* Set a PendSV to request a context switch. */
;;;265    	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000002  f04f5080          MOV      r0,#0x10000000
000006  6008              STR      r0,[r1,#0]
;;;266    
;;;267    	/* Barriers are normally not required but do ensure the code is completely
;;;268    	within the specified behaviour for the architecture. */
;;;269    	__dsb( portSY_FULL_READ_WRITE );
000008  f3bf8f4f          DSB      
;;;270    	__isb( portSY_FULL_READ_WRITE );
00000c  f3bf8f6f          ISB      
;;;271    }
000010  4770              BX       lr
;;;272    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0xe000ed04

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;233     */
;;;234    portBASE_TYPE xPortStartScheduler( void )
000000  4809              LDR      r0,|L7.40|
;;;235    {
000002  b510              PUSH     {r4,lr}
;;;236    	/* Make PendSV, CallSV and SysTick the same priority as the kernel. */
;;;237    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000004  6801              LDR      r1,[r0,#0]
000006  f441017f          ORR      r1,r1,#0xff0000
00000a  6001              STR      r1,[r0,#0]
;;;238    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00000c  6801              LDR      r1,[r0,#0]
00000e  f041417f          ORR      r1,r1,#0xff000000
000012  6001              STR      r1,[r0,#0]
;;;239    
;;;240    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;241    	here already. */
;;;242    	vPortSetupTimerInterrupt();
000014  f7fffffe          BL       vPortSetupTimerInterrupt
;;;243    
;;;244    	/* Initialise the critical nesting count ready for the first task. */
;;;245    	uxCriticalNesting = 0;
000018  4904              LDR      r1,|L7.44|
00001a  2000              MOVS     r0,#0
;;;246    
;;;247    	/* Start the first task. */
;;;248    	prvStartFirstTask();
00001c  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
00001e  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;249    
;;;250    	/* Should not get here! */
;;;251    	return 0;
000022  2000              MOVS     r0,#0
;;;252    }
000024  bd10              POP      {r4,pc}
;;;253    /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0xe000ed20
                  |L7.44|
                          DCD      ||.data||

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;325    
;;;326    void xPortSysTickHandler( void )
000000  4906              LDR      r1,|L8.28|
;;;327    {
000002  b510              PUSH     {r4,lr}
;;;328    	#if configUSE_PREEMPTION == 1
;;;329    	{
;;;330    		/* If using preemption, also force a context switch. */
;;;331    		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000004  f04f5080          MOV      r0,#0x10000000
000008  6008              STR      r0,[r1,#0]
;;;332    	}
;;;333    	#endif
;;;334    
;;;335    	/* Only reset the systick load register if configUSE_TICKLESS_IDLE is set to
;;;336    	1.  If it is set to 0 tickless idle is not being used.  If it is set to a
;;;337    	value other than 0 or 1 then a timer other than the SysTick is being used
;;;338    	to generate the tick interrupt. */
;;;339    	#if configUSE_TICKLESS_IDLE == 1
;;;340    		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
;;;341    	#endif
;;;342    
;;;343    	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
00000a  f7fffffe          BL       ulPortSetInterruptMask
;;;344    	{
;;;345    		vTaskIncrementTick();
00000e  f7fffffe          BL       vTaskIncrementTick
;;;346    	}
;;;347    	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
000012  e8bd4010          POP      {r4,lr}
000016  2000              MOVS     r0,#0
000018  f7ffbffe          B.W      vPortClearInterruptMask
;;;348    }
;;;349    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.28|
                          DCD      0xe000ed04

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\free_rtos\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortSVCHandler|
#line 197
|vPortSVCHandler| PROC
#line 198

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 213
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 214

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]
 
 msr msp, r0
 
 cpsie i
 
 svc 0
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |xPortPendSVHandler|
#line 293
|xPortPendSVHandler| PROC
#line 294

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #191
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 505
|ulPortSetInterruptMask| PROC
#line 506

 PRESERVE8

 mrs r0, basepri
 mov r1, #191
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 516
|vPortClearInterruptMask| PROC
#line 517

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP

;*** End   embedded assembler ***
