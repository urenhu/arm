; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\queue_1.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\queue_1.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I..\cmsis -I..\main -I..\usr_lib -I..\ctt -I..\sensor -I..\free_rtos -I..\STM32F10x_StdPeriph -I..\STM32F10x_StdPeriph\inc -IC:\project\diy-project\stm32fxx\stm32_glcd_base\target\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\queue_1.crf ..\free_rtos\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;1337   
;;;1338   static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
000000  b430              PUSH     {r4,r5}
;;;1339   {
000002  6803              LDR      r3,[r0,#0]
000004  460d              MOV      r5,r1
000006  2b00              CMP      r3,#0
000008  d00c              BEQ      |L1.36|
;;;1340   	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
;;;1341   	{
;;;1342   		pxQueue->pcReadFrom += pxQueue->uxItemSize;
00000a  6c02              LDR      r2,[r0,#0x40]
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  188c              ADDS     r4,r1,r2
;;;1343   		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
000010  60c4              STR      r4,[r0,#0xc]
000012  6841              LDR      r1,[r0,#4]
000014  428c              CMP      r4,r1
000016  d300              BCC      |L1.26|
;;;1344   		{
;;;1345   			pxQueue->pcReadFrom = pxQueue->pcHead;
000018  60c3              STR      r3,[r0,#0xc]
                  |L1.26|
;;;1346   		}
;;;1347   		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( size_t ) pxQueue->uxItemSize );
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  4628              MOV      r0,r5
00001e  bc30              POP      {r4,r5}
000020  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.36|
;;;1348   	}
;;;1349   }
000024  bc30              POP      {r4,r5}
000026  4770              BX       lr
;;;1350   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;1299   
;;;1300   static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
000000  b510              PUSH     {r4,lr}
;;;1301   {
000002  4613              MOV      r3,r2
000004  6c02              LDR      r2,[r0,#0x40]
000006  4604              MOV      r4,r0
000008  b16a              CBZ      r2,|L2.38|
;;;1302   	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
;;;1303   	{
;;;1304   		#if ( configUSE_MUTEXES == 1 )
;;;1305   		{
;;;1306   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1307   			{
;;;1308   				/* The mutex is no longer being held. */
;;;1309   				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1310   				pxQueue->pxMutexHolder = NULL;
;;;1311   			}
;;;1312   		}
;;;1313   		#endif
;;;1314   	}
;;;1315   	else if( xPosition == queueSEND_TO_BACK )
00000a  b183              CBZ      r3,|L2.46|
;;;1316   	{
;;;1317   		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
;;;1318   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;1319   		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
;;;1320   		{
;;;1321   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;1322   		}
;;;1323   	}
;;;1324   	else
;;;1325   	{
;;;1326   		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  f7fffffe          BL       __aeabi_memcpy
;;;1327   		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
000012  68e1              LDR      r1,[r4,#0xc]
000014  6c20              LDR      r0,[r4,#0x40]
000016  1a09              SUBS     r1,r1,r0
;;;1328   		if( pxQueue->pcReadFrom < pxQueue->pcHead )
000018  60e1              STR      r1,[r4,#0xc]
00001a  6822              LDR      r2,[r4,#0]
00001c  4291              CMP      r1,r2
00001e  d202              BCS      |L2.38|
;;;1329   		{
;;;1330   			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000020  6861              LDR      r1,[r4,#4]
000022  1a08              SUBS     r0,r1,r0
000024  60e0              STR      r0,[r4,#0xc]
                  |L2.38|
;;;1331   		}
;;;1332   	}
;;;1333   
;;;1334   	++( pxQueue->uxMessagesWaiting );
000026  6ba0              LDR      r0,[r4,#0x38]
000028  1c40              ADDS     r0,r0,#1
00002a  63a0              STR      r0,[r4,#0x38]
;;;1335   }
00002c  bd10              POP      {r4,pc}
                  |L2.46|
00002e  68a0              LDR      r0,[r4,#8]            ;1317
000030  f7fffffe          BL       __aeabi_memcpy
000034  6c21              LDR      r1,[r4,#0x40]         ;1318
000036  68a0              LDR      r0,[r4,#8]            ;1318
000038  4408              ADD      r0,r0,r1              ;1318
00003a  60a0              STR      r0,[r4,#8]            ;1319
00003c  6861              LDR      r1,[r4,#4]            ;1319
00003e  4288              CMP      r0,r1                 ;1319
000040  d3f1              BCC      |L2.38|
000042  6820              LDR      r0,[r4,#0]            ;1321
000044  60a0              STR      r0,[r4,#8]            ;1321
000046  e7ee              B        |L2.38|
;;;1336   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;1351   
;;;1352   static void prvUnlockQueue( xQUEUE *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1353   {
000002  4604              MOV      r4,r0
;;;1354   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1355   
;;;1356   	/* The lock counts contains the number of extra data items placed or
;;;1357   	removed from the queue while the queue was locked.  When a queue is
;;;1358   	locked items can be added or removed, but the event lists cannot be
;;;1359   	updated. */
;;;1360   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1361   	{
;;;1362   		/* See if data was added to the queue while it was locked. */
;;;1363   		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
;;;1364   		{
;;;1365   			/* Data was posted while the queue was locked.  Are any tasks
;;;1366   			blocked waiting for data to become available? */
;;;1367   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1368   			{
;;;1369   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1370   				{
;;;1371   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
;;;1372   					{
;;;1373   						/* The queue is a member of a queue set, and posting to
;;;1374   						the queue set caused a higher priority task to unblock.
;;;1375   						A context switch is required. */
;;;1376   						vTaskMissedYield();
;;;1377   					}
;;;1378   				}
;;;1379   				else
;;;1380   				{
;;;1381   					/* Tasks that are removed from the event list will get added to
;;;1382   					the pending ready list as the scheduler is still suspended. */
;;;1383   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1384   					{
;;;1385   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1386   						{
;;;1387   							/* The task waiting has a higher priority so record that a
;;;1388   							context	switch is required. */
;;;1389   							vTaskMissedYield();
;;;1390   						}
;;;1391   					}
;;;1392   					else
;;;1393   					{
;;;1394   						break;
;;;1395   					}
;;;1396   				}
;;;1397   			}
;;;1398   			#else /* configUSE_QUEUE_SETS */
;;;1399   			{
;;;1400   				/* Tasks that are removed from the event list will get added to
;;;1401   				the pending ready list as the scheduler is still suspended. */
;;;1402   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1403   				{
;;;1404   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000008  f1040524          ADD      r5,r4,#0x24
00000c  e00a              B        |L3.36|
                  |L3.14|
00000e  6a60              LDR      r0,[r4,#0x24]         ;1402
000010  b158              CBZ      r0,|L3.42|
000012  4628              MOV      r0,r5                 ;1402
000014  f7fffffe          BL       xTaskRemoveFromEventList
000018  b108              CBZ      r0,|L3.30|
;;;1405   					{
;;;1406   						/* The task waiting has a higher priority so record that a
;;;1407   						context	switch is required. */
;;;1408   						vTaskMissedYield();
00001a  f7fffffe          BL       vTaskMissedYield
                  |L3.30|
;;;1409   					}
;;;1410   				}
;;;1411   				else
;;;1412   				{
;;;1413   					break;
;;;1414   				}
;;;1415   			}
;;;1416   			#endif /* configUSE_QUEUE_SETS */
;;;1417   
;;;1418   			--( pxQueue->xTxLock );
00001e  6ca0              LDR      r0,[r4,#0x48]
000020  1e40              SUBS     r0,r0,#1
000022  64a0              STR      r0,[r4,#0x48]
                  |L3.36|
000024  6ca0              LDR      r0,[r4,#0x48]         ;1363
000026  2800              CMP      r0,#0                 ;1363
000028  dcf1              BGT      |L3.14|
                  |L3.42|
;;;1419   		}
;;;1420   
;;;1421   		pxQueue->xTxLock = queueUNLOCKED;
00002a  f04f36ff          MOV      r6,#0xffffffff
00002e  64a6              STR      r6,[r4,#0x48]
;;;1422   	}
;;;1423   	taskEXIT_CRITICAL();
000030  f7fffffe          BL       vPortExitCritical
;;;1424   
;;;1425   	/* Do the same for the Rx lock. */
;;;1426   	taskENTER_CRITICAL();
000034  f7fffffe          BL       vPortEnterCritical
;;;1427   	{
;;;1428   		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
;;;1429   		{
;;;1430   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1431   			{
;;;1432   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000038  f1040510          ADD      r5,r4,#0x10
00003c  e00a              B        |L3.84|
                  |L3.62|
00003e  6920              LDR      r0,[r4,#0x10]         ;1430
000040  b158              CBZ      r0,|L3.90|
000042  4628              MOV      r0,r5                 ;1430
000044  f7fffffe          BL       xTaskRemoveFromEventList
000048  b108              CBZ      r0,|L3.78|
;;;1433   				{
;;;1434   					vTaskMissedYield();
00004a  f7fffffe          BL       vTaskMissedYield
                  |L3.78|
;;;1435   				}
;;;1436   
;;;1437   				--( pxQueue->xRxLock );
00004e  6c60              LDR      r0,[r4,#0x44]
000050  1e40              SUBS     r0,r0,#1
000052  6460              STR      r0,[r4,#0x44]
                  |L3.84|
000054  6c60              LDR      r0,[r4,#0x44]         ;1428
000056  2800              CMP      r0,#0                 ;1428
000058  dcf1              BGT      |L3.62|
                  |L3.90|
;;;1438   			}
;;;1439   			else
;;;1440   			{
;;;1441   				break;
;;;1442   			}
;;;1443   		}
;;;1444   
;;;1445   		pxQueue->xRxLock = queueUNLOCKED;
00005a  6466              STR      r6,[r4,#0x44]
;;;1446   	}
;;;1447   	taskEXIT_CRITICAL();
00005c  e8bd4070          POP      {r4-r6,lr}
000060  f7ffbffe          B.W      vPortExitCritical
;;;1448   }
;;;1449   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1225   
;;;1226   unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
000000  b510              PUSH     {r4,lr}
;;;1227   {
000002  4604              MOV      r4,r0
;;;1228   unsigned portBASE_TYPE uxReturn;
;;;1229   
;;;1230   	configASSERT( xQueue );
;;;1231   
;;;1232   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1233   		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
000008  6ba4              LDR      r4,[r4,#0x38]
;;;1234   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1235   
;;;1236   	return uxReturn;
00000e  4620              MOV      r0,r4
;;;1237   }
000010  bd10              POP      {r4,pc}
;;;1238   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1239   
;;;1240   unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;1241   {
;;;1242   unsigned portBASE_TYPE uxReturn;
;;;1243   
;;;1244   	configASSERT( xQueue );
;;;1245   
;;;1246   	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
;;;1247   
;;;1248   	return uxReturn;
;;;1249   }
000002  4770              BX       lr
;;;1250   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1251   
;;;1252   void vQueueDelete( xQueueHandle xQueue )
000000  b510              PUSH     {r4,lr}
;;;1253   {
;;;1254   xQUEUE *pxQueue;
;;;1255   
;;;1256   	pxQueue = ( xQUEUE * ) xQueue;
000002  4604              MOV      r4,r0
;;;1257   	configASSERT( pxQueue );
;;;1258   
;;;1259   	traceQUEUE_DELETE( pxQueue );
;;;1260   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1261   	{
;;;1262   		prvQueueUnregisterQueue( pxQueue );
;;;1263   	}
;;;1264   	#endif
;;;1265   	vPortFree( pxQueue->pcHead );
000004  6800              LDR      r0,[r0,#0]
000006  f7fffffe          BL       vPortFree
;;;1266   	vPortFree( pxQueue );
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      vPortFree
;;;1267   }
;;;1268   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;281    
;;;282    xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;283    {
000004  460f              MOV      r7,r1
000006  0005              MOVS     r5,r0
;;;284    xQUEUE *pxNewQueue;
;;;285    size_t xQueueSizeInBytes;
;;;286    xQueueHandle xReturn = NULL;
000008  f04f0600          MOV      r6,#0
00000c  d016              BEQ      |L7.60|
;;;287    
;;;288    	/* Remove compiler warnings about unused parameters should
;;;289    	configUSE_TRACE_FACILITY not be set to 1. */
;;;290    	( void ) ucQueueType;
;;;291    
;;;292    	/* Allocate the new queue structure. */
;;;293    	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
;;;294    	{
;;;295    		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
00000e  204c              MOVS     r0,#0x4c
000010  f7fffffe          BL       pvPortMalloc
000014  0004              MOVS     r4,r0
;;;296    		if( pxNewQueue != NULL )
000016  d011              BEQ      |L7.60|
;;;297    		{
;;;298    			/* Create the list of pointers to queue items.  The queue is one byte
;;;299    			longer than asked for to make wrap checking easier/faster. */
;;;300    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
000018  fb05f007          MUL      r0,r5,r7
00001c  1c40              ADDS     r0,r0,#1
;;;301    
;;;302    			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
00001e  f7fffffe          BL       pvPortMalloc
;;;303    			if( pxNewQueue->pcHead != NULL )
000022  6020              STR      r0,[r4,#0]
000024  b138              CBZ      r0,|L7.54|
;;;304    			{
;;;305    				/* Initialise the queue members as described above where the
;;;306    				queue type is defined. */
;;;307    				pxNewQueue->uxLength = uxQueueLength;
;;;308    				pxNewQueue->uxItemSize = uxItemSize;
;;;309    				xQueueGenericReset( pxNewQueue, pdTRUE );
000026  e9c4570f          STRD     r5,r7,[r4,#0x3c]
00002a  2101              MOVS     r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       xQueueGenericReset
;;;310    
;;;311    				#if ( configUSE_TRACE_FACILITY == 1 )
;;;312    				{
;;;313    					pxNewQueue->ucQueueType = ucQueueType;
;;;314    				}
;;;315    				#endif /* configUSE_TRACE_FACILITY */
;;;316    
;;;317    				#if( configUSE_QUEUE_SETS == 1 )
;;;318    				{
;;;319    					pxNewQueue->pxQueueSetContainer = NULL;
;;;320    				}
;;;321    				#endif /* configUSE_QUEUE_SETS */
;;;322    
;;;323    				traceQUEUE_CREATE( pxNewQueue );
;;;324    				xReturn = pxNewQueue;
000032  4626              MOV      r6,r4
000034  e002              B        |L7.60|
                  |L7.54|
;;;325    			}
;;;326    			else
;;;327    			{
;;;328    				traceQUEUE_CREATE_FAILED( ucQueueType );
;;;329    				vPortFree( pxNewQueue );
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       vPortFree
                  |L7.60|
;;;330    			}
;;;331    		}
;;;332    	}
;;;333    
;;;334    	configASSERT( xReturn );
;;;335    
;;;336    	return xReturn;
00003c  4630              MOV      r0,r6
;;;337    }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;338    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReceive||, CODE, READONLY, ALIGN=1

                  xQueueGenericReceive PROC
;;;1015   
;;;1016   signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1017   {
;;;1018   signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000004  2500              MOVS     r5,#0
000006  b082              SUB      sp,sp,#8              ;1017
000008  461e              MOV      r6,r3                 ;1017
00000a  4688              MOV      r8,r1                 ;1017
;;;1019   xTimeOutType xTimeOut;
;;;1020   signed char *pcOriginalReadPosition;
;;;1021   xQUEUE *pxQueue;
;;;1022   
;;;1023   	pxQueue = ( xQUEUE * ) xQueue;
00000c  4604              MOV      r4,r0
00000e  462f              MOV      r7,r5
                  |L8.16|
;;;1024   	configASSERT( pxQueue );
;;;1025   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1026   
;;;1027   	/* This function relaxes the coding standard somewhat to allow return
;;;1028   	statements within the function itself.  This is done in the interest
;;;1029   	of execution time efficiency. */
;;;1030   
;;;1031   	for( ;; )
;;;1032   	{
;;;1033   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1034   		{
;;;1035   			/* Is there data in the queue now?  To be running we must be
;;;1036   			the highest priority task wanting to access the queue. */
;;;1037   			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000014  6ba0              LDR      r0,[r4,#0x38]
000016  b310              CBZ      r0,|L8.94|
;;;1038   			{
;;;1039   				/* Remember our read position in case we are just peeking. */
;;;1040   				pcOriginalReadPosition = pxQueue->pcReadFrom;
;;;1041   
;;;1042   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000018  4641              MOV      r1,r8
00001a  4620              MOV      r0,r4
00001c  68e5              LDR      r5,[r4,#0xc]
00001e  f7fffffe          BL       prvCopyDataFromQueue
;;;1043   
;;;1044   				if( xJustPeeking == pdFALSE )
000022  b17e              CBZ      r6,|L8.68|
;;;1045   				{
;;;1046   					traceQUEUE_RECEIVE( pxQueue );
;;;1047   
;;;1048   					/* We are actually removing data. */
;;;1049   					--( pxQueue->uxMessagesWaiting );
;;;1050   
;;;1051   					#if ( configUSE_MUTEXES == 1 )
;;;1052   					{
;;;1053   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1054   						{
;;;1055   							/* Record the information required to implement
;;;1056   							priority inheritance should it become necessary. */
;;;1057   							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
;;;1058   						}
;;;1059   					}
;;;1060   					#endif
;;;1061   
;;;1062   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1063   					{
;;;1064   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
;;;1065   						{
;;;1066   							portYIELD_WITHIN_API();
;;;1067   						}
;;;1068   					}
;;;1069   				}
;;;1070   				else
;;;1071   				{
;;;1072   					traceQUEUE_PEEK( pxQueue );
;;;1073   
;;;1074   					/* The data is not being removed, so reset the read
;;;1075   					pointer. */
;;;1076   					pxQueue->pcReadFrom = pcOriginalReadPosition;
;;;1077   
;;;1078   					/* The data is being left in the queue, so see if there are
;;;1079   					any other tasks waiting for the data. */
;;;1080   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000024  60e5              STR      r5,[r4,#0xc]
000026  6a60              LDR      r0,[r4,#0x24]
000028  b130              CBZ      r0,|L8.56|
;;;1081   					{
;;;1082   						/* Tasks that are removed from the event list will get added to
;;;1083   						the pending ready list as the scheduler is still suspended. */
;;;1084   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00002a  f1040024          ADD      r0,r4,#0x24
00002e  f7fffffe          BL       xTaskRemoveFromEventList
000032  b108              CBZ      r0,|L8.56|
                  |L8.52|
;;;1085   						{
;;;1086   							/* The task waiting has a higher priority than this task. */
;;;1087   							portYIELD_WITHIN_API();
000034  f7fffffe          BL       vPortYield
                  |L8.56|
;;;1088   						}
;;;1089   					}
;;;1090   				}
;;;1091   
;;;1092   				taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;1093   				return pdPASS;
00003c  2001              MOVS     r0,#1
                  |L8.62|
;;;1094   			}
;;;1095   			else
;;;1096   			{
;;;1097   				if( xTicksToWait == ( portTickType ) 0 )
;;;1098   				{
;;;1099   					/* The queue was empty and no block time is specified (or
;;;1100   					the block time has expired) so leave now. */
;;;1101   					taskEXIT_CRITICAL();
;;;1102   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1103   					return errQUEUE_EMPTY;
;;;1104   				}
;;;1105   				else if( xEntryTimeSet == pdFALSE )
;;;1106   				{
;;;1107   					/* The queue was empty and a block time was specified so
;;;1108   					configure the timeout structure. */
;;;1109   					vTaskSetTimeOutState( &xTimeOut );
;;;1110   					xEntryTimeSet = pdTRUE;
;;;1111   				}
;;;1112   			}
;;;1113   		}
;;;1114   		taskEXIT_CRITICAL();
;;;1115   
;;;1116   		/* Interrupts and other tasks can send to and receive from the queue
;;;1117   		now the critical section has been exited. */
;;;1118   
;;;1119   		vTaskSuspendAll();
;;;1120   		prvLockQueue( pxQueue );
;;;1121   
;;;1122   		/* Update the timeout state to see if it has expired yet. */
;;;1123   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1124   		{
;;;1125   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1126   			{
;;;1127   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1128   
;;;1129   				#if ( configUSE_MUTEXES == 1 )
;;;1130   				{
;;;1131   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1132   					{
;;;1133   						portENTER_CRITICAL();
;;;1134   						{
;;;1135   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1136   						}
;;;1137   						portEXIT_CRITICAL();
;;;1138   					}
;;;1139   				}
;;;1140   				#endif
;;;1141   
;;;1142   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1143   				prvUnlockQueue( pxQueue );
;;;1144   				if( xTaskResumeAll() == pdFALSE )
;;;1145   				{
;;;1146   					portYIELD_WITHIN_API();
;;;1147   				}
;;;1148   			}
;;;1149   			else
;;;1150   			{
;;;1151   				/* Try again. */
;;;1152   				prvUnlockQueue( pxQueue );
;;;1153   				( void ) xTaskResumeAll();
;;;1154   			}
;;;1155   		}
;;;1156   		else
;;;1157   		{
;;;1158   			prvUnlockQueue( pxQueue );
;;;1159   			( void ) xTaskResumeAll();
;;;1160   			traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1161   			return errQUEUE_EMPTY;
;;;1162   		}
;;;1163   	}
;;;1164   }
00003e  b006              ADD      sp,sp,#0x18
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L8.68|
000044  6ba0              LDR      r0,[r4,#0x38]         ;1049
000046  1e40              SUBS     r0,r0,#1              ;1049
000048  63a0              STR      r0,[r4,#0x38]         ;1049
00004a  6920              LDR      r0,[r4,#0x10]         ;1062
00004c  2800              CMP      r0,#0                 ;1062
00004e  d0f3              BEQ      |L8.56|
000050  f1040010          ADD      r0,r4,#0x10           ;1064
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2801              CMP      r0,#1                 ;1064
00005a  d0eb              BEQ      |L8.52|
00005c  e7ec              B        |L8.56|
                  |L8.94|
00005e  9804              LDR      r0,[sp,#0x10]         ;1097
000060  b108              CBZ      r0,|L8.102|
000062  b11d              CBZ      r5,|L8.108|
000064  e006              B        |L8.116|
                  |L8.102|
000066  f7fffffe          BL       vPortExitCritical
00006a  e01d              B        |L8.168|
                  |L8.108|
00006c  4668              MOV      r0,sp                 ;1109
00006e  f7fffffe          BL       vTaskSetTimeOutState
000072  2501              MOVS     r5,#1                 ;1110
                  |L8.116|
000074  f7fffffe          BL       vPortExitCritical
000078  f7fffffe          BL       vTaskSuspendAll
00007c  f7fffffe          BL       vPortEnterCritical
000080  6c60              LDR      r0,[r4,#0x44]         ;1120
000082  1c40              ADDS     r0,r0,#1              ;1120
000084  d100              BNE      |L8.136|
000086  6467              STR      r7,[r4,#0x44]         ;1120
                  |L8.136|
000088  6ca0              LDR      r0,[r4,#0x48]         ;1120
00008a  1c40              ADDS     r0,r0,#1              ;1120
00008c  d100              BNE      |L8.144|
00008e  64a7              STR      r7,[r4,#0x48]         ;1120
                  |L8.144|
000090  f7fffffe          BL       vPortExitCritical
000094  a904              ADD      r1,sp,#0x10           ;1123
000096  4668              MOV      r0,sp                 ;1123
000098  f7fffffe          BL       xTaskCheckForTimeOut
00009c  b130              CBZ      r0,|L8.172|
00009e  4620              MOV      r0,r4                 ;1158
0000a0  f7fffffe          BL       prvUnlockQueue
0000a4  f7fffffe          BL       xTaskResumeAll
                  |L8.168|
0000a8  2000              MOVS     r0,#0                 ;1161
0000aa  e7c8              B        |L8.62|
                  |L8.172|
0000ac  f7fffffe          BL       vPortEnterCritical
0000b0  6ba0              LDR      r0,[r4,#0x38]
0000b2  b138              CBZ      r0,|L8.196|
0000b4  f7fffffe          BL       vPortExitCritical
0000b8  4620              MOV      r0,r4                 ;1152
0000ba  f7fffffe          BL       prvUnlockQueue
0000be  f7fffffe          BL       xTaskResumeAll
0000c2  e7a5              B        |L8.16|
                  |L8.196|
0000c4  f7fffffe          BL       vPortExitCritical
0000c8  f1040024          ADD      r0,r4,#0x24           ;1142
0000cc  9904              LDR      r1,[sp,#0x10]         ;1142
0000ce  f7fffffe          BL       vTaskPlaceOnEventList
0000d2  4620              MOV      r0,r4                 ;1143
0000d4  f7fffffe          BL       prvUnlockQueue
0000d8  f7fffffe          BL       xTaskResumeAll
0000dc  2800              CMP      r0,#0                 ;1144
0000de  d197              BNE      |L8.16|
0000e0  f7fffffe          BL       vPortYield
0000e4  e794              B        |L8.16|
;;;1165   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;235    
;;;236    portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;237    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;238    xQUEUE *pxQueue;
;;;239    
;;;240    	pxQueue = ( xQUEUE * ) xQueue;
;;;241    	configASSERT( pxQueue );
;;;242    
;;;243    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;244    	{
;;;245    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000a  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
00000e  6820              LDR      r0,[r4,#0]
000010  fb010002          MLA      r0,r1,r2,r0
;;;246    		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000014  6060              STR      r0,[r4,#4]
000016  2000              MOVS     r0,#0
000018  63a0              STR      r0,[r4,#0x38]
;;;247    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
;;;248    		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
00001c  60a0              STR      r0,[r4,#8]
00001e  4601              MOV      r1,r0
000020  6be0              LDR      r0,[r4,#0x3c]
000022  1e40              SUBS     r0,r0,#1
000024  fb001002          MLA      r0,r0,r2,r1
;;;249    		pxQueue->xRxLock = queueUNLOCKED;
000028  60e0              STR      r0,[r4,#0xc]
00002a  f04f30ff          MOV      r0,#0xffffffff
00002e  6460              STR      r0,[r4,#0x44]
;;;250    		pxQueue->xTxLock = queueUNLOCKED;
000030  64a0              STR      r0,[r4,#0x48]
;;;251    
;;;252    		if( xNewQueue == pdFALSE )
;;;253    		{
;;;254    			/* If there are tasks blocked waiting to read from the queue, then
;;;255    			the tasks will remain blocked as after this function exits the queue
;;;256    			will still be empty.  If there are tasks blocked waiting to	write to
;;;257    			the queue, then one should be unblocked as after this function exits
;;;258    			it will be possible to write to it. */
;;;259    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;260    			{
;;;261    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000032  f1040010          ADD      r0,r4,#0x10
000036  b14d              CBZ      r5,|L9.76|
;;;262    				{
;;;263    					portYIELD_WITHIN_API();
;;;264    				}
;;;265    			}
;;;266    		}
;;;267    		else
;;;268    		{
;;;269    			/* Ensure the event queues start in the correct state. */
;;;270    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000038  f7fffffe          BL       vListInitialise
;;;271    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00003c  f1040024          ADD      r0,r4,#0x24
000040  f7fffffe          BL       vListInitialise
                  |L9.68|
;;;272    		}
;;;273    	}
;;;274    	taskEXIT_CRITICAL();
000044  f7fffffe          BL       vPortExitCritical
;;;275    
;;;276    	/* A value is returned for calling semantic consistency with previous
;;;277    	versions. */
;;;278    	return pdPASS;
000048  2001              MOVS     r0,#1
;;;279    }
00004a  bd70              POP      {r4-r6,pc}
                  |L9.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;259
00004e  2900              CMP      r1,#0                 ;259
000050  d0f8              BEQ      |L9.68|
000052  f7fffffe          BL       xTaskRemoveFromEventList
000056  2801              CMP      r0,#1                 ;261
000058  d1f4              BNE      |L9.68|
00005a  f7fffffe          BL       vPortYield
00005e  e7f1              B        |L9.68|
;;;280    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=1

                  xQueueGenericSend PROC
;;;553    
;;;554    signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;555    {
;;;556    signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000004  2500              MOVS     r5,#0
000006  b082              SUB      sp,sp,#8              ;555
000008  461e              MOV      r6,r3                 ;555
00000a  4688              MOV      r8,r1                 ;555
;;;557    xTimeOutType xTimeOut;
;;;558    xQUEUE *pxQueue;
;;;559    
;;;560    	pxQueue = ( xQUEUE * ) xQueue;
00000c  4604              MOV      r4,r0
00000e  462f              MOV      r7,r5
                  |L10.16|
;;;561    	configASSERT( pxQueue );
;;;562    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;563    
;;;564    	/* This function relaxes the coding standard somewhat to allow return
;;;565    	statements within the function itself.  This is done in the interest
;;;566    	of execution time efficiency. */
;;;567    	for( ;; )
;;;568    	{
;;;569    		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;570    		{
;;;571    			/* Is there room on the queue now?  To be running we must be
;;;572    			the highest priority task wanting to access the queue. */
;;;573    			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000014  6ba0              LDR      r0,[r4,#0x38]
000016  6be1              LDR      r1,[r4,#0x3c]
000018  4288              CMP      r0,r1
00001a  d214              BCS      |L10.70|
;;;574    			{
;;;575    				traceQUEUE_SEND( pxQueue );
;;;576    				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00001c  4632              MOV      r2,r6
00001e  4641              MOV      r1,r8
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       prvCopyDataToQueue
;;;577    
;;;578    				#if ( configUSE_QUEUE_SETS == 1 )
;;;579    				{
;;;580    					if( pxQueue->pxQueueSetContainer != NULL )
;;;581    					{
;;;582    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;583    						{
;;;584    							/* The queue is a member of a queue set, and posting
;;;585    							to the queue set caused a higher priority task to
;;;586    							unblock. A context switch is required. */
;;;587    							portYIELD_WITHIN_API();
;;;588    						}
;;;589    					}
;;;590    					else
;;;591    					{
;;;592    						/* If there was a task waiting for data to arrive on the
;;;593    						queue then unblock it now. */
;;;594    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;595    						{
;;;596    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
;;;597    							{
;;;598    								/* The unblocked task has a priority higher than
;;;599    								our own so yield immediately.  Yes it is ok to
;;;600    								do this from within the critical section - the
;;;601    								kernel takes care of that. */
;;;602    								portYIELD_WITHIN_API();
;;;603    							}
;;;604    						}
;;;605    					}
;;;606    				}
;;;607    				#else /* configUSE_QUEUE_SETS */
;;;608    				{
;;;609    					/* If there was a task waiting for data to arrive on the
;;;610    					queue then unblock it now. */
;;;611    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000026  6a60              LDR      r0,[r4,#0x24]
000028  b138              CBZ      r0,|L10.58|
;;;612    					{
;;;613    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
00002a  f1040024          ADD      r0,r4,#0x24
00002e  f7fffffe          BL       xTaskRemoveFromEventList
000032  2801              CMP      r0,#1
000034  d101              BNE      |L10.58|
;;;614    						{
;;;615    							/* The unblocked task has a priority higher than
;;;616    							our own so yield immediately.  Yes it is ok to do
;;;617    							this from within the critical section - the kernel
;;;618    							takes care of that. */
;;;619    							portYIELD_WITHIN_API();
000036  f7fffffe          BL       vPortYield
                  |L10.58|
;;;620    						}
;;;621    					}
;;;622    				}
;;;623    				#endif /* configUSE_QUEUE_SETS */
;;;624    
;;;625    				taskEXIT_CRITICAL();
00003a  f7fffffe          BL       vPortExitCritical
;;;626    
;;;627    				/* Return to the original privilege level before exiting the
;;;628    				function. */
;;;629    				return pdPASS;
00003e  2001              MOVS     r0,#1
                  |L10.64|
;;;630    			}
;;;631    			else
;;;632    			{
;;;633    				if( xTicksToWait == ( portTickType ) 0 )
;;;634    				{
;;;635    					/* The queue was full and no block time is specified (or
;;;636    					the block time has expired) so leave now. */
;;;637    					taskEXIT_CRITICAL();
;;;638    
;;;639    					/* Return to the original privilege level before exiting
;;;640    					the function. */
;;;641    					traceQUEUE_SEND_FAILED( pxQueue );
;;;642    					return errQUEUE_FULL;
;;;643    				}
;;;644    				else if( xEntryTimeSet == pdFALSE )
;;;645    				{
;;;646    					/* The queue was full and a block time was specified so
;;;647    					configure the timeout structure. */
;;;648    					vTaskSetTimeOutState( &xTimeOut );
;;;649    					xEntryTimeSet = pdTRUE;
;;;650    				}
;;;651    			}
;;;652    		}
;;;653    		taskEXIT_CRITICAL();
;;;654    
;;;655    		/* Interrupts and other tasks can send to and receive from the queue
;;;656    		now the critical section has been exited. */
;;;657    
;;;658    		vTaskSuspendAll();
;;;659    		prvLockQueue( pxQueue );
;;;660    
;;;661    		/* Update the timeout state to see if it has expired yet. */
;;;662    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;663    		{
;;;664    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;665    			{
;;;666    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;667    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;668    
;;;669    				/* Unlocking the queue means queue events can effect the
;;;670    				event list.  It is possible	that interrupts occurring now
;;;671    				remove this task from the event	list again - but as the
;;;672    				scheduler is suspended the task will go onto the pending
;;;673    				ready last instead of the actual ready list. */
;;;674    				prvUnlockQueue( pxQueue );
;;;675    
;;;676    				/* Resuming the scheduler will move tasks from the pending
;;;677    				ready list into the ready list - so it is feasible that this
;;;678    				task is already in a ready list before it yields - in which
;;;679    				case the yield will not cause a context switch unless there
;;;680    				is also a higher priority task in the pending ready list. */
;;;681    				if( xTaskResumeAll() == pdFALSE )
;;;682    				{
;;;683    					portYIELD_WITHIN_API();
;;;684    				}
;;;685    			}
;;;686    			else
;;;687    			{
;;;688    				/* Try again. */
;;;689    				prvUnlockQueue( pxQueue );
;;;690    				( void ) xTaskResumeAll();
;;;691    			}
;;;692    		}
;;;693    		else
;;;694    		{
;;;695    			/* The timeout has expired. */
;;;696    			prvUnlockQueue( pxQueue );
;;;697    			( void ) xTaskResumeAll();
;;;698    
;;;699    			/* Return to the original privilege level before exiting the
;;;700    			function. */
;;;701    			traceQUEUE_SEND_FAILED( pxQueue );
;;;702    			return errQUEUE_FULL;
;;;703    		}
;;;704    	}
;;;705    }
000040  b006              ADD      sp,sp,#0x18
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L10.70|
000046  9804              LDR      r0,[sp,#0x10]         ;633
000048  b108              CBZ      r0,|L10.78|
00004a  b11d              CBZ      r5,|L10.84|
00004c  e006              B        |L10.92|
                  |L10.78|
00004e  f7fffffe          BL       vPortExitCritical
000052  e01d              B        |L10.144|
                  |L10.84|
000054  4668              MOV      r0,sp                 ;648
000056  f7fffffe          BL       vTaskSetTimeOutState
00005a  2501              MOVS     r5,#1                 ;649
                  |L10.92|
00005c  f7fffffe          BL       vPortExitCritical
000060  f7fffffe          BL       vTaskSuspendAll
000064  f7fffffe          BL       vPortEnterCritical
000068  6c60              LDR      r0,[r4,#0x44]         ;659
00006a  1c40              ADDS     r0,r0,#1              ;659
00006c  d100              BNE      |L10.112|
00006e  6467              STR      r7,[r4,#0x44]         ;659
                  |L10.112|
000070  6ca0              LDR      r0,[r4,#0x48]         ;659
000072  1c40              ADDS     r0,r0,#1              ;659
000074  d100              BNE      |L10.120|
000076  64a7              STR      r7,[r4,#0x48]         ;659
                  |L10.120|
000078  f7fffffe          BL       vPortExitCritical
00007c  a904              ADD      r1,sp,#0x10           ;662
00007e  4668              MOV      r0,sp                 ;662
000080  f7fffffe          BL       xTaskCheckForTimeOut
000084  b130              CBZ      r0,|L10.148|
000086  4620              MOV      r0,r4                 ;696
000088  f7fffffe          BL       prvUnlockQueue
00008c  f7fffffe          BL       xTaskResumeAll
                  |L10.144|
000090  2000              MOVS     r0,#0                 ;702
000092  e7d5              B        |L10.64|
                  |L10.148|
000094  f7fffffe          BL       vPortEnterCritical
000098  6ba0              LDR      r0,[r4,#0x38]
00009a  6be1              LDR      r1,[r4,#0x3c]
00009c  4288              CMP      r0,r1
00009e  d110              BNE      |L10.194|
0000a0  f7fffffe          BL       vPortExitCritical
0000a4  f1040010          ADD      r0,r4,#0x10           ;667
0000a8  9904              LDR      r1,[sp,#0x10]         ;667
0000aa  f7fffffe          BL       vTaskPlaceOnEventList
0000ae  4620              MOV      r0,r4                 ;674
0000b0  f7fffffe          BL       prvUnlockQueue
0000b4  f7fffffe          BL       xTaskResumeAll
0000b8  2800              CMP      r0,#0                 ;681
0000ba  d1a9              BNE      |L10.16|
0000bc  f7fffffe          BL       vPortYield
0000c0  e7a6              B        |L10.16|
                  |L10.194|
0000c2  f7fffffe          BL       vPortExitCritical
0000c6  4620              MOV      r0,r4                 ;689
0000c8  f7fffffe          BL       prvUnlockQueue
0000cc  f7fffffe          BL       xTaskResumeAll
0000d0  e79e              B        |L10.16|
;;;706    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;919    
;;;920    signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;921    {
000004  461f              MOV      r7,r3
000006  4615              MOV      r5,r2
000008  4688              MOV      r8,r1
;;;922    signed portBASE_TYPE xReturn;
;;;923    unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;924    xQUEUE *pxQueue;
;;;925    
;;;926    	pxQueue = ( xQUEUE * ) xQueue;
00000a  4604              MOV      r4,r0
;;;927    	configASSERT( pxQueue );
;;;928    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;929    
;;;930    	/* Similar to xQueueGenericSend, except we don't block if there is no room
;;;931    	in the queue.  Also we don't directly wake a task that was blocked on a
;;;932    	queue read, instead we return a flag to say whether a context switch is
;;;933    	required or not (i.e. has a task with a higher priority than us been woken
;;;934    	by this	post). */
;;;935    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000c  f7fffffe          BL       ulPortSetInterruptMask
000010  4606              MOV      r6,r0
;;;936    	{
;;;937    		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000012  6ba0              LDR      r0,[r4,#0x38]
000014  6be1              LDR      r1,[r4,#0x3c]
000016  4288              CMP      r0,r1
000018  d21a              BCS      |L11.80|
;;;938    		{
;;;939    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;940    
;;;941    			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00001a  463a              MOV      r2,r7
00001c  4641              MOV      r1,r8
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       prvCopyDataToQueue
;;;942    
;;;943    			/* If the queue is locked we do not alter the event list.  This will
;;;944    			be done when the queue is unlocked later. */
;;;945    			if( pxQueue->xTxLock == queueUNLOCKED )
000024  6ca0              LDR      r0,[r4,#0x48]
000026  1c40              ADDS     r0,r0,#1
000028  d004              BEQ      |L11.52|
;;;946    			{
;;;947    				#if ( configUSE_QUEUE_SETS == 1 )
;;;948    				{
;;;949    					if( pxQueue->pxQueueSetContainer != NULL )
;;;950    					{
;;;951    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
;;;952    						{
;;;953    							/* The queue is a member of a queue set, and posting
;;;954    							to the queue set caused a higher priority task to
;;;955    							unblock.  A context switch is required. */
;;;956    							if( pxHigherPriorityTaskWoken != NULL )
;;;957    							{
;;;958    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;959    							}
;;;960    						}
;;;961    					}
;;;962    					else
;;;963    					{
;;;964    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;965    						{
;;;966    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;967    							{
;;;968    								/* The task waiting has a higher priority so record that a
;;;969    								context	switch is required. */
;;;970    								if( pxHigherPriorityTaskWoken != NULL )
;;;971    								{
;;;972    									*pxHigherPriorityTaskWoken = pdTRUE;
;;;973    								}
;;;974    							}
;;;975    						}
;;;976    					}
;;;977    				}
;;;978    				#else /* configUSE_QUEUE_SETS */
;;;979    				{
;;;980    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;981    					{
;;;982    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;983    						{
;;;984    							/* The task waiting has a higher priority so record that a
;;;985    							context	switch is required. */
;;;986    							if( pxHigherPriorityTaskWoken != NULL )
;;;987    							{
;;;988    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;989    							}
;;;990    						}
;;;991    					}
;;;992    				}
;;;993    				#endif /* configUSE_QUEUE_SETS */
;;;994    			}
;;;995    			else
;;;996    			{
;;;997    				/* Increment the lock count so the task that unlocks the queue
;;;998    				knows that data was posted while it was locked. */
;;;999    				++( pxQueue->xTxLock );
00002a  6ca0              LDR      r0,[r4,#0x48]
00002c  1c40              ADDS     r0,r0,#1
00002e  64a0              STR      r0,[r4,#0x48]
                  |L11.48|
;;;1000   			}
;;;1001   
;;;1002   			xReturn = pdPASS;
000030  2401              MOVS     r4,#1
000032  e00e              B        |L11.82|
                  |L11.52|
000034  6a60              LDR      r0,[r4,#0x24]         ;980
000036  2800              CMP      r0,#0                 ;980
000038  d0fa              BEQ      |L11.48|
00003a  f1040024          ADD      r0,r4,#0x24           ;982
00003e  f7fffffe          BL       xTaskRemoveFromEventList
000042  2800              CMP      r0,#0                 ;982
000044  d0f4              BEQ      |L11.48|
000046  2d00              CMP      r5,#0                 ;986
000048  d0f2              BEQ      |L11.48|
00004a  2001              MOVS     r0,#1                 ;988
00004c  6028              STR      r0,[r5,#0]            ;988
00004e  e7ef              B        |L11.48|
                  |L11.80|
;;;1003   		}
;;;1004   		else
;;;1005   		{
;;;1006   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1007   			xReturn = errQUEUE_FULL;
000050  2400              MOVS     r4,#0
                  |L11.82|
;;;1008   		}
;;;1009   	}
;;;1010   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       vPortClearInterruptMask
;;;1011   
;;;1012   	return xReturn;
000058  4620              MOV      r0,r4
;;;1013   }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;1014   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;1471   
;;;1472   signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;1473   {
000002  b108              CBZ      r0,|L12.8|
;;;1474   signed portBASE_TYPE xReturn;
;;;1475   
;;;1476   	configASSERT( xQueue );
;;;1477   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
;;;1478   	{
;;;1479   		xReturn = pdTRUE;
;;;1480   	}
;;;1481   	else
;;;1482   	{
;;;1483   		xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1484   	}
;;;1485   
;;;1486   	return xReturn;
;;;1487   }
000006  4770              BX       lr
                  |L12.8|
000008  2001              MOVS     r0,#1                 ;1479
00000a  4770              BX       lr
;;;1488   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;1510   
;;;1511   signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
000000  6b81              LDR      r1,[r0,#0x38]
;;;1512   {
;;;1513   signed portBASE_TYPE xReturn;
;;;1514   
;;;1515   	configASSERT( xQueue );
;;;1516   	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
000002  6bc0              LDR      r0,[r0,#0x3c]
000004  4281              CMP      r1,r0
000006  d101              BNE      |L13.12|
;;;1517   	{
;;;1518   		xReturn = pdTRUE;
000008  2001              MOVS     r0,#1
;;;1519   	}
;;;1520   	else
;;;1521   	{
;;;1522   		xReturn = pdFALSE;
;;;1523   	}
;;;1524   
;;;1525   	return xReturn;
;;;1526   }
00000a  4770              BX       lr
                  |L13.12|
00000c  2000              MOVS     r0,#0                 ;1522
00000e  4770              BX       lr
;;;1527   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1166   
;;;1167   signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1168   {
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
;;;1169   signed portBASE_TYPE xReturn;
;;;1170   unsigned portBASE_TYPE uxSavedInterruptStatus;
;;;1171   xQUEUE *pxQueue;
;;;1172   
;;;1173   	pxQueue = ( xQUEUE * ) xQueue;
000008  4604              MOV      r4,r0
;;;1174   	configASSERT( pxQueue );
;;;1175   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
;;;1176   
;;;1177   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  f7fffffe          BL       ulPortSetInterruptMask
00000e  4606              MOV      r6,r0
;;;1178   	{
;;;1179   		/* We cannot block from an ISR, so check there is data available. */
;;;1180   		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000010  6ba0              LDR      r0,[r4,#0x38]
000012  b1e0              CBZ      r0,|L14.78|
;;;1181   		{
;;;1182   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1183   
;;;1184   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000014  4639              MOV      r1,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       prvCopyDataFromQueue
;;;1185   			--( pxQueue->uxMessagesWaiting );
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  1e40              SUBS     r0,r0,#1
000020  63a0              STR      r0,[r4,#0x38]
;;;1186   
;;;1187   			/* If the queue is locked we will not modify the event list.  Instead
;;;1188   			we update the lock count so the task that unlocks the queue will know
;;;1189   			that an ISR has removed data while the queue was locked. */
;;;1190   			if( pxQueue->xRxLock == queueUNLOCKED )
000022  6c60              LDR      r0,[r4,#0x44]
000024  1c40              ADDS     r0,r0,#1
000026  d004              BEQ      |L14.50|
;;;1191   			{
;;;1192   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1193   				{
;;;1194   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1195   					{
;;;1196   						/* The task waiting has a higher priority than us so
;;;1197   						force a context switch. */
;;;1198   						if( pxHigherPriorityTaskWoken != NULL )
;;;1199   						{
;;;1200   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1201   						}
;;;1202   					}
;;;1203   				}
;;;1204   			}
;;;1205   			else
;;;1206   			{
;;;1207   				/* Increment the lock count so the task that unlocks the queue
;;;1208   				knows that data was removed while it was locked. */
;;;1209   				++( pxQueue->xRxLock );
000028  6c60              LDR      r0,[r4,#0x44]
00002a  1c40              ADDS     r0,r0,#1
00002c  6460              STR      r0,[r4,#0x44]
                  |L14.46|
;;;1210   			}
;;;1211   
;;;1212   			xReturn = pdPASS;
00002e  2401              MOVS     r4,#1
000030  e00e              B        |L14.80|
                  |L14.50|
000032  6920              LDR      r0,[r4,#0x10]         ;1192
000034  2800              CMP      r0,#0                 ;1192
000036  d0fa              BEQ      |L14.46|
000038  f1040010          ADD      r0,r4,#0x10           ;1194
00003c  f7fffffe          BL       xTaskRemoveFromEventList
000040  2800              CMP      r0,#0                 ;1194
000042  d0f4              BEQ      |L14.46|
000044  2d00              CMP      r5,#0                 ;1198
000046  d0f2              BEQ      |L14.46|
000048  2001              MOVS     r0,#1                 ;1200
00004a  6028              STR      r0,[r5,#0]            ;1200
00004c  e7ef              B        |L14.46|
                  |L14.78|
;;;1213   		}
;;;1214   		else
;;;1215   		{
;;;1216   			xReturn = pdFAIL;
00004e  2400              MOVS     r4,#0
                  |L14.80|
;;;1217   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1218   		}
;;;1219   	}
;;;1220   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       vPortClearInterruptMask
;;;1221   
;;;1222   	return xReturn;
000056  4620              MOV      r0,r4
;;;1223   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1224   /*-----------------------------------------------------------*/
                          ENDP

