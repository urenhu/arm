/*********************************  *************************************
* Copyright (c) 2017 金鑫液晶显示屏
* All rights reserved.
*
* 文件名   ：FSMC_8080.c    
* 描述     ：主函数
*
* 前版本 ：V1.0
* 作    者 ：CGY
* 完成日期 ：2017-10-31
* 修改描述 ：第一版本
*	微信号：wxjcgy20120815
*	E-mail : 68771083@qq.com
*	淘宝显示屏范例屏： https://shop150276963.taobao.com/?spm=a313o.7775905.1998679131.d0011.pdIFpT           						                          	
*******************************************************************************/
#include "FSMC_8080.h"
#include "stdlib.h"
#include "font.h"
#include "TFTLCD_Init.h"
#include "gImage_128128.h" 

//STM32内存不足，以下三个中只能打一个包含图片数组,数组名一样：gImage[] 
//#include "WeiXinPic.h"  //微信二维码240*320图片
#include "flowerPic.h" //花朵图片240*320图片
//#include "ZFB_Pic.h"  //淘宝二维码240*320图片



//LCD的画笔颜色和背景色	   
u16 POINT_COLOR=0x0000;	//画笔颜色
u16 BACK_COLOR=0xFFFF;  //背景色 
  
//管理LCD重要参数
//默认为竖屏
_lcd_dev lcddev;

/***************
//接口判读选择
//MCU=0,00: L8BIT   0K
//MCU=1,01: 16BIT	OK
//MCU=2,10: W4SPI	OK
//MCU=3,11: W3SPI
//MCU=4,--: H8BIT
***************/
#define  MCU 1

/*******************************************************************************
* Function Name  : LCD_CtrlLinesConfig
* Description    : Configures LCD Control lines (FSMC Pins) in alternate function
                   Push-Pull mode.
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_CtrlLinesConfig(void)
{
 	GPIO_InitTypeDef	GPIO_InitStructure;	
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOE , ENABLE); 

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 ;            //LCD复位PE1
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOD, &GPIO_InitStructure); 
	
//	FSMC-D0--D15: 
//	D0   D1   D2   D3   D4   D5   D6   D7   D8   D9   D10   D11   D12   D13  D14   D15       
//  PD14 PD15  PD0  PD1  PE7  PE8  PE9 PE10 PE11 PE12  PE13  PE14  PE15  PD8  PD9   PD10 
//  FSMC_CMD:
//  FSMC_NOE      FSMC_NWE       FSMC_NE1     FSMC_A16
//  LCD_RD        LCD_WR         LCD_CS       LCD_RS  
//	 PD4            PD5           PD7         PD11	
  
	GPIO_InitStructure.GPIO_Pin= GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_7|GPIO_Pin_11|      //LCD_RD,LCD_WR,LCD_CS,LCD_RS
								 GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_14|GPIO_Pin_15; 	//对应FSMC_D0-D3,FSMC_D13-D15
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出
//	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //SPI要设置成输出，不然无显20170830
 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|
								  GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;	 	//PORTE,对应FSMC_D4-D12
 	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; 		 //复用推挽输出   
 	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 	GPIO_Init(GPIOE, &GPIO_InitStructure);    	    	 											 	
	
}



void LCD_SPICtrlLinesConfig(void)
{

	GPIO_InitTypeDef GPIO_InitStructure;
//	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOD, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOD , ENABLE); 
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;	//REST
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
								    //RS            SDA         SCK         CS
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   //4SPI要设置成输出，不然无显20170830 
	GPIO_Init(GPIOD, &GPIO_InitStructure);
	
/*
								    //RS           CS
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_7;	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //spi 3w TEST 20170907
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOD, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_4;	//SDA	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD; //spi 3w TEST 20170907	
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOD, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_5;	//SCK	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //spi 3w TEST 20170907	
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOD, &GPIO_InitStructure);
*/	
	GPIO_SetBits(GPIOD, GPIO_Pin_13);

	}
	
/*******************************************************************************
* Function Name  : LCD_FSMCConfig
* Description    : Configures the Parallel interface (FSMC) for LCD(Parallel mode)
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_FSMCConfig(void)
{
	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
	FSMC_NORSRAMTimingInitTypeDef  readWriteTiming; 
	FSMC_NORSRAMTimingInitTypeDef  writeTiming;
	
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC,ENABLE);	//使能FSMC时钟
	readWriteTiming.FSMC_AddressSetupTime = 0x01;	 //地址建立时间（ADDSET）为2个HCLK 1/36M=27ns
	readWriteTiming.FSMC_AddressHoldTime = 0x00;	 //地址保持时间（ADDHLD）模式A未用到	
	readWriteTiming.FSMC_DataSetupTime = 0x0f;		 // 数据保存时间为16个HCLK,因为液晶驱动IC的读数据的时候，速度不能太快，尤其对1289这个IC。
	readWriteTiming.FSMC_BusTurnAroundDuration = 0x00;
	readWriteTiming.FSMC_CLKDivision = 0x00;
	readWriteTiming.FSMC_DataLatency = 0x00;
	readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_A;	 //模式A 
		

	writeTiming.FSMC_AddressSetupTime = 0x00;	 //地址建立时间（ADDSET）为1个HCLK  
	writeTiming.FSMC_AddressHoldTime = 0x00;	 //地址保持时间（A		
	writeTiming.FSMC_DataSetupTime = 0x03;		 ////数据保存时间为4个HCLK	
	writeTiming.FSMC_BusTurnAroundDuration = 0x00;
	writeTiming.FSMC_CLKDivision = 0x00;
	writeTiming.FSMC_DataLatency = 0x00;
	writeTiming.FSMC_AccessMode = FSMC_AccessMode_A;	 //模式A 

 
	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM1;//  这里使用NE1 ，也就对应BTCR[6],[7]。
	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable; // 不复用数据地址
	FSMC_NORSRAMInitStructure.FSMC_MemoryType =FSMC_MemoryType_SRAM;// FSMC_MemoryType_SRAM;  //SRAM 
	
	switch(MCU)   
		{	
			case 0:{FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b; }  break; //存储器数据宽度为8bit  
			case 1:{FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;}  break; //存储器数据宽度为16bit 
			default:FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b; break;
		} 
		
//	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;  //存储器数据宽度为16bit	
	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode =FSMC_BurstAccessMode_Disable;// FSMC_BurstAccessMode_Disable; 
	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable; 
	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;   
	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;  
	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;	//  存储器写使能
	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;   
	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Enable; // 读写使用不同的时序
	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable; 
	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &readWriteTiming; //读写时序
	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &writeTiming;  //写时序

	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);  //初始化FSMC配置

	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE);  // 使能BANK1 	
		
}


/*******************************************************************************
* Function Name  : LCD_Reset
* Description    : 对ＬＣＤ进行复位操作
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_RESET(void)
{   
	GPIO_SetBits(GPIOD, GPIO_Pin_13 );		 
	delay_ms(30);
	GPIO_ResetBits(GPIOD, GPIO_Pin_13);	  
	delay_ms(50);					   
	GPIO_SetBits(GPIOD, GPIO_Pin_13 );		 
	delay_ms(30);		 
}


/*******************************************************************************
* Function Name  : SPI　　送数
* Description    : 送数８个位数
* Input          : byte
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_WriteByteSPI(unsigned char byte)
{
  //4SPI  Use  this
	int bit;
	bit = byte >> 7; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 6; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 5; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 4; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 3; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 2; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 1; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = byte >> 0; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	
}

/********************************4W-SPI***********************************************/
void SPI4W_WriteRegIndex(u16 Index)
{
	int bit; 
	unsigned char byte=Index;
		
	SPI_CS(0);
	SPI_A0(0);
	
	SPI_SDA(0);
	SPI_SCL(0);	

	LCD_WriteByteSPI(Index);	

	SPI_A0(1);	
	SPI_CS(1);
	
}

void SPI4W_WriteData(u16 dat)
{
	unsigned char byte=dat;
	
	SPI_CS(0);
	SPI_A0(1);
	
	SPI_SDA(1);
	SPI_SCL(0);
	
 //	LCD_WriteByteSPI(dat>>8); //start byte RS=1,RW=0----Write a GRAM data
	LCD_WriteByteSPI(dat);

	SPI_A0(0);	
	SPI_CS(1);	
	
}

void SPI4W_WriteDisplayData(u16 dat)
{
	int bit; 
	unsigned char byte;
		
	SPI_CS(0);
	SPI_A0(1);
	
	SPI_SDA(1);
	SPI_SCL(0);
	
    LCD_WriteByteSPI(dat>>8); //start byte RS=1,RW=0----Write a GRAM data
    LCD_WriteByteSPI(dat);
		
	SPI_CS(1);
	
}
/********************************3W-SPI***********************************************/
void SPI3W_WriteRegIndex(u8 Index)
{
	unsigned char i;
	int bit;

	SPI_CS(1);	
	SPI_CS(0);

	SPI_SCL(0);	
	SPI_A0(0);

	SPI_SCL(1);

//	LCD_WriteByteSPI(Index);	//upper eight bits
	
	bit = Index >> 7; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 6; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 5; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 4; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 3; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 2; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 1; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = Index >> 0; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;	
	
//	opt_delay(0);

	SPI_CS(1);
}

void SPI3W_WriteData(u8 dat)
{
	unsigned char i;
	int bit;
	
	SPI_CS(0);
	SPI_SCL(0);
	SPI_A0(1);
	
	SPI_SDA(1);//写1 一定要写1　不然无显

	SPI_SCL(1);
;
 //   LCD_WriteByteSPI(dat>>8);	//start byte RS=1,RW=0----Write a GRAM data
 //   LCD_WriteByteSPI(dat);

	
	bit = dat >> 7; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 6; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 5; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 4; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 3; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 2; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 1; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = dat >> 0; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;	
	
//	opt_delay(0);

	SPI_CS(1);	
	
}

void SPI3W_WriteDisplayData(u16 dat)
{
	unsigned char i;
	int bit;
	
	SPI_CS(0);
	SPI_SCL(0);
	SPI_A0(1);
	
	SPI_SDA(1);//写1 一定要写1　不然无显

	SPI_SCL(1);
	
 /*	LCD_WriteByteSPI(dat>>8);	//start byte RS=1,RW=0----Write a GRAM data
    LCD_WriteByteSPI(dat);
*/		
	bit = ((dat&0xff00)>>8) >> 7; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 6; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 5; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 4; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 3; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 2; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 1; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = ((dat&0xff00)>>8) >> 0; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;	

	bit = (dat&0xff) >> 7; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 6; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 5; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 4; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 3; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 2; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 1; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;
	bit = (dat&0xff) >> 0; LCD_WR_CLR; SPI_SDIN = bit; LCD_WR_SET;

//	opt_delay(0);
	
	SPI_CS(1);	
	
}
/*******************************************************************************
* Function Name  : LCD_WR_REG　　
* Description    : 写寄存器函数,regval:寄存器值
* Input          : regval
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_WR_REG(u16 regval)			//16BIT REG
{  
	//LCD->LCD_REG=regval;
	
	switch(MCU)   
		{	
			case 0:{	LCD->LCD_REG=regval>>8;	
						LCD->LCD_REG=regval&0xff; }		break;  //写入要写的寄存器序号
			case 1:{	LCD->LCD_REG=regval;}	   		break;  //写入要写的寄存器序号
			case 2:{	SPI4W_WriteRegIndex((regval&0xFF)>>8);
						SPI4W_WriteRegIndex(regval&0xFF);}	break;
			case 3:{	SPI3W_WriteRegIndex((regval&0xFF)>>8);
						SPI3W_WriteRegIndex(regval&0xFF);}	break;
			default:{	LCD->LCD_REG=regval;}			break;	
		} 
			
}

void LCD_WR_8REG(u16 regval)  //8BIT  REG
{   
	//LCD->LCD_REG=regval;
	
	switch(MCU)   
		{	
			case 0:{	LCD->LCD_REG=regval; }			break;  //写入要写的寄存器序号
			case 1:{	LCD->LCD_REG=regval; }			break;  //写入要写的寄存器序号	
			case 2:{	SPI4W_WriteRegIndex(regval);}	break;
			case 3:{	SPI3W_WriteRegIndex(regval);}	break;
			default:{	LCD->LCD_REG=regval;}			break;	
		} 

}

/*******************************************************************************
* Function Name  : LCD_WR_DATA   
* Description    : 写LCD数据函数,data:要写入的值
* Input          : data
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_WR_DATA(u16 data)  //16BIT REG
{
//	LCD->LCD_RAM=data;

	switch(MCU)   
		{	
			case 0:{	LCD->LCD_RAM=data>>8;
						LCD->LCD_RAM=data&0xff;	}	break; 
			case 1:{	LCD->LCD_RAM=data;		} 	break;  	
			case 2:{	SPI4W_WriteData(data);  }	break;
			case 3:{	SPI3W_WriteData(data);	}	break;
			default:{	LCD->LCD_RAM=data;		}	break;		
		}	
				
}

void LCD_WR_8DATA(u16 data)  //8BIT REG
{
//	LCD->LCD_RAM=data;
	
	switch(MCU)   
		{	
			case 0:{	LCD->LCD_RAM=data;}			break;  
			case 1:{	LCD->LCD_RAM=data;}			break;  	
			case 2:{	SPI4W_WriteData(data);}		break;
			case 3:{	SPI3W_WriteData(data);}		break;
			default:{	LCD->LCD_RAM=data;}			break;	
		}
}

/*******************************************************************************
* Function Name  : LCD_WriteReg    
* Description    : 写寄存器函数,LCD_Reg:寄存器地址；写LCD数据函数,LCD_RegValue:要写入的数据
* Input          : LCD_Reg,LCD_RegValue
* Output         : None
* Return         : None
*这一般用在１６位寄存器格式上的多，故用传两次．要是８位寄存器ＩＣ在改一下只传一次的．
*******************************************************************************/
void LCD_WriteReg(u16 LCD_Reg,u16 LCD_RegValue)  
{	
	switch(MCU)   
		{	
			case 0:{	LCD->LCD_REG = LCD_Reg>>8;		
						LCD->LCD_REG = LCD_Reg&0xff;
						LCD->LCD_RAM = LCD_RegValue>>8;
						LCD->LCD_RAM = LCD_RegValue&0xff; 	}		break;  
			case 1:{	LCD->LCD_REG = LCD_Reg;		   	 
						LCD->LCD_RAM = LCD_RegValue; 		}		break; 
			case 2:{	SPI4W_WriteRegIndex(LCD_Reg>>8);
						SPI4W_WriteRegIndex(LCD_Reg&0xff);
						SPI4W_WriteDisplayData(LCD_RegValue>>8);
						SPI4W_WriteDisplayData(LCD_RegValue&0xff);	}		break;
			case 3:{	SPI3W_WriteRegIndex(LCD_Reg>>8);
						SPI3W_WriteRegIndex(LCD_Reg&0xff);	
						SPI3W_WriteData(LCD_RegValue>>8);
						SPI3W_WriteData(LCD_RegValue&0xff);	}		break;
			default:{	LCD->LCD_REG = LCD_Reg;		    	 
						LCD->LCD_RAM = LCD_RegValue;		}		break; 
		}				
}

/*******************************************************************************
* Function Name  : LCD_RD_DATA     ＹＺ
* Description    : 读LCD数据函数
* Input          : None
* Output         : None
* Return         : 读到的值
*******************************************************************************/
u16 LCD_RD_DATA(void)
{
	vu16 ram;			//防止被优化
	ram=LCD->LCD_RAM;	
	return ram;	 
}

/*
//串口读点  20171101  NG
The read mode of interface means that the host reads register’s parameter or display data from ILI9341V. The
host has to send a command (Read ID or register command) and then the following byte is transmitted in the
opposite direction. ILI9341V latches the SDA (input data) at the rising edges of SCL (serial clock), and then
shifts SDA (output data) at falling edges of SCL (serial clock). After the read status command has been sent, the
SDA line must be set to tri-state and no later than at the falling edge of SCL of the last bit. The read mode has
three types of transmitted command data (8-/24-/32-bit) according command code
*/
u16 LCD_SPI_RD_DATA(void)
{
	u8 bit=0;
	
	vu16 ram;			//防止被优化
	
	PDin(4); //ＳＤＡ设置输入
	
	LCD_WR_CLR;	bit = (SPI_SDIN << 7); LCD_WR_SET;
	LCD_WR_CLR;	bit = (SPI_SDIN << 6); LCD_WR_SET;
	LCD_WR_CLR;	bit = (SPI_SDIN << 5); LCD_WR_SET;
	LCD_WR_CLR;	bit = (SPI_SDIN << 4); LCD_WR_SET;
	LCD_WR_CLR;	bit = (SPI_SDIN << 3); LCD_WR_SET;
	LCD_WR_CLR;	bit = (SPI_SDIN << 2); LCD_WR_SET;	
	LCD_WR_CLR;	bit = (SPI_SDIN << 1); LCD_WR_SET;	
	LCD_WR_CLR;	bit = (SPI_SDIN << 0); LCD_WR_SET;	
		
	ram=bit;	
	
	PDout(4); //恢复：ＳＤＡ设置输出
	
	return ram;	 
}
/*******************************************************************************
* Function Name  : LCD_ReadReg     
* Description    : 读IC寄存器函数,读寄存器
* Input          : LCD_Reg:寄存器地址
* Output         : None
* Return         : 读到的值
*******************************************************************************/
u16 LCD_ReadReg(u16 LCD_Reg)
{										   
	switch(MCU)   
		{	
			case 0:{	LCD_WR_REG(LCD_Reg);		//写入要读的寄存器序号
						delay_us(5);		  
						return LCD_RD_DATA();}	break;	//返回读到的值
			case 1:{	u16 info;
						LCD_WR_REG(LCD_Reg);		//写入要读的寄存器序号
						delay_us(5);
						info=LCD_RD_DATA();
						info<<=8;
						info|=LCD_RD_DATA();
						return info;}			break;	//返回读到的值
			case 2:{	 			}			break;	//返回读到的值
			case 3:{	 			}			break;	//返回读到的值
			default: break;	
		}	
						
}   

/*******************************************************************************
* Function Name  : LCD_WriteRAM_Prepare  开始写GRAM   改ＹＺ
* Description    : 开始写IC-GRAM寄存器函数
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_WriteRAM_Prepare(void)
{
 	//LCD->LCD_REG=lcddev.wramcmd;	
	TFT_WriteRAM(); //在TFTLCD_Init.c设置
}

/*******************************************************************************
* Function Name  : LCD_WriteRAM    
* Description    : LCD写GRAM寄存器函数
* Input          : RGB_Code:颜色值
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_WriteRAM(u16 RGB_Code)
{
//	LCD->LCD_RAM = RGB_Code;//写十六位GRAM

	switch(MCU)   
		{	
			case 0:{	LCD->LCD_RAM = RGB_Code>>8;	
						LCD->LCD_RAM = RGB_Code&0xff; 		}	break;  
			case 1:{	LCD->LCD_RAM = RGB_Code;			}	break; 
			case 2:{	SPI4W_WriteDisplayData(RGB_Code);	}	break;
			case 3:{	SPI3W_WriteDisplayData(RGB_Code);	}	break;			
			default:{	LCD->LCD_RAM=RGB_Code;				}	break;	  //写十六位GRAM
		}
			
}

/*******************************************************************************
* Function Name  : LCD_BGR2RGB     ＹＺ
* Description    : GBR格式函数.从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式,通过该函数转换.
* Input          : c:GBR格式的颜色值
* Output         : None
* Return         : 返回值RGB格式的颜色值
*******************************************************************************/
u16 LCD_BGR2RGB(u16 c)
{
	u16  r,g,b,rgb;   
	b=(c>>0)&0x1f;
	g=(c>>5)&0x3f;
	r=(c>>11)&0x1f;	 
	rgb=(b<<11)+(g<<5)+(r<<0);		 
	return(rgb);
	
} 

/*******************************************************************************
//当mdk -O1时间优化时需要设置    ＹＺ
//延时i
*******************************************************************************/
void opt_delay(u8 i)
{
	while(i--);
}

/*******************************************************************************
* Function Name  : LCD_ReadPoint    ＹＺ
* Description    :读取个某点的颜色值
* Input          : x,y:坐标
* Output         : None
* Return         : 返回值此点的颜色的颜色值
*******************************************************************************/
u16 LCD_ReadPoint(u16 x,u16 y)
{
 	u16 r=0,g=0,b=0;
	if(x>=lcddev.width||y>=lcddev.height)return 0;	//超过了范围,直接返回		   
	LCD_SetCursor(x,y);	    
	if(lcddev.id==0X9341||lcddev.id==0X6804||lcddev.id==0X5310||lcddev.id==0X1963)LCD_WR_REG(0X2E);//9341/6804/3510/1963 发送读GRAM指令
	else if(lcddev.id==0X5510)LCD_WR_REG(0X2E00);	//5510 发送读GRAM指令
	else LCD_WR_REG(0X22);      		 			//其他IC发送读GRAM指令
	if(lcddev.id==0X9320)opt_delay(2);				//FOR 9320,延时2us	    
 	r=LCD_RD_DATA();								//dummy Read	   
	if(lcddev.id==0X1963)return r;					//1963直接读就可以 
	opt_delay(2);	  
 	r=LCD_RD_DATA();  		  						//实际坐标颜色
 	if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)		//9341/NT35310/NT35510要分2次读出
 	{
		opt_delay(2);	  
		b=LCD_RD_DATA(); 
		g=r&0XFF;		//对于9341/5310/5510,第一次读取的是RG的值,R在前,G在后,各占8位
		g<<=8;
	} 
	if(lcddev.id==0X9325||lcddev.id==0X4535||lcddev.id==0X4531||lcddev.id==0XB505||lcddev.id==0XC505)return r;	//这几种IC直接返回颜色值
	else if(lcddev.id==0X9341||lcddev.id==0X5310||lcddev.id==0X5510)return (((r>>11)<<11)|((g>>10)<<5)|(b>>11));//ILI9341/NT35310/NT35510需要公式转换一下
	else return LCD_BGR2RGB(r);						//其他IC
}	
	

/*******************************************************************************
* Function Name  : LCD_Clear   modify YZ
* Description    ://清屏函数   
* Input          : color:要清屏的填充色
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_Clear(u16 color)
{
	u16 i,j;
	u32 index=0;     
	u32 totalpoint=lcddev.width;
	totalpoint*=lcddev.height; 			//得到总点数
	
	BlockWrite(0,lcddev.width,0,lcddev.height);

	for(index=0;index<totalpoint;index++)
	{
		LCD_WriteRAM(color);
//		LCD->LCD_RAM=color;
	
	}	
	
} 


/*******************************************************************************
* Function Name  : LCD_Display
* Description    : 显示填充色
* Input          : color:要显示的填充色
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_Display(u16 color)
{
	u16 i,j;
	
	u16 sx=0,sy=0;
	u16 twidth,theight;
	twidth=sx+lcddev.width-1;
	theight=sy+lcddev.height-1;

	BlockWrite(0,lcddev.width,0,lcddev.height);

	for(i=0;i<lcddev.height;i++)
	{
		for(j=0;j<lcddev.width;j++)
		{	
			LCD_WriteRAM(color);
//			LCD->LCD_RAM=color;			
		}
	
	}
	
}

/*******************************************************************************
* Function Name  : LCD_DisplayJiuGongGe
* Description    : 九宫格显示:RGB-BGR-RGB
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_DisplayJiuGongGe(void)
{

	u16 Row,Column,aa;
	
	BlockWrite(0,lcddev.width,0,lcddev.height);
	
	aa=lcddev.height/3;

	for(Row=0;Row<aa;Row++)
	{
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0xf800);
//		LCD->LCD_RAM=0xf800;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x07e0);
//		LCD->LCD_RAM=0x07e0;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x001f);
//		LCD->LCD_RAM=0x001f;
		for(Column=0;Column<(lcddev.width%3);Column++) 	LCD_WriteRAM(0x001f);
//		LCD->LCD_RAM=0x001f;
	}

	for(Row=0;Row<aa;Row++)
	{			  
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x001f);
//		LCD->LCD_RAM=0x001f;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0xf800);		
//		LCD->LCD_RAM=0xf800;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x07e0);
//		LCD->LCD_RAM=0x07e0;
		for(Column=0;Column<(lcddev.width%3);Column++)	LCD_WriteRAM(0x07e0); 
//		LCD->LCD_RAM=0x07e0;
	}

	for(Row=0;Row<aa;Row++)
	{			  				   
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x07e0); 
//		LCD->LCD_RAM=0x07e0;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x001f);  
//		LCD->LCD_RAM=0x001f;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0xf800); 
//		LCD->LCD_RAM=0xf800;
		for(Column=0;Column<(lcddev.width%3);Column++)	LCD_WriteRAM(0xf800);  
//		LCD->LCD_RAM=0xf800;
	}

	for(Row=0;Row<(lcddev.height%3);Row++)
	{			  				   
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x07e0); 
//		LCD->LCD_RAM=0x07e0;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0x001f);  
//		LCD->LCD_RAM=0x001f;
		for(Column=0;Column<(lcddev.width/3);Column++)	LCD_WriteRAM(0xf800); 
//		LCD->LCD_RAM=0xf800;
		for(Column=0;Column<(lcddev.width%3);Column++)	LCD_WriteRAM(0xf800);  
//		LCD->LCD_RAM=0xf800;
	}

}

/*******************************************************************************
* Function Name  : LCD_Frame
* Description    : 四边线＋中间区域内填充单个颜色  
* Input          :RGB_Data为中间纯色， f_data为四边框线色
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_Frame(u16 RGB_Data,u16 f_data)
{
	u16 i,j;

	BlockWrite(0,lcddev.width,0,lcddev.height);

	for(i=0;i<1;i++)
	{
		for(j=0;j<lcddev.width;j++)	LCD_WriteRAM(f_data);	
//		LCD->LCD_RAM=f_data;
	}
	
	for (i=0;i<(lcddev.height-2);i++)
	{
		for (j=0;j<1;j++)	LCD_WriteRAM(f_data);
//		LCD->LCD_RAM=f_data;
			
		for (j=0;j<(lcddev.width-2);j++)	LCD_WriteRAM(RGB_Data);	
//		LCD->LCD_RAM=RGB_Data;
			
		for (j=0;j<1;j++)	LCD_WriteRAM(f_data);
//		LCD->LCD_RAM=f_data;
	}

	for(i=0;i<1;i++)
	{
		for(j=0;j<lcddev.width;j++)	LCD_WriteRAM(f_data);
//		LCD->LCD_RAM=f_data;
	}	
	
}	
	

/*******************************************************************************
* Function Name  : Show_Gray
* Description    : 灰阶显示
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void Show_Gray(void) 
{
	unsigned int i,j,k,c16h;
	
	BlockWrite(0,lcddev.width,0,lcddev.height);
	
	for(j=0;j<(lcddev.height);j++)  
		{
		c16h=0x0000;
		for(k=0;k<16;k++)
			{
		    for(i=0;i<(lcddev.width/16);i++)
				{
					LCD_WriteRAM(c16h);	
//					LCD->LCD_RAM=c16h;
				}
			c16h=c16h+0x1082;//32阶 0841 16阶 1082 8阶2104
			}
		}
}	

/*******************************************************************************
* Function Name  : LCD_Fill   Modify YZ
* Description    : 在指定区域内填充单个颜色，(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)  
* Input          : color:要填充的颜色
* Output         : None
* Return         : None
*******************************************************************************/
void LCD_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 color)
{          
	u16 i,j;
	u16 xlen=0;
	u16 temp;

	xlen=ex-sx+1;
	
	for(i=sy;i<=ey;i++)
	{
		LCD_SetCursor(sx,i);      				//设置光标位置 
		LCD_WriteRAM_Prepare();     			//开始写入GRAM	  
		for(j=0;j<xlen;j++)	
		LCD_WriteRAM(color);
		
//		LCD->LCD_RAM=color;	//显示颜色 	    
	}
	
}  
/*******************************************************************************
//在指定区域内填充指定颜色块		YZ	 
//(sx,sy),(ex,ey):填充矩形对角坐标,区域大小为:(ex-sx+1)*(ey-sy+1)   
//color:要填充的颜色
*******************************************************************************/
void LCD_Color_Fill(u16 sx,u16 sy,u16 ex,u16 ey,u16 *color)
{  
	u16 height,width;
	u16 i,j;
	width=ex-sx+1; 			//得到填充的宽度
	height=ey-sy+1;			//高度
 	for(i=0;i<height;i++)
	{
 		LCD_SetCursor(sx,sy+i);   	//设置光标位置 
		LCD_WriteRAM_Prepare();     //开始写入GRAM
		for(j=0;j<width;j++)
		LCD_WriteRAM(color[i*width+j]);
		
//		LCD->LCD_RAM=color[i*width+j];//写入数据 
	}		  
} 

/*******************************************************************************
* Function Name  : DisplayPicture
* Description    :   
* Input          : 
* Output         : None
* Return         : None
*一下TFT的彩色,一个点占2个字节RGB565,也就是一个点可以有2^16种色调,一个个点组成了图片
* 图片为：２４０－３２０ 在屏中间显示
*******************************************************************************/
void DisplayPicture(void)
{
	u16 temp,pos,t;  

	BlockWrite(0,lcddev.width,0,lcddev.height);
	
//	BlockWrite((lcddev.width-240)/2,(lcddev.width+240)/2-1,(lcddev.height-320)/2,(lcddev.height+320)/2-1); //OK 20170927
  
	for(pos=0;pos<320;pos++) //(pos=0;pos<lcddev.height;pos++)
	{
		for(t=0;t<240*2;t++) //(t=0;t<lcddev.width*2;t++)
		{
			//temp=gImage[pos*lcddev.width*2+t]*256+gImage[pos*lcddev.width*2+t+1];  //这个地方  改成gImage[pos*480+t]<<8+gImage[pos*480+t+1];  好像有问题
			temp=gImage[pos*240*2+t]*256+gImage[pos*240*2+t+1];
		
			t++;                                
			LCD_WriteRAM(temp);      //理解这个函数  对摄像头那一章才能有真正的理解                            
		}                                
	}         	
	
}	


void DisplayPicture1(void)
{

	u16 temp,pos,t;  

//	BlockWrite(113,207,193,287);//OK 20170927
	BlockWrite((lcddev.width-128)/2,(lcddev.width+128)/2-1,(lcddev.height-128)/2,(lcddev.height+128)/2-1); //OK 20171005	
	
	for(pos=0;pos<128;pos++)
	{
		for(t=0;t<128*2;t++)
		{
			temp=gImage_128128[pos*128*2+t]*256+gImage_128128[pos*128*2+t+1];  
			t++;                                
			LCD_WriteRAM(temp);                                 
		}                                
	}

}	
/*******************************************************************************
//设置光标位置    MODIFY YZ
//Xpos:横坐标
//Ypos:纵坐标
*******************************************************************************/
void LCD_SetCursor(u16 Xpos, u16 Ypos)
{	 
	
//	LCD_Set(); 

//	LCD_WR_REG(lcddev.setxcmd); 
//	LCD_WR_DATA(Xpos>>8);LCD_WR_DATA(Xpos&0XFF); 			 
//	LCD_WR_REG(lcddev.setycmd); 
//	LCD_WR_DATA(Ypos>>8);LCD_WR_DATA(Ypos&0XFF); //此写法第一个点一直显示出来,奇怪 20170824

	LCD_WR_8REG(lcddev.setxcmd); 
	LCD_WR_8DATA(Xpos>>8);LCD_WR_8DATA(Xpos&0XFF); 			 
	LCD_WR_8REG(lcddev.setycmd); 
	LCD_WR_8DATA(Ypos>>8);LCD_WR_8DATA(Ypos&0XFF);   //OK20171005
	LCD_WR_8REG(0x2C);
	
} 


//以下为公共函数
/*******************************************************************************
//画点			modify	YZ
//x,y:坐标
//POINT_COLOR:此点的颜色
*******************************************************************************/
void LCD_DrawPoint(u16 x,u16 y)
{
	LCD_SetCursor(x,y);		//设置光标位置 
	
	LCD_WriteRAM(POINT_COLOR);
	
//	LCD->LCD_RAM=POINT_COLOR; 
	
	
}

/*******************************************************************************
//快速画点  modify YZ
//x,y:坐标
//color:颜色
*******************************************************************************/
void LCD_Fast_DrawPoint(u16 x,u16 y,u16 color)
{	  
	LCD_SetCursor(x,y);	

	LCD_WriteRAM(color);
	
//	LCD->LCD_RAM=color;	
	
}

/*******************************************************************************
//画线				YZ
//x1,y1:起点坐标
//x2,y2:终点坐标  
*******************************************************************************/
void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)
{
	u16 t; 
	int xerr=0,yerr=0,delta_x,delta_y,distance; 
	int incx,incy,uRow,uCol; 
	delta_x=x2-x1; //计算坐标增量 
	delta_y=y2-y1; 
	uRow=x1; 
	uCol=y1; 
	if(delta_x>0)incx=1; //设置单步方向 
	else if(delta_x==0)incx=0;//垂直线 
	else {incx=-1;delta_x=-delta_x;} 
	if(delta_y>0)incy=1; 
	else if(delta_y==0)incy=0;//水平线 
	else{incy=-1;delta_y=-delta_y;} 
	if( delta_x>delta_y)distance=delta_x; //选取基本增量坐标轴 
	else distance=delta_y; 
	for(t=0;t<=distance+1;t++ )//画线输出 
	{  
		LCD_DrawPoint(uRow,uCol);//画点 
		xerr+=delta_x ; 
		yerr+=delta_y ; 
		if(xerr>distance) 
		{ 
			xerr-=distance; 
			uRow+=incx; 
		} 
		if(yerr>distance) 
		{ 
			yerr-=distance; 
			uCol+=incy; 
		} 
	}  
}    

/*******************************************************************************
//画矩形	  YZ
//(x1,y1),(x2,y2):矩形的对角坐标
*******************************************************************************/
void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)
{
	LCD_DrawLine(x1,y1,x2,y1);
	LCD_DrawLine(x1,y1,x1,y2);
	LCD_DrawLine(x1,y2,x2,y2);
	LCD_DrawLine(x2,y1,x2,y2);
}

/*******************************************************************************
//在指定位置画一个指定大小的圆  YZ
//(x,y):中心点
//r    :半径
*******************************************************************************/
void LCD_Draw_Circle(u16 x0,u16 y0,u8 r)
{
	int a,b;
	int di;
	a=0;b=r;	  
	di=3-(r<<1);             //判断下个点位置的标志
	while(a<=b)
	{
		LCD_DrawPoint(x0+a,y0-b);             //5
 		LCD_DrawPoint(x0+b,y0-a);             //0           
		LCD_DrawPoint(x0+b,y0+a);             //4               
		LCD_DrawPoint(x0+a,y0+b);             //6 
		LCD_DrawPoint(x0-a,y0+b);             //1       
 		LCD_DrawPoint(x0-b,y0+a);             
		LCD_DrawPoint(x0-a,y0-b);             //2             
  		LCD_DrawPoint(x0-b,y0-a);             //7     	         
		a++;
		//使用Bresenham算法画圆     
		if(di<0)di +=4*a+6;	  
		else
		{
			di+=10+4*(a-b);   
			b--;
		} 						    
	}
} 

/*******************************************************************************
//在指定位置显示一个字符   YZ
//x,y:起始坐标
//num:要显示的字符:" "--->"~"
//size:字体大小 12/16/24
//mode:叠加方式(1)还是非叠加方式(0)
//解释：
//1、字符宽度(size/2)＝高度(size)一半。
//2、字符取模为竖向取模，即每列占几个字节，最后不够完整字节数的占一字节。
//3、字符所占空间为：每列所占字节＊列数。
//csize=(size/8+((size%8)?1:0))*(size/2)
//乘号*前为计算每列所占字节数，乘号*后为列数（字符高度一半）
*******************************************************************************/
void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)
{  							  
    u8 temp,t1,t;
	u16 y0=y;
	u8 csize=(size/8+((size%8)?1:0))*(size/2);		//得到字体一个字符对应点阵集所占的字节数	
 	num=num-' ';//得到偏移后的值（ASCII字库是从空格开始取模，所以-' '就是对应字符的字库）
	for(t=0;t<csize;t++)
	{   
		if(size==12)temp=asc2_1206[num][t]; 	 	//调用1206字体
		else if(size==16)temp=asc2_1608[num][t];	//调用1608字体
		else if(size==24)temp=asc2_2412[num][t];	//调用2412字体
		else return;								//没有的字库
		for(t1=0;t1<8;t1++)
		{			    
			if(temp&0x80)LCD_Fast_DrawPoint(x,y,POINT_COLOR);
			else if(mode==0)LCD_Fast_DrawPoint(x,y,BACK_COLOR);
			temp<<=1;
			y++;
			if(y>=lcddev.height)return;		//超区域了
			if((y-y0)==size)
			{
				y=y0;
				x++;
				if(x>=lcddev.width)return;	//超区域了
				break;
			}
		}  	 
	}  	    	   	 	  
}  

/*******************************************************************************
//m^n函数  YZ
//返回值:m^n次方.
*******************************************************************************/
u32 LCD_Pow(u8 m,u8 n)
{
	u32 result=1;	 
	while(n--)result*=m;    
	return result;
}	

/*******************************************************************************
//显示数字,高位为0,则不显示  YZ
//x,y :起点坐标	 
//len :数字的位数
//size:字体大小
//color:颜色 
//num:数值(0~4294967295);
*******************************************************************************/
void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)
{         	
	u8 t,temp;
	u8 enshow=0;						   
	for(t=0;t<len;t++)
	{
		temp=(num/LCD_Pow(10,len-t-1))%10;
		if(enshow==0&&t<(len-1))
		{
			if(temp==0)
			{
				LCD_ShowChar(x+(size/2)*t,y,' ',size,0);
				continue;
			}else enshow=1; 
		 	 
		}
	 	LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,0); 
	}
} 

/*******************************************************************************
//显示数字,高位为0,还是显示  YZ
//x,y:起点坐标
//num:数值(0~999999999);	 
//len:长度(即要显示的位数)
//size:字体大小
//mode:
//[7]:0,不填充;1,填充0.
//[6:1]:保留
//[0]:0,非叠加显示;1,叠加显示.
*******************************************************************************/
void LCD_ShowxNum(u16 x,u16 y,u32 num,u8 len,u8 size,u8 mode)
{  
	u8 t,temp;
	u8 enshow=0;						   
	for(t=0;t<len;t++)
	{
		temp=(num/LCD_Pow(10,len-t-1))%10;
		if(enshow==0&&t<(len-1))
		{
			if(temp==0)
			{
				if(mode&0X80)LCD_ShowChar(x+(size/2)*t,y,'0',size,mode&0X01);  
				else LCD_ShowChar(x+(size/2)*t,y,' ',size,mode&0X01);  
 				continue;
			}else enshow=1; 
		 	 
		}
	 	LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,mode&0X01); 
	}
} 

/*******************************************************************************
//显示字符串
//x,y:起点坐标
//width,height:区域大小  
//size:字体大小
//*p:字符串起始地址		
//说明：字符是有点组成的，故在字符函数中不断调用画点函数LCD_DrawPoint();来画点（往LCD->LCD_RAM里写颜色值，这个颜色值在lcd.h里被定义为16位的地址）。
*******************************************************************************/
void LCD_ShowString(u16 x,u16 y,u16 width,u16 height,u8 size,u8 *p)
{         
	u8 x0=x;
	width+=x;
	height+=y;
    while((*p<='~')&&(*p>=' '))//判断是不是非法字符!
    {       
        if(x>=width){x=x0;y+=size;}
        if(y>=height)break;//退出
        LCD_ShowChar(x,y,*p,size,0);
        x+=size/2;
        p++;
    }  
}

/***********************************End FUNCTION********************************************/

/*******************************************************************************
//SSD1963
*******************************************************************************/
/*******************************************************************************
//SSD1963 背光设置     ＹＺ
//pwm:背光等级,0~100.越大越亮.
*******************************************************************************/
void LCD_SSD_BackLightSet(u8 pwm)
{	
	LCD_WR_REG(0xBE);	//配置PWM输出
	LCD_WR_DATA(0x05);	//1设置PWM频率
	LCD_WR_DATA(pwm*2.55);//2设置PWM占空比
	LCD_WR_DATA(0x01);	//3设置C
	LCD_WR_DATA(0xFF);	//4设置D
	LCD_WR_DATA(0x00);	//5设置E
	LCD_WR_DATA(0x00);	//6设置F
}

void SSD1963_SetRGB(void)
{

	LCD_WR_REG(0xE2);		//Set PLL with OSC = 10MHz (hardware),	Multiplier N = 35, 250MHz < VCO < 800MHz = OSC*(N+1), VCO = 300MHz
	LCD_WR_DATA(0x1D);		//参数1 
	LCD_WR_DATA(0x02);		//参数2 Divider M = 2, PLL = 300/(M+1) = 100MHz
	LCD_WR_DATA(0x04);		//参数3 Validate M and N values   
	delay_us(100);
	LCD_WR_REG(0xE0);		// Start PLL command
	LCD_WR_DATA(0x01);		// enable PLL
	delay_ms(10);
	LCD_WR_REG(0xE0);		// Start PLL command again
	LCD_WR_DATA(0x03);		// now, use PLL output as system clock	
	delay_ms(12);  
	LCD_WR_REG(0x01);		//软复位
	delay_ms(10);
	
	LCD_WR_REG(0xE6);		//设置像素频率,33Mhz
	LCD_WR_DATA(0x2F);
	LCD_WR_DATA(0xFF);
	LCD_WR_DATA(0xFF);
	
	LCD_WR_REG(0xB0);		//设置LCD模式
	LCD_WR_DATA(0x20);		//24位模式
	LCD_WR_DATA(0x00);		//TFT 模式 

	LCD_WR_DATA((SSD_HOR_RESOLUTION-1)>>8);//设置LCD水平像素
	LCD_WR_DATA(SSD_HOR_RESOLUTION-1);		 
	LCD_WR_DATA((SSD_VER_RESOLUTION-1)>>8);//设置LCD垂直像素
	LCD_WR_DATA(SSD_VER_RESOLUTION-1);		 
	LCD_WR_DATA(0x00);		//RGB序列 
	
	LCD_WR_REG(0xB4);		//Set horizontal period
	LCD_WR_DATA((SSD_HT-1)>>8);
	LCD_WR_DATA(SSD_HT-1);
	LCD_WR_DATA(SSD_HPS>>8);
	LCD_WR_DATA(SSD_HPS);
	LCD_WR_DATA(SSD_HOR_PULSE_WIDTH-1);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x00);
	LCD_WR_REG(0xB6);		//Set vertical period
	LCD_WR_DATA((SSD_VT-1)>>8);
	LCD_WR_DATA(SSD_VT-1);
	LCD_WR_DATA(SSD_VPS>>8);
	LCD_WR_DATA(SSD_VPS);
	LCD_WR_DATA(SSD_VER_FRONT_PORCH-1);
	LCD_WR_DATA(0x00);
	LCD_WR_DATA(0x00);
	
	LCD_WR_REG(0xF0);	//设置SSD1963与CPU接口为16bit  
	LCD_WR_DATA(0x03);	//16-bit(565 format) data for 16bpp 

	LCD_WR_REG(0x29);	//开启显示
	//设置PWM输出  背光通过占空比可调 
	LCD_WR_REG(0xD0);	//设置自动白平衡DBC
	LCD_WR_DATA(0x00);	//disable

	LCD_WR_REG(0xBE);	//配置PWM输出
	LCD_WR_DATA(0x05);	//1设置PWM频率
	LCD_WR_DATA(0xFE);	//2设置PWM占空比
	LCD_WR_DATA(0x01);	//3设置C
	LCD_WR_DATA(0x00);	//4设置D
	LCD_WR_DATA(0x00);	//5设置E 
	LCD_WR_DATA(0x00);	//6设置F 
	
	LCD_WR_REG(0xB8);	//设置GPIO配置
	LCD_WR_DATA(0x03);	//2个IO口设置成输出
	LCD_WR_DATA(0x01);	//GPIO使用正常的IO功能 
	LCD_WR_REG(0xBA);
	LCD_WR_DATA(0X01);	//GPIO[1:0]=01,控制LCD方向
	
	LCD_SSD_BackLightSet(100);//背光设置为最亮

}
















